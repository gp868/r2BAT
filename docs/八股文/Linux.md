# Linux

# CPU占用过高如何检测？

1. 使用top命令可实时显示进程CPU百分比和内存使用情况，找出CPU占用较高的进程pid。

2. 查询进程中，哪个线程的cpu占用率高，记住TID：`ps -mp pid -o THREAD,tid,time`。

    其中，-m显示所有的线程，-p表示pid进程使用cpu的时间，-o表示该参数后是用户自定义格式，如：THREAD,tid,time表示线程、线程ID号、线程占用的时间。

3. 将TID转换为16进制格式（英文小写格式） `printf “%x\n” tid`

4. 通过`jstack`命令获取占用资源异常的线程栈：

    ```php
    jstack pid > jstack.pid.log #先保存文件，再从文件中查看
    或者
    jstack 514 |grep 202 -A 30  #直接命令行查看
    ```

5. 从上面日志文件或者命令行查看日志，从日志中能看到自己编写的代码的类和方法，一般情况是对应代码处产生了死循环。

# kill和kill -9的区别

kill和kill -9，两个命令在linux中都有杀死进程的效果。执行kill命令，系统会发送一个`SIGTERM`信号给对应的程序。程序接收到该信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应），也就是说，SIGTERM多半是会被阻塞的。而`kill -9`命令，系统给程序发送的信号是`SIGKILL`，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。

# 写时拷贝

写时拷贝（copy on write, COW）。

父进程 fork 出的子进程与父进程共享内存空间，一开始父进程的数据不会复制给子进程，这样创建子进程的速度就很快了 (不用复制，直接指向父进程的物理空间)。只有当父子进程中有写入操作，再为子进程分配相应的物理空间。

fork之后，内核把父进程中所有的内存页的权限设置为只读，然后子进程的地址空间指向父进程，与父进程共享数据。当父子进程都只读内存时，正常执行。当某个进程写内存时，CPU检测到内存页是只读的，就会触发页异常中断，内核就会把触发异常的页复制一份出来，这样父子进程就各自持有独立的异常页（其余的页还是共享父进程的）。

写时拷贝可以减少分配和复制大量资源时带来的时间消耗；检查不必要的资源分配，比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

# 命令

- 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)

  wc ：- c 统计字节数 - l 统计行数 - w 统计字数。

- scp：本地和远程互传文件

- ps：查看当前进程

- 怎么使一个命令在后台运行?

  使用 & 在命令结尾来让程序自动运行。(命令后可以不追加空格)

- job：查看后台任务

- lsof：查看所有被进程打开的文件

- 





- 介绍下nm与ldd命令

- shell命令查内存，端口 ，io访问量，读写速率

- awk grep具体应用

- 硬链接与软连接，目录可不可以用硬链接

- 常见命令netstat iptable tcpdump top

- makefile介绍下(cmake介绍下)

- gdb查看堆栈中所有遍历

- gdb查看shared_ptr

  指向的内容

- gdb如何调试多进程多线程

- g++和gcc编译出来有什么区别

- 死锁怎么调试

- core文件中是什么，gdb调试core文件

- 如何读取一个10G文件，cat一个10g文件会发生什么

