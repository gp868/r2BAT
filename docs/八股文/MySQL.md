# MySQL

# 索引

- 分类
  - 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引
  - 按「物理存储」分类：主键索引、二级索引
  - 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引
  - 按「字段个数」分类：单列索引、联合索引


- 主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

  - 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
  - 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。


- 联合索引的最左匹配原则

  联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。

  例子：

  `select * from t_table where a > 1 and b = 2`， a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引；

  `select * from t_table where a >= 1 and b = 2`，a 和 b 字段都用到了联合索引进行索引查询；

  `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，a 和 b 字段都用到了联合索引进行索引查询；

  `SELECT * FROM t_user WHERE name like 'j%' and age = 22`， a 和 b 字段都用到了联合索引进行索引查询；

- 什么时候适用索引？
  - 字段有唯一性限制的，比如商品编码；
  - 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
  - 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

- 什么时候不需要创建索引？
    - WHERE条件， GROUP BY， ORDER BY 里用不到的字段；
    - 字段中存在大量重复数据，不需要创建索引；
    - 表数据太少的时候，不需要创建索引；
    - 经常更新的字段不用创建索引；

- 如何优化索引

  - 前缀索引优化

    前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

  - 覆盖索引优化

    覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。

  - 主键索引最好是自增的

    如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。

    如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。

  - 防止索引失效

    - 使用左或者左右模糊匹配，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
    - 查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
    - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
    - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

- MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

  - B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

  - B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；

  - B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。


- 有哪些手段可以优化数据库的 SQL 查询效率？
  - 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引；
  - 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
  - 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；
  - 使用左或者左右模糊匹配，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
  - 应尽量避免在 where 子句中对字段进行表达式操作或者函数操作，这将导致引擎放弃使用索引而进行全表扫描；

- 主键和唯一索引的区别

  - 主键是一种约束，而唯一索引是一种索引；

  - 主键一定会创建一个唯一索引，有唯一索引的列不一定为主键；
  - 主键不允许空值，唯一索引列允许空值；
  - 一个表只能有一个主键，但是可以有多个唯一索引；
  - 主键可以被其它表引用为外键，唯一索引列不可以；

# 事务

- 事务的ACID特性：

  - 原子性（Atomicity）

    一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

  - 一致性（Consistency）

    数据库总是从一个一致性的状态转移到另一个一致性的状态。一致性确保了即使在执行第三、第四条语句之间时系统崩溃，前面执行的第一、第二条语句也不会生效，因为事务最终没有提交，所有事务中所作的修改也不会保存到数据库中。

  - 隔离性（Isolation）

    一个事务的执行不能其它事务干扰，一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

  - 持久性（Durability）

    事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。


- InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

  - 原子性是通过 undo log（回滚日志） 来保证的；

  - 一致性则是通过持久性+原子性+隔离性来保证；

  - 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
  - 持久性是通过 redo log （重做日志）来保证的；

- 并发事务引发的问题

  在同时处理多个事务的时候，就可能出现**脏读、不可重复读、幻读**的问题。

  - 脏读

    读到其他事务未提交的数据；

  - 不可重复读

    前后读取的数据不一致；

  - 幻读

    前后读取的记录数量不一致。

- 事务的隔离级别

  三种现象的严重性排序：脏读 > 不可重复读 > 幻读

  四种隔离级别：

  - 读未提交

    一个事务还没提交时，它做的变更就能被其他事务看到；

  - 读已提交

    一个事务提交之后，它做的变更才能被其他事务看到；

  - 可重复读

    一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；

  - 串行化

    会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

  隔离水平高低排序：串行化  > 可重复读 > 读已提交 > 读未提交，隔离级别越高，性能效率就越低。

  - 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
  - 在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
  - 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
  - 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

  所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。

  MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：

  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题；
  - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

  对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

  - 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
  - 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

  这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

# 语法

- 各关键字的使用顺序

  ```
  select--from--where--group by--having--order by--limit
  ```

- SELECT... FROM ...

- 去重：SELECT DISTINCT... FROM ...

- 顺序：SELECT ... FROM  ... ORDER BY ... （ASC省略）; 

- 倒序：SELECT ... FROM ... ORDER BY ... DESC; (descending order)

- 多变量排序

  ```mysql
  SELECT
      cust_id,
      order_num
  FROM
      Orders
  ORDER BY
      cust_id,
      order_date DESC;
  ```

- 范围筛选

  ```mysql
  SELECT 
      prod_name,
      prod_price
  FROM
      Products
  WHERE
      prod_price >= 3 AND prod_price <= 6
  ORDER BY
      prod_price;
  ```

  ```mysql
  SELECT 
      prod_name,
      prod_price
  FROM
      Products
  WHERE
      prod_price BETWEEN 3 AND 6
  ORDER BY
      prod_price;
  ```

  ```mysql
  SELECT
      order_num,
      prod_id,
      quantity
  FROM
      OrderItems 
  WHERE
      quantity >= 100
      AND
      prod_id in ('BR01', 'BR02', 'BR03');
  ```

- 筛选记录

  `LIMIT`关键字：

  ```mysql
  SELECT ... FROM ... LIMIT [offset,] rows
  ```

  `LIMIT`关键字⽤于强制 SELECT 语句返回指定的记录数。LIMIT 接受⼀个或两个数字参数，参数必须是⼀个整数常量。

  - 如果给定两个参数，第⼀个参数指定起始记录⾏的**偏移量**，第⼆个参数指定记录的**行数**；

    ```mysql
    SELECT * FROM table LIMIT 10, 5; // 从第11行开始记录5行数据
    SELECT * FROM table LIMIT 10, 1; // 显示第11行
    ```

  - 如果只给定⼀个参数，它表示返回从第一行开始记录行的数⽬；

    ```mysql
    SELECT * FROM score ORDER BY grade LIMIT 5
    // 显示成绩排名前5的j
    ```

  - `offset`关键字，后面的参数是记录行的**偏移量**；

    ```mysql
    select * from user limit 3 offset 1;
    // 取第2, 3, 4行三条数据
    select * from user limit 1 offset 4;
    // 取第 5 行数据
    ```

- 模糊查找

  关键词：like

  用法：[字符] like '%_[]'

  - %表示任何字符出现任意次数
  - _表示单个字符
  - []表示一个字符集

  ```mysql
  SELECT
      prod_name, 
      prod_desc
  FROM
      Products
  WHERE
      prod_desc LIKE '%toy%'; // 出现 toy 字段
  ```

  ```mysql
  SELECT
    prod_name,
    prod_desc
  FROM
    Products
  WHERE
    prod_desc NOT LIKE '%toy%' // 未出现 toy 字段
  ORDER BY
    prod_name;
  ```

  ```mysql
  SELECT
      prod_name,
      prod_desc
  FROM
      Products
  WHERE
      prod_desc LIKE '%toy%' AND prod_desc LIKE '%carrotS%' // 同时出现 toy 和 carrots 两个字段
  ```

  ```mysql
  SELECT
      prod_name,
      prod_desc
  FROM
      Products
  WHERE
      prod_desc LIKE '%toy%carrots%'; // 以先后顺序同时出现 toy 和 carrots 字段
  ```

  ```mysql
  SELECT 
      order_num,
      order_date
  FROM
      Orders
  WHERE
      order_date like '2020-01%' // 筛选出一月份的数据
  ORDER BY
      order_date
  ```

- 别名

  ```mysql
  SELECT 
      vend_id,
      vend_name vname,
      vend_address vaddress,
      vend_city vcity
  FROM
      Vendors
  ORDER BY
      vend_name
  ```

  ```mysql
  SELECT 
      prod_id,
      prod_price,
      prod_price * 0.9 sale_price
      round(prod_price * 0.9, 1) sale_price // 四舍五入保留一位小数
  FROM
      Products;
  ```

- 字符操作

  关键词：substring, concat, upper

  用法：

  - 字符串的截取：substring(字符串，起始位置，截取字符数）
  - 字符串的拼接：concat(字符串1，字符串2，字符串3,...)
  - 字母大写：upper(字符串）

  ```mysql
  SELECT
      cust_id,
      cust_name,
      upper(concat(substring(cust_name,1,2), substring(cust_city,1,3))) as user_login
  FROM
      Customers
  ```


- 聚合函数

  | 函数名   | COUNT | SUM  | AVG      | MAX    | MIN    |
  | -------- | ----- | ---- | -------- | ------ | ------ |
  | **作用** | 计数  | 求和 | 求平均值 | 最大值 | 最小值 |

  - MAX(column)：返回某列的最大值
  - MIN(column)：返回某列的最高值 
  - COUNT(column)：返回某列的总行数 
  - COUNT(*)：返回表的总行数
  - SUM(column)：返回某列的相加总和
  - AVG(column)：返回某列的平均值

- 聚合函数只作用非null，因为null数据不参与运算。

  ```mysql
  select avg(comm), avg(ifnull(comm, 0)) from emp;
  ```

  两个计算结果是不一样的，ifnull函数的作用就是发现值为null后将其值变为0。聚合函数使用时注意空值的情况，要配合`ifnull`函数使用。

- 分组 GROUP BY

  GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上通常配合 COUNT, SUM, AVG等函数一起使用。

  例如：求每个部门所有工资总和。通过deptno字段对表数据进行分组后，然后通过sum(sal)来计算每个分组的总和。

  ```mysql
  SELECT
  	deptno, SUM(sal)
  FROM 
  	emp
  GROUP BY
  	deptno;
  ```

  例如：查询每个部门工资大于1500的的人数。

  ```mysql
  SELECT
  	deptno, COUNT(*)
  FROM 
  	emp
  WHERE
  	sal > 1500
  GROUP BY
  	deptno;
  ```

- HAVING

  HAVING用于**分组后**的再次筛选，只能用于分组。

  例如：求工资总和大于9000的部门，并按照工资总和排序。

  ```mysql
  SELECT
  	deptno, SUM(sal)
  FROM 
  	emp
  GROUP BY
  	deptno
  HAVING
  	SUM(sal) > 9000
  ORDER BY
  	SUM(sal);
  ```

  - **having和where区别：**

  1. having用在分组后，where用在分组前；
  2. where不能使用聚合函数，having可以使用聚合函数；
  3. where在分组之前就会进行筛选，过滤掉的数据不会进入分组；

# 其他

- MySQL最左匹配原则

最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。例如某表现有索引(a,b,c)，现在你有如下语句：

```mysql
select * from t where a=1 and b=1 and c=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b,c
select * from t where a=1 and b=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b
select * from t where b=1 and a=1;     #这样可以利用到定义的索引（a,b,c）,用上a,c（mysql有查询优化器）
select * from t where a=1;     #这样也可以利用到定义的索引（a,b,c）,用上a
select * from t where b=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）
select * from t where a=1 and c=1;     #这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到
```

也就是说通过最左匹配原则你可以定义一个联合索引，使得多种查询条件都可以用到该索引。但是当遇到范围查询(>、<、between、like)就会停止匹配，也就是：

```mysql
select * from t where a=1 and b>1 and c =1; #这样a,b可以用到（a,b,c），c索引用不到 
```

这条语句只有 a,b 会用到索引，c 都不能用到索引，原因可以从联合索引的结构来解释。但是如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句。

```mysql
select * from t where a=1 and b >1 and c=1;  #如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引
#优化器改写为
select * from t where a=1 and c=1 and b >1;
```

这也是最左前缀原理的一部分，索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询。a,c也走，但是只走a字段索引，不会走c字段。另外还有一个特殊情况，`select * from table where a = 1 and b > 2 and c = 3`这种类型的也只会有 a与b 走索引，c不会走。像这种类型的sql语句，在a、b走完索引后，c肯定是无序了，所以c就没法走索引，数据库会觉得还不如全表扫描c字段来的快。

以index （a,b,c）为例建立这样的索引相当于建立了索引a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。

索引的底层是一颗 B+ 树，那么联合索引当然还是一颗 B+ 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 B+ 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+ 树。

一个形如(a,b,c)联合索引的 b+ 树，其中的非叶子节点存储的是第一个关键字的索引 a，而叶子节点存储的是三个关键字的数据。这里可以看出 a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，b 相同的时候，c 又是有序的。

以 `select * from t where a=5 and b>0 and c=1; #这样a,b可以用到（a,b,c），c不可以` 为例子，当查询到 b 的值以后（这是一个范围值），c 是无序的，所以就不能根据联合索引来确定该取哪一行。

也就是说，在 InnoDB 中联合索引只有先确定了前一个（左侧的值）后，才能确定下一个值。如果有范围查询的话，那么联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用。

- 为什么要使用联合索引

1、减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！

2、覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。

3、效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！

- 主键和唯一索引的区别

  - 主键是一种约束，而唯一索引是一种索引；

  - 主键一定会创建一个唯一索引，有唯一索引的列不一定为主键；
  - 主键不允许空值，唯一索引列允许空值；
  - 一个表只能有一个主键，但是可以有多个唯一索引；
  - 主键可以被其它表引用为外键，唯一索引列不可以；

- InnoDB 的普通索引和主键索引有什么区别

  Mysql各种索引区别：

  - 普通索引：最基本的索引，没有任何限制

  - 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。

  - 主键索引：它是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；索引列的值必须是唯一的。简单来说：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个；

  - 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。

  - 联合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。

- MySQL用char和varchar什么区别？

  1. varchar比char更节省空间。

     varchar类型用于存储可变长度字符串，实际存储的空间=字符串内容+字符串长度，需要使用1或2个额外字节记录字符串的长度。char类型是固定长度的，一旦定义了字段类型char(10)，哪怕只是存了3个字符，那么也是用了10个字符长度的存储空间，其中7个为空字符/无效字符。

  2. char的性能比varchar要更好。

     char根据定义的字符串长度分配了足够的空间。varchar在更新长度时（比原来长度更长），有可能导致分裂页，导致出现碎片问题。根据存储结构的特性，也导致了更新数据时，char的性能比varchar要更好。

  3. 适合varchar的场景：

     - 字符串的最大长度比平均长度大很多；

     - 列的更新很少，所以碎片不是问题。

  4. 适合char的场景:

     - 存储很短的字符串或者所有值都接近同一个长度，例如md5、ip等信息。

     - 经常变更的数据，不容易产生碎片。



