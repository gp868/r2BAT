# cpp

# 语言基础

## C和C++区别

C++是面向对象的语言，而C是面向过程的结构化编程语言；

C++具有封装、继承和多态三种特性；

C++相比C，增加了许多类型安全的功能，比如强制类型转换；

C++支持范式编程，比如模板类、函数模板等；

函数方面 C++ 中有重载和虚函数的概念，用以实现多态；

C++ 中增加了模板还重用代码，提供了更加强大的 STL 标准库。

## 内存模型

### **C/C++内存有哪几种类型？**

C++ 内存分区：**栈、堆、全局/静态存储区、常量存储区、代码区**。

**栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。

**堆**：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。

**全局区/静态存储区（.bss 段和 .data 段）**：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在.bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。

**常量存储区（.data 段**）：存放的是常量，不允许修改，程序运行结束自动释放。

**代码区（.text 段）**：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

### **堆和栈的区别**

申请方式：栈是系统自动分配，堆是程序员主动申请。

存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制；

空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的；

碎片问题不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出；

分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现；

分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的奇存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。

申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上；

栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。

默认的栈空间大小为1M（64位和32位系统），可通过CreatThread参数列表改变线程的StackSize，最大支持线程数 = 内存/StackSize。

堆：与64位/32位有关，与编译器有关，受限于计算机系统中有效的虚拟内存。理论上，32位系统，堆内存可以达到4G的空间，但是堆最大也没有4G，因为整个进程的映像空间有一部分被映射给操作系统，另外栈也占据了一部，全局、静态变量再占据一部分，还有其他代码数据占据一部分。操作系统中有记录空闲内存地址的链表，申请时，寻找第一个空间大于申请空间的堆。

### 如何定义一个只能在堆（栈）上生成对象的类?

1. 只能在堆上生成对象：将析构函数设置为私有。 

   原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 

2. 只能在栈上生成对象：将new 和 delete 重载为私有。 

   原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。 将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。 

## 程序编译的过程

编译过程分为四个过程：**编译预处理，编译，汇编，链接**。

**编译预处理**：处理以 # 开头的指令；

**编译、优化**：将源码 .cpp 文件翻译成 .s 汇编代码；

**汇编**：将汇编代码 .s 翻译成机器指令 .o 文件；

**链接**：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe文件。

链接分为两种：

**静态链接**：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。

**动态链接**：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

二者的优缺点：

**静态链接**：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。

**动态链接**：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

## 内存泄漏

1. **什么是内存泄露**

内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。
进一步解释：

- 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
- 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
- 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。
- 指针重新赋值

```php
char *p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = np;
```

开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。

2. **怎么防止内存泄漏？**

**防止内存泄漏的方法：**

- **内部封装**：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）；

- **智能指针**：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。

## 指针和引用

### 区别

指针和引用都是一种内存地址的概念，区别：指针是一个实体，引用只是一个别名。

在程序编译的时候，将指针和引用添加到符号表中。

指针指向一块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷贝和赋值，有 const 和非 const 区别，甚至可以为空，sizeof 指针得到的是指针类型的大小。

而对于引用来说，它只是一块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑定到一块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别。

sizeof 引用得到代表对象的大小，而 sizeof 指针得到的是指针本身的大小。另外在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行的修改会直接作用到引用对象上。

作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。

### 使用场景

1. 如果使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时应该把变量声明为指针，因为这样可以赋空值给该变量；

2. 如果变量肯定指向一个对象，例如设计中不允许变量为空，这时就可以把变量声明为引用；

3. 重载操作符时应当返回引用（主要是为了减少不必要开销，引用效率高）；

4. 引用主要是作为函数的参数和返回值来使用的。

## static、const、#define宏定义

### **static关键字**

static修饰**局部变量**：变量存放在静态数据区，其生命周期会一直延续到整个程序执行结束；

static修饰**全局变量**：会改变变量的作用域范围，变量只在本文件内部有效，对其他文件不可见；  

static修饰**函数**：会改变函数的作用域，函数只在本文件内部有效，对其他文件不可见；

static修饰**类**：如果对类中的某个函数用 static  修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行 static 修饰，则表示该变量是类中所有对象所共有的，存储空间中只存在一个副本，可以通过类和对象去调用；

（类外定义和初始化，在类内仅是声明而已）

### **const关键字**

const修饰**常量**：定义时就初始化，以后不能更改；

const修饰**指针变量**和**引用变量**：如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果 const 位于星号的右侧，则 const 就是修饰指针本身，即指针本身是常量；

const修饰函数的**形参**：func(const int a)，该形参在函数里不能改变； 

const修饰**类成员变量**：const 成员变量，只在某个对象生命周期内是常量，而对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同，所以不能在类的声明中初始化 const 成员变量，因为类的对象在没有创建时候，编译器不知道 const 成员变量的值是什么，const 成员变量的初始化只能在类的构造函数的初始化列表中进行。

const修饰**类成员函数**：防止成员函数修改对象的内容。要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使用的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数又必须具体到某一个函数。

const 修饰**类对象**，定义常量对象：常量对象只能调用**常量函数**，不能调用非常量函数。而非常量对象可以调用类中的常量函数，也可以调用非常量函数。

**原因**：对象调用成员函数时，在形参列表的最前面加一个形参 this，但这是隐式的。this 指针是默认指向调用函数的当前对象的，所以，this 是一个常量指针，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即小括号）后加了 const 关键字（void print() const;），此成员函数为**常量函数**，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。

### **const和宏定义的区别**

对于 `define `来说， 宏定义实际上是在预编译阶段进行处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进行字符替换，遇到多少次就字符替换，而且这个简单的字符替换过程中，很容易出现边界效应，达不到预期的效果。因为 define 宏定义仅仅是字符替换，因此运行时系统并不为宏定义分配内存，但是从汇编的角度来讲，define 以立即数的方式保留了多份数据的拷贝。

对于 `const `来说， const 是在编译期间进行处理的，const 有类型，也有类型检查，程序运行时系统会为 const 常量分配内存，而且从汇编的角度讲，const 常量在出现的地方保留的是真正数据的内存地址，只保留了一份数据的拷贝，省去了不必要的内存空间。而且，有时编译器不会为普通的 const 常量分配内存，而是直接将 const 常量添加到符号表中，省去了读取和写入内存的操作，效率更高。

## volatile 和 extern 关键字

**volatile 的作用**：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化。volatile不具有原子性。

**volatile 对编译器的影响**：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，每次使用该变量必须从内存地址中读取，而不是保存在寄存器中的备份。防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

用到volatile的几种情况：

- 并行设备的硬件寄存器（如状态寄存器）
- 中断服务子程序会访问到的非自动变量
- 多线程应用中被几个任务共享的变量

**volatile 三个特性**

易变性：在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的 volatile 变量的寄存器内容，而是重新从内存中读取。

不可优化性：volatile 告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。

顺序性：能够保证 volatile 变量之间的顺序性，编译器不会进行乱序优化。

**extern**

在 C 语言中，修饰符 extern 用在变量或者函数的声明前，用来说明 “此变量/函数是在别处定义的，要在此处引用”。

注意 extern 声明的位置对其作用域也有关系，如果是在 main 函数中进行声明的，则只能在 main 函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用 #include 包含进来即可，为啥要用 extern？因为用 extern 会加速程序的编译过程，这样能节省时间。

在 C++ 中 extern 还有另外一种作用，用于指示 C 或者 C++函数的调用规范。比如在 C++中调用 C 库函数，就需要在 C++程序中用 extern “C” 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C 函数规范来链接。主要原因是 C++和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。

## #define和inline

- inline 函数工作原理

inline 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。

普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。

- 宏定义（define）和内联函数（inline）的区别

1. 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。

2. 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。

3. 宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。

## new/delete  malloc/ free

- **malloc/free底层原理**

在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、munmap这些系统调用实现的；

malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。


malloc的底层实现 ：

- 开辟空间小于128K时，通过**brk()函数**    
  - 将数据段.data的最高地址指针**_edata**向高地址移动，即**增加堆**的有效区域来申请内存空间
  - brk分配的内存需要等到高地址内存释放以后才能释放，这也是内存碎片产生的原因
- 开辟空间大于128K时，通过**mmap()函数**
  - 利用mmap系统调用，在堆和栈之间**文件映射区域**申请一块虚拟内存
  - 128K限制可由M_MMAP_THRESHOLD选项进行修改
  - mmap分配的内存可以单独释放
- 以上只涉及虚拟内存的分配，直到进程第一次访问其地址时，才会通过缺页中断机制分配到物理页中

**malloc 申请的内存，free 释放内存会归还给操作系统吗？**

malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

**为什么不全部使用 mmap 来分配内存？**

频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。

**为什么不全部使用 brk 来分配？**

如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存空间，如果下次申请的内存小于 30k，那么就可以重用这个空闲内存空间。但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。

随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致内存泄露。所以，malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。

- **new/delete底层原理**

new和 delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。

- 内置类型：
  如果申请的是内置类型的空间，new和malloc，delete和free基本类似。不同之处：new在申请空间失败时会抛异常，malloc在申请空间失败时会返回NULL。
- 自定义类型：
  - new的原理：
    1. 调用operator new函数申请空间；
    2. 在申请的空间上执行构造函数，完成对象的构造；
  - delete的原理：
    1. 在空间上执行析构函数，完成对象中资源的清理工作；
    2. 调用operator delete函数释放对象的空间；
  - new[N]的原理：
    1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请；
    2. 在申请的空间上执行N次构造函数；
  - delete[N]的原理：
    1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理；
    2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间；

- **区别**

new、delete是C++中的操作符需要编译器支持，而malloc和free是标准库函数，需要加入头文件 stdlib.h。

malloc需要自行指定动态分配内存的大小，而new在指定指针类型之后可以自动分配内存，无需指定大小。

malloc返回的指针需要进行强制类型转换，而new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换；

new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型的指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

malloc / free是库函数而不是运算符，只能动态的申请和释放内存，不在编译器控制范围之内，不能够自动调用构造函数和析构函数，无法强制要求其做自定义类型对象构造和析构工作（对于C++来说）。

## 智能指针

1. **智能指针的作用**

   智能指针的作用是**管理一个指针**，避免程序员申请的空间在函数结束时忘记释放，造成**内存泄漏**。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

   如果在程序中使用 new 从堆（自由存储区）分配内存，等到不再需要时，应使用 delete 将其释放，如果忘记释放，则会产生内存泄露。C++ 引入了智能指针 auto_ptr（C++98）， 以帮助自动完成这个过程。智能指针是行为类似于指针的类对象。

3. **有哪些智能指针**

   C++ 中有 4 种智能指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr。其中 auto_ptr 在 C++11 中被弃用，weak_ptr 需要配合 shared_ptr 使用，并不能算是真正的智能指针。

3. **智能指针实现原理**

   智能指针解决问题的思想：将常规指针进行封装，当智能指针对象过期时，让它的析构函数对常规指针进行内存释放。

   - **auto_ptr**

   auto_ptr（C++98的方案，C++11已经废弃）：采用所有权模式，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的析构函数会删除该对象。然后，让赋值操作转让所有权。

   - **unique_ptr**

   unique_ptr（替代 auto_ptr）：也是采用所有权模式，实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。

   - **shared_ptr**

   shared_ptr：采用引用计数实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁时候释放。它使用引用计数来表明资源被几个指针共享。例如，赋值时，计数将加 1，而指针过期时，计数将减 1。仅当最后一个指针过期时，才调用 delete。当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致**内存泄漏**。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

   - **weak_ptr**

   weak_ptr：该类型指针通常不单独使用，只能和 shared_ptr 类型指针搭配使用。weak_ptr  类型指针并不会影响所指堆内存空间的引用计数，可以用来解**决循环引用问题**。

   为了**解决循环引用导致的内存泄漏**，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，可以检测到所管理的对象是否已经被释放，从而避免非法访问。

   weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 `lock `函数来获得shared_ptr。

   当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（析构函数没有被调用），解决办法：把其中一个改为weak_ptr就可以。

5. **如何选择智能指针**

   如果程序要使用多个指向同一个对象的指针，应该选择 shared_ptr；

   如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr;

   如果使用 new [] 分配内存，应该选择 unique_ptr;

   如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。

5. **shared_ptr底层**

   shared_ptr的实现机制是在拷贝构造时使⽤同⼀份引⽤计数：

   （1）⼀个模板指针T* ptr，指向实际的对象；

   （2）⼀个引⽤次数，必须**new**出来的，不然会多个shared_ptr⾥⾯会有不同的引⽤次数⽽导致多次delete；

   （3）重载拷贝构造函数，使其引⽤次数加⼀；

   （4）重载析构函数，使引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)；

   （5）重载operator=（赋值运算符），如果原来的shared_ptr已经有对象，则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加⼀；

   （6）重载operator*（解引用运算符）和operator->（获取指针运算符），使得能像指针⼀样使⽤shared_ptr；

   代码实现：

```php
template<typename T>
class SharedPtr{
public:
    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1)){}
    // 拷贝构造函数
    SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
    	(*_pcount)++;
    }
    // 析构函数
    ~SharedPtr(){
        if (--(*(this->_pcount)) == 0){
            delete _ptr;
            delete _pcount;
            _ptr = NULL;
            _pcount = NULL;
        }
    }
    // 重载operator=（赋值运算符）
    SharedPtr<T>& operator=(const SharedPtr& s){
        if (this != &s){
            if (--(*(this->_pcount)) == 0){
                delete this->_ptr;
                delete this->_pcount;
            }
            _ptr = s._ptr;
            _pcount = s._pcount;
            *(_pcount)++;
        }
        return *this;
	}
    // 重载operator*
    T& operator*(){
        return *(this->_ptr);
    }
    // 重载operator->
    T* operator->(){
        return this->_ptr;
    }
private:
	T* _ptr;
	int* _pcount;	//指向引用计数的指针
};    
```

**线程安全问题**

[为什么多线程读写 shared_ptr 要加锁？ - 陈硕的Blog - C++博客 (cppblog.com)](http://www.cppblog.com/Solstice/archive/2013/01/28/197597.html)

shared_ptr的引用计数本身是线程安全（引用计数是原子操作）。
多个线程同时**读**同一个shared_ptr对象是线程安全的，如果是多个线程对同一个shared_ptr进行**读和写**，则需要加锁。
多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的，都需要加锁保护，因为shared_ptr有两个数据成员，读写操作不能原子化，使得多线程读写同一个shared_ptr对象需要加锁。

防止出现指针空悬。

6. **weak_ptr底层**

weak_ptr是为了配合shared_ptr⽽引⼊的⼀种智能指针，它的最⼤作⽤在于协助shared_ptr⼯作，像旁观者那样观测资源的使⽤情况，但weak_ptr没有共享资源，它的构造不会引起指针引⽤计数的增加。weak_ptr和shared_ptr指向相同内存，shared_ptr析构之后内存释放，在使⽤之前使⽤函数lock()检查weak_ptr是否为空指针。

shared_ptr和weak_ptr主要区别如下：

- shared_ptr对象能够初始化实际指向一个地址内容，而weak_ptr对象没办法直接初始化，需要用一个shared_ptr实例来初始化weak_ptr；

- weak_ptr不会影响shared_ptr的引用计数，因为它是一个弱引用，只是一个临时引用指向shared_ptr。即使用shared_ptr对象初始化weak_ptry也不会导致shared_ptr引用计数增加，依此特性可以解决shared_ptr的**循环引用**问题；

- weak_ptr没有解引用*和获取指针->运算符，它只能通过lock成员函数去获取对应的shared_ptr智能指针对象，从而获取对应的地址和内容。

7. **unique_ptr底层**

unique_ptr”唯⼀”拥有其所指对象，同⼀时刻只能有⼀个unique_ptr指向给定对象，离开作⽤域时，若其指向对象，则将其所指对象销毁（默认delete）。定义unique_ptr时需要将其绑定到⼀个new返回的指针上。

unique_ptr不⽀持普通的拷⻉和赋值，因为拥有指向的唯一对象，但是可以拷⻉和赋值⼀个将要被销毁的unique_ptr。可以通过release或者reset将指针所有权从⼀个（⾮const）unique_ptr 转移到另⼀个unique_ptr 。

一个unique_ptr怎么赋值给另一个unique_ptr对象？（std::move） 

借助 **std::move()** 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。

```cpp
// A 作为一个类 
std::unique_ptr<A> ptr1(new A());
std::unique_ptr<A> ptr2 = std::move(ptr1);
```

8. 初始化一个智能指针的三种方法：

```php
// 利用构造函数来初始化
std::shared_ptr<int> sp1(new int(123));
 
// 利用智能指针的reset方法来初始化
std::shared_ptr<int> sp2;
sp2.reset(new int(123));
 
// 利用make_shared函数来初始化
std::shared_ptr<int> sp3;
sp3 = std::make_shared<int>(123);
```

##  C++11的新特性

nullptr替代 NULL；引入了 auto 和 decltype 这两个关键字实现了类型推导；基于范围的 for 循环for(auto& i : res){}；类和结构体的中初始化列表；Lambda 表达式（匿名函数）；std::forward_list（单向链表）；右值引用和move语义。

**1. auto 类型推导**
auto 关键字：自动类型推导，编译器会在 **编译期间** 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。

**2. decltype 类型推导**
decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在**编译时期**进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。

auto和decltype的区别：

```php
auto var = val1 + val2; 
decltype(val1 + val2) var1 = 0; 
```

- auto 根据 **=** 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。
- auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。

**3. lambda 表达式**
lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。

lambda匿名函数的定义:

```php
[capture list] (parameter list) -> return type
{
   function body;
};
```

其中：

- capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。
- return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

```php
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int arr[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行升序排序
    sort(arr, arr+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : arr){
        cout << n << " ";
    }
    return 0;
}
```

**4. 范围 for 语句**

```php
for (declaration : expression){
    statement
}
```

参数的含义：

- expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。
- declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。

for循环后的括号被冒号”:”分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。它与普通循环类似，可以用 continue来结束本次循环，也可以用break来跳出整个循环。

1. for循环迭代的范围是确定的。对于数组而言就是数组第一个元素和最后一个元素的范围；对于类来说，应该提供begin和end方法，begin和end就是for循环迭代的范围；

2. 迭代的对象要实现++和==操作符。注意：基于范围的for循环使用于标准库的容器时，如果使用auto来声明迭代的对象，那么这个对象不会是迭代器对象，如：

   ```php
   std::vector v{ 1, 2, 3, 4, 5 };
   for (auto e : v) 
   	cout << e << " "; // e为解引用后的对象，不是迭代器
   ```

**5. 右值引用**
右值引用：绑定到右值的引用，用 **&&** 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。

```php
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int var = 42;
    int &l_var = var;
    int &&r_var = var; // 错误：不能将右值引用绑定到左值上

    int &&r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上
    return 0;
}
```

左值：指表达式结束后依然存在的持久对象，右值：表达式结束就不再存在的临时对象，左值和右值的区别：左值持久，右值短暂。

右值引用和左值引用的区别：

- 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
- 右值引用必须绑定到右值的引用，通过 **&&** 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

**std::move** 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。

```php
#include <iostream>
using namespace std;

void fun1(int& tmp) { 
  cout << "fun1(int& tmp):" << tmp << endl; 
} 

void fun2(int&& tmp) { 
  cout << "fun2(int&& tmp)" << tmp << endl; 
} 

int main() { 
  int var = 11; 
  fun1(12); // 错误：不能将左值引用绑定到右值上
  fun1(var);// 正确
  fun2(1); 	// 正确
}
```

**6. 标准库 move() 函数**
move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。

**std::move()** 函数原型：

```cpp
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type &&>(t);
}
```

说明：引用折叠原理

- 右值传递给上述函数的形参 T&& 依然是右值，即 T&& && 相当于 T&&。
- 左值传递给上述函数的形参 T&& 依然是左值，即 T&& & 相当于 T&。

小结：通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。

**remove_reference** 具体实现：

```php
//原始的，最通用的版本
template <typename T> struct remove_reference{
    typedef T type;  //定义 T 的类型别名为 type
};
 
//部分版本特例化，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> //左值引用
{ typedef T type; }
 
template <class T> struct remove_reference<T&&> //右值引用
{ typedef T type; }   
  
//举例如下,下列定义的a、b、c三个变量都是int类型
int i;
remove_refrence<decltype(42)>::type a;             //使用原版本，
remove_refrence<decltype(i)>::type  b;             //左值引用特例版本
remove_refrence<decltype(std::move(i))>::type  b;  //右值引用特例版本 
```

举例：

```php
int var = 10; 

转化过程：
1. std::move(var) => std::move(int&& &) => 折叠后 std::move(int&)
2. 此时：T 的类型为 int&，typename remove_reference<T>::type 为 int，这里使用 remove_reference 的左值引用的特例化版本
3. 通过 static_cast 将 int& 强制转换为 int&&

整个std::move被实例化如下
string&& move(int& t) 
{
    return static_cast<int&&>(t); 
}
```

总结std::move() 实现原理：

- 利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&&变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；
- 然后通过 remove_refrence 移除引用，得到具体的类型 T；
- 最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。

**7. 智能指针**
相关知识已在前面中进行了详细的说明，这里不再重复。

**8. delete 函数和 default 函数**

- delete 函数：`= delete` 表示该函数不能被调用。
- default 函数：`= default` 表示编译器生成默认的函数，例如：生成默认的构造函数。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	A() = default; // 表示使用默认的构造函数
	~A() = default;	// 表示使用默认的析构函数
	A(const A &) = delete; // 表示类的对象禁止拷贝构造
	A &operator=(const A &) = delete; // 表示类的对象禁止拷贝赋值
};
int main()
{
	A ex1;
	A ex2 = ex1; // error: use of deleted function 'A::A(const A&)'
	A ex3;
	ex3 = ex1; // error: use of deleted function 'A& A::operator=(const A&)'
	return 0;
}
```

## 四种强制转换

C++ 的四种强制转换包括：**static_cast, dynamic_cast, const_cast, reinterpret_cast**

基本用法：`static_cast<type-id> expression`，其他类似`xxx_cast<newType>(data)`。

**static_cast**

- 使用场景：

a、用于类层次结构中基类和派生类之间指针或引用的转换

上行转换（派生类---->基类）是安全的；

下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的。

b、用于基本数据类型之间的转换，如把int转换为char，这种带来安全性问题由程序员来保证

c、把空指针转换成目标类型的空指针

d、把任何类型的表达式转为void类型

- 使用特点

a、主要执行非多态的转换操作，用于代替C中通常的转换操作；

b、隐式转换都建议使用static_cast进行标明和替换。

**dynamic_cast**

专门用于派生类之间的转换，type-id 必须是类指针，类引用或 void*，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的事错误意义的指针，可能造成非法访问等问题。

- 使用场景：只有在派生类之间转换时才使用dynamic_cast，type-id必须是类指针，类引用或者void*。

- 使用特点：

a、基类必须要有虚函数，因为dynamic_cast是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表（如果一个类没有虚函数，那么一般意义上，这个类的设计者也不想它成为一个基类）。

b、对于下行转换，dynamic_cast是安全的（当类型不一致时，转换过来的是空指针），而static_cast是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题）

c、dynamic_cast还可以进行交叉转换

**const_cast**

专门用于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯一一个可以操作常量的转换符。

- 使用场景：

a、常量指针转换为非常量指针，并且仍然指向原来的对象

b、常量引用被转换为非常量引用，并且仍然指向原来的对象

- 使用特点：

a、cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符

b、去除常量性是一个危险的动作，尽量避免使用。一个特定的场景是：类通过const提供重载时，一般都是非常量函数调用`const_cast<const T>`将参数转换为常量，然后调用常量函数，然后得到结果再调用`const_cast <T>`去除常量性。

**reinterpret_cast**

不到万不得已，不要使用这个转换符，高危操作。使用特点：从底层对数据进行重新解释，依赖具体的平台，可移植性差；可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引用之间进行肆无忌惮的转换。

- 使用场景：不到万不得已，不用使用这个转换符，高危操作

- 使用特点：　　

a、reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差

b、reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组

c、reinterpret_cast可以在指针和引用里进行肆无忌惮的转换

> 自动类型转换（隐式）：利用编译器内置的转换规则，或者用户自定义的转换构造函数以及类型转换函数（这些都可以认为是已知的转换规则）。例如从 int 到 double、从派生类到基类、从type *到void *、从 double 到 Complex 等。type *是一个具体类型的指针，例如int *、double *、Student *等，它们都可以直接赋值给void *指针。例如，malloc() 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量。
>
> 强制类型转换（显式）：隐式不能完成的类型转换工作，就必须使用强制类型转换：(new_type) expression。
>
> 数据类型转换的本质：对数据所占用的二进制位做出重新解释。
>
> 隐式类型转换：编译器可以根据已知的转换规则来决定是否需要**修改**数据的二进制位。
>
> 强制类型转换：由于没有对应的转换规则，所以能做的事情仅仅是**重新解释**数据的二进制位，但无法对数据的二进制位做出修正。

## class 和 struct 的异同

struct 和 class 都可以自定义数据类型，也支持继承操作。

struct 中默认的访问级别是 public，默认的继承级别也是 public；class 中默认的访问级别是 private，默认的继承级别也是 private。

当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身，class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。

class 可以用于定义模板参数，struct 不能用于定义模板参数。

## memset, memcpy, strcpy函数

strcpy函数的原型：`char* strcpy(char* dest, const char* src)`， strcpy的作用是拷贝字符串，当它遇到'`\0`'时结束拷贝。

memcpy函数的原型：`void *memcpy( void *dest, const void *src, size_t count )`，memcpy用来做内存拷贝，可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度。

memset函数的原型：`memset(void *s, int ch,size_t n)`，memset的作用是对一段内存空间全部设置为某个字符，常用在内存空间的初始化。

strcpy，memcpy和memset主要有以下三点区别：

1. 复制内容不同，strcpy只能复制字符串，而memcpy可以复制任一内容，比如整形、结构体等。所以在复制字符串时会用strcpy(因为效率原因)，而复制其他类型数据一般会用memcpy。

2. 从参数可以看出复制方法也不尽相同。strcpy不需要指定特定长度，遇到“\0”才会结束，所以使用不当容易造成溢出。memcpy则是根据第三个参数决定复制长度。

3. 将s中当前位置后面的n个字节用 ch 替换并返回 s，作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零的一种快速操作。


## 其他

- `cout << res;` 为什么可以输出到屏幕上，中间那个符号是什么？

  cout是一个对象，它的作用是把通过`<<`输入它的消息显示在屏幕上，cout<<"aa"这句语句的含义就是把字符串"aa"插入到输出流中去，插入之后对象cout会把插入的流显示到屏幕上。

  `<<`这里是使用了运算符重载，`<<`被重载成了插入运算符，`<<`在这里的作用就是把右边的信息以流的方式插入左边的cout中。

  `endl`是一个特殊的C++符号，表示重启一行。`endl`也被定义在`iostream`中，位于命名空间`std`中。`endl`确保程序继续运行前刷新输出，`'\n'`不能提供这样的保证，意味着在有些系统中，有时可能在你输入信息后才显示。

- gcc和g++的区别

  1. gcc与g++都可以编译c代码与c++代码。但是后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。

  2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的。但是因为gcc命令不能自动和C++程序使用的库链接，所以通常用g++来完成链接。

  3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C++程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

     ```php
     gcc main1.cpp -lstdc++
     ```

# 面向对象

## 三大特性

C++ 面向对象的三大特征是：封装、继承、多态。

**封装**

就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让信任的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。

在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

**继承**

是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或者“**派生类**”，被继承的类称为“**基类**”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。

继承概念的实现方式有两类：

**实现继承**：实现继承是指直接使用基类的属性和方法而无需额外编码的能力。

**接口继承**：接口继承是指仅使用属性和方法的名称、但是子类必需提供实现的能力。

**多态**

就是向不同的对象发送同一个消息，不同对象在接收时会产生不同的行为（即方法）。即一个接口，可以实现多种方法。（重载实现编译时多态，虚函数实现运行时多态）

多态分为两类：

- **静态多态**：函数重载和运算符重载属于静态多态，复用函数名；
- **动态多态**：派生类和虚函数实现运行时多态。

**静态多态**和**动态多态**区别：

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

**多态满足条件**：有继承关系；子类重写父类中的虚函数；

**多态使用条件**：父类指针或引用指向子类对象；

**多态的优点**：代码组织结构清晰；可读性强；利于前期和后期的扩展以及维护

## 继承

[C++之继承_浮沉一只白的博客-CSDN博客_c++ 继承](https://blog.csdn.net/m0_57234892/article/details/123892631)

### 三种继承方式

**private, public, protected的访问范围：**

private: 只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问；

protected: 可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问；

public: 可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问；

**类继承后方法属性变化:**

使用private继承，父类的所有方法在子类中变为private；

使用protected继承，父类的protected和public方法在子类中变为protected，而private方法不变；

使用public继承，父类中的方法属性不发生改变；

派生类的访问方式会变为基类的访问方式和继承方式取权限最小的那个。

**总结：**

基类`private`成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。

如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为`protected`。可以看出保护成员限定符是因继承才出现的。

class的默认继承方式为private，而struct的默认继承方式为public。

实际应用多为public继承。

### 菱形继承

单继承：一个子类只有一个直接父类时称这个继承关系为单继承。

多继承：一个子类有两个或两个以上直接父类时称这个继承关系称为多继承。

两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为**菱形继承**。

菱形继承带来的主要问题是子类继承两份相同的数据，导致数据的冗余性和二义性，可以用**虚继承**来解决。

可以通过指定访问哪个父类来解决二义性：

```php
class Person{
public:
	string _name; // 姓名
};

class Student : public Person{
protected:
	int _num; //学号
};

class Teacher : public Person{
protected:
	int _id; // 职工编号
};

class Assistant : public Student, public Teacher{
protected:
	string _Course; // 课程
};

void Test(){
	Assistant a;
	a._name = "peter";	// 这样会出现二义性无法明确知道访问的是哪一个
	a.Student::_name = "Tom"; // 正确
	a.Teacher::_name = "Jack"; // 正确
}
```

而为了解决冗余性，则出现了**菱形虚继承**。

在继承方式前面加上 `virtual `关键字就是虚继承，

```php
class Person{
public:
	string _name; // 姓名
};

class Student : virtual public Person{
protected:
	int _num; //学号
};

class Teacher : virtual public Person{
protected:
	int _id; // 职工编号
};

class Assistant : public Student, public Teacher{
protected:
	string _Course; // 课程
};

int main(){
	Assistant a;
	a.Student::_name = "Tom";
	a.Teacher::_name = "Jack";
	a._name = "peter"; // 正确
	return 0;
}
```

这段代码使用虚继承重新实现了菱形继承，这样在派生类 Assistant 中就只保留了一份成员变量 _name，直接访问就不会再有歧义了。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为**虚基类**，本例中的 Person 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

### 友元

在程序里有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到**友元**。友元的**目的**就是让一个函数或者类访问另一个类中私有成员。友元的关键字为 **friend**，友元的三种实现：全局函数做友元、类做友元、成员函数做友元。

[论C++的自我修养（4）友元_海岸星的清风的博客-CSDN博客](https://blog.csdn.net/weixin_42461320/article/details/122900371)

### (虚)继承类的内存占用大小 

首先，平时所声明的类只是一种类型定义，它本身是没有大小可言的。 因此，如果用sizeof运算符对一个类型名操作，那得到的是具有该类型实体的大小。 

计算一个类对象的大小时的规律： 

1. 空类、单一继承的空类、多重继承的空类所占空间大小为：1（字节，下同）； 

2. 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的； 

3. 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vPtr指向虚函数表VTable； 

4. 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）vfPtr指针指向虚函数表vfTable和一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）； 

5. 在考虑以上内容所占空间的大小时，还要注意编译器下的“补齐”的影响，即编译器会插入多余的字节补齐； 

6. 类对象的大小=各非静态数据成员（包括父类的非静态数据成员但都不包括所有的成员函数）的总和+ vfptr指针(多继承下可能不止一个)+vbptr指针(多继承下可能不止一个)+编译器额外增加的字节。

常见数据类型的内存占用：

1. 指针的大小一定是4个字节，而不管是什么类型的指针；
2. char型占1个字节，bool型占1个字节，int占4个字节，short int占2个字节，long int占4个字节，float占4字节，double占8字节，string占4字节，一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节，void * 万能指针在32位系统上是4字节，64位系统上是8字节；
3. 数组的长度：若指定了数组长度，则不看元素个数，总字节数 = 数组长度 * sizeof（元素类型）；若没有指定长度，则按实际元素个数来确定。Ps：若是字符数组，则应考虑末尾的空字符。

例子1：

```php
class A{};
class B{
public:
    virtual void b1(){}
    virtual void b2(){}
};
class C : public B{
public:
    virtual void c(){}
};
class D : public virtual B{ //虚继承
public:
    virtual void d1(){}
    virtual void d2(){}
};
class E : public virtual D{// 虚继承
public:
    virtual void e1(){}
    virtual void e2(){}
};

int _tmain(int argc, _TCHAR* argv[]){
    cout<<sizeof(A)<<endl<<sizeof(B)<<endl<<sizeof(C)<<endl<<sizeof(D)<<endl<<sizeof(E);
    // 1 4 4 12 20
    return 0;
}
```

例子2：

```php
class CBase { 
	int a; 
	char p; 
}; 
sizeof(CBase)=8;

class CBase { 
public: 
	CBase(void); 
	virtual ~CBase(void); 
private: 
	int  a; 
	char *p; 
}; 
sizeof(CBase)=12

class CChild : public CBase { 
public: 
	CChild(void); 
	~CChild(void); 
	virtual void test();
private: 
	int b; 
}; 
sizeof(CChild)=16；

class a{}; // 1
class b{}; // 1
class c : public a{ // 4
	virtual void fun()=0;
};
class d : public b,public c{}; // 8
```

## 重载、重写和隐藏

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

```php
#include <iostream>
using namespace std;

class Base{
public:
    void fun(int tmp, float tmp1) { cout << "Base::fun(int tmp, float tmp1)" << endl; }
};

class Derive : public Base{
public:
    void fun(int tmp) { cout << "Derive::fun(int tmp)" << endl; } // 隐藏基类中的同名函数
};

int main(){
    Derive ex;
    ex.fun(1);       // Derive::fun(int tmp)
    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided
    return 0;
}
```

**说明**：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

**重载**：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

```php
class A{
public:
    void fun(int tmp);
    void fun(float tmp);        // 重载 参数类型不同（相对于上一个函数）
    void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数）
    void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数）
    int fun(int tmp);            //错误：注意重载不关心函数返回类型
};
```

**重写 **：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。

```php
#include <iostream>
using namespace std;

class Base{
public:
    virtual void fun(int tmp) { cout << "Base::fun(int tmp) : " << tmp << endl; }
};

class Derived : public Base{
public:
    virtual void fun(int tmp) { cout << "Derived::fun(int tmp) : " << tmp << endl; } // 重写基类中的 fun 函数
};

int main(){
    Base *p = new Derived();
    p->fun(3); // Derived::fun(int) : 3
    return 0;
}
```

**重写和重载的区别：**

- **范围区别**：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。
- **参数区别**：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。
- **virtual 关键字**：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。

**隐藏和重写，重载的区别：**

- **范围区别**：隐藏与重载范围不同，隐藏发生在不同类中。
- **参数区别**：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual修饰，基类函数都是被隐藏，而不是重写。

## 构造函数和析构函数

- **构造函数**：主要作用在于创建对象时，为对象的成员属性赋值。构造函数由编译器自动调用，无须手动调用。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造函数，无须手动调用，而且只会调用一次

- **析构函数**：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号 ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次

- 构造函数的两种分类方式：

1. 按参数分为： 有参构造和无参构造

2. 按类型分为： 普通构造和拷贝构造

此外，C++还提供了**初始化列表**语法，用来初始化属性。**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`。

所以**类成员初始化方式**有两种：1. 赋值初始化，通过在函数体内进行赋值初始化；2. 列表初始化，在冒号后使用初始化列表进行初始化。

这两种方式的主要**区别**在于：

对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的。而列表初始化是给数据成员分配内存空间时就进行初始化，也就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)，那么分配了内存空间后在进入函数体之前给数据成员赋值，初始化这个数据成员，此时函数体还未执行。

那为什么用成员初始化列表会快一些呢？

因为方法一（赋值初始化）是在构造函数当中做赋值的操作，而方法二（列表初始化）是做纯粹的初始化操作。C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率。

- **执行顺序**

**构造函数顺序**

1. 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

2. 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

3. 派生类构造函数。

**析构函数顺序**

1. 调用派生类的析构函数；

2. 调用成员类对象的析构函数；

3. 调用基类的析构函数。

- **构造函数、析构函数可否抛出异常**

析构函数：

如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。通常异常发生时，C++机制会调用已经构造对象的析构函数来释放资源，此时如析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

那么如果无法保证在析构函数中不发生异常该怎么办？那就是把异常完全封装在析构函数内部，决不让异常抛出析构函数之外。这是一种非常简单，也非常有效的方法。

构造函数：

构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。在构造函数中抛出异常，在概念上将被视为该对象没有被成功构造，因此当前对象的析构函数就不会被调用。因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。

构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前把系统资源释放掉，防止内存泄露。构造函数中尽量不要抛出异常，能避免的就避免，如果必须，要考虑不要内存泄露。

解决办法：在Catch 块里面释放已经申请的资源 或者 用智能指针把资源当做对象处理。

## 深拷贝和浅拷贝

如果一个类拥有资源，该类的对象进行复制时，**如果资源重新分配，就是深拷贝，否则就是浅拷贝。**

- **深拷贝**：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。
- **浅拷贝**：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。

当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下， 系统会调用默认的拷贝函数－即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。

但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致指野指针的问题。

所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于**深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决来野指针的问题**。简而言之，当数据成员中有指针时，必需要用深拷贝更加安全。

```php
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		cout << "有参构造函数!" << endl;
		m_age = age;
		m_height = new int(height);
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL){
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

```

## 虚函数

- **虚函数的实现原理**

首先C++中多态的实现是在基类的函数前加上 `virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数，如果是基类，就调用基类的函数。

实际上，当一个类中包含虚函数时，编译器会为该类生成一个**虚函数表**，保存该类中虚函数的地址。同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自己的虚函数表。当我们定义一个派生类对象时，编译器检测该类型有虚函数，所以为这个派生类对象生成一个**虚函数指针**，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

后续如果有一个基类类型的指针指向派生类，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调用派生类的虚函数表中的虚函数，从而实现多态。

- **多态的实现原理**

多态一般就是指**继承加虚函数实现的多态**，多态可以分为静态多态和动态多态。

- **静态多态**其实就是重载，静态多态在编译时期就决定了调用哪个函数，根据参数列表来决定；
- **动态多态**是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态。

一般情况下我们不区分这两个时所说的多态就是指动态多态。动态多态的实现与虚函数表，虚函数指针相关。

**静态多态**和**动态多态**区别：静态多态的函数地址早绑定 - 编译阶段确定函数地址；动态多态的函数地址晚绑定 - 运行阶段确定函数地址

**多态满足条件**：有继承关系；子类重写父类中的虚函数；

**多态使用条件**：父类指针或引用指向子类对象；

- **存放位置**

1. 虚函数表指针位置取决于对象在哪。如果是new的对象，则存在堆上，如果是直接声明，则存在栈上；

2. 虚函数表位于只读数据段（.rodata），即C++内存模型中的常量区；

3. 虚函数代码则位于代码段（.text），即C++内存模型中的代码区。

- **编译器如何建立虚函数表**

对于派生类来说，编译器建立**虚函数表**有三个步骤：

1. 拷贝基类的虚函数表，如果是多继承，就拷贝每个有虚函数基类的虚函数表；

2. 还有一个基类的虚函数表和派生类自身的虚函数表共用了一个虚函数表，称这个基类为派生类的主基类；

3. 查看派生类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派生类是否有自身的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中。

- **析构函数一般写成虚函数的原因**

为了防止内存泄漏。一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。

如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。

- **构造函数为什么一般不定义为虚函数**

而且从目前编译器通过虚函数来实现多态的方式来看，虚函数的调用是通过实例化之后对象的虚函数表指针来找到虚函数的地址进行调用的。如果构造函数是虚函数，那么虚函数表指针则是不存在的，无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违反了先实例化后调用的准则。

调用构造函数后， 才能生成一个对象。 假设构造函数是虚函数， 虚函数存在于虚函数表中， 而去找虚函数表又需要虚函数表指针， 而虚函数表指针又存在于对象中， 这样就矛盾了： 都没有生成对象， 哪有什么虚函数表指针呢？

- **纯虚函数**

声明一个纯虚函数的目的就是为了让派生类只继承成员函数的接口，而且派生类中必需提供一个这个纯虚函数的实现，否则含有纯虚函数的类将是**抽象类**，不能进行实例化。

对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调用这个实现的唯一方式是在派生类对象中指出其 class 名称来调用。

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0` ，当类中有了纯虚函数，这个类也称为抽象类。

抽象类特点：无法实例化对象；子类必须重写抽象类中的纯虚函数，否则也属于抽象类。

- **哪些函数不能是虚函数**

**构造函数**，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚函数表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

**内联函数**，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；

**静态函数**，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。

**友元函数**，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

**普通函数**，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

- **实例化一个对象需要哪几个阶段**

**1、分配空间**

创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。

**2、初始化**

首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。

**3、赋值**

对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。

总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。对于拥有虚函数的类的对象，还需要给虚表指针赋值。

没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。

有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。

类对象的初始化顺序：**基类构造函数–>派生类成员变量的构造函数–>派生类自身构造函数**

## delete this

- 在**成员函数**中调用delete this会出现什么问题？对象还可以使用吗？

在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

- 如果在类的**析构函数**中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

## 函数模板和类模板

1. 什么是模板？如何实现？

**模板**：创建类或者函数的蓝图或者公式，分为函数模板和类模板。

**实现方式**：模板定义以关键字 **template** 开始，后跟一个模板参数列表。

- 模板参数列表不能为空；
- 模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。

```php
template <typename T, typename U, ...>
```

函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。

- 对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。
- 函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。

```php
#include<iostream>

using namespace std;

template <typename T>
T add_fun(const T & tmp1, const T & tmp2){
    return tmp1 + tmp2;
}

int main(){
    int var1, var2;
    cin >> var1 >> var2;
    cout << add_fun(var1, var2);

    double var3, var4;
    cin >> var3 >> var4;
    cout << add_fun(var3, var4);
    return 0;
}
```

类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。

```php
#include <iostream>

using namespace std;

template <typename T>
class Complex
{
public:
    //构造函数
    Complex(T a, T b)
    {
        this->a = a;
        this->b = b;
    }

    //运算符重载
    Complex<T> operator+(Complex &c)
    {
        Complex<T> tmp(this->a + c.a, this->b + c.b);
        cout << tmp.a << " " << tmp.b << endl;
        return tmp;
    }

private:
    T a;
    T b;
};

int main()
{
    Complex<int> a(10, 20);
    Complex<int> b(20, 30);
    Complex<int> c = a + b;

    return 0;
}
```

2. 函数模板和类模板的区别？

实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。

实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。

默认参数：类模板在模板参数列表中可以有默认参数。

特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。

调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。

函数模板调用方式举例：

```php
#include<iostream>

using namespace std;

template <typename T>
T add_fun(const T & tmp1, const T & tmp2){
    return tmp1 + tmp2;
}

int main(){
    int var1, var2;
    cin >> var1 >> var2;
    cout << add_fun<int>(var1, var2); // 显式调用

    double var3, var4;
    cin >> var3 >> var4;
    cout << add_fun(var3, var4); // 隐式调用
    return 0;
}

```

3. 什么是可变参数模板？

可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。

- 模板参数包：表示零个或多个模板参数；
- 函数参数包：表示零个或多个函数参数。

用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符。

```cpp
template <typename T, typename... Args> // Args 是模板参数包
void foo(const T &t, const Args&... rest); // 可变参数模板，rest 是函数参数包

#include <iostream>

using namespace std;

template <typename T>
void print_fun(const T &t)
{
    cout << t << endl; // 最后一个元素
}

template <typename T, typename... Args>
void print_fun(const T &t, const Args &...args)
{
    cout << t << " ";
    print_fun(args...);
}

int main()
{
    print_fun("Hello", "wolrd", "!");
    return 0;
}
/*运行结果：
Hello wolrd !
*/
```

说明：可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。

4. 什么是模板特化？为什么特化？

模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。

模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化

- 函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。
- 类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。

特化分为全特化和偏特化：

- 全特化：模板中的模板参数全部特例化。
- 偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。

说明：要区分下函数重载与函数模板特化。定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。

```php
#include <iostream>
#include <cstring>

using namespace std;
//函数模板
template <class T>
bool compare(T t1, T t2)
{
    cout << "通用版本：";
    return t1 == t2;
}

template <> //函数模板特化
bool compare(char *t1, char *t2)
{
    cout << "特化版本：";
    return strcmp(t1, t2) == 0;
}

int main(int argc, char *argv[])
{
    char arr1[] = "hello";
    char arr2[] = "abc";
    cout << compare(123, 123) << endl;
    cout << compare(arr1, arr2) << endl;

    return 0;
}
/*
运行结果：
通用版本：1
特化版本：0
*/
```

# STL

## STL原理

STL ⼀共提供六⼤组件，包括**容器，算法，迭代器，仿函数，适配器和空间配置器**，彼此可以组合套⽤。容器通过配置器取得数据存储空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，适配器可以应⽤于容器、 仿函数和迭代器。

容器：各种数据结构，如 vector，list，deque，set，map，⽤来存放数据， 从实现的⻆度来讲是⼀种类模板。

算法：是用来操作容器中的数据的模板函数，如 sort（插⼊，快排，堆排序），search（⼆分查找）， 从实现的⻆度来讲是⼀种⽅法模板。

迭代器：提供了访问容器中对象的方法。从实现的⻆度来看，迭代器是⼀种将 operator*，operator->，operator++，operator-- 等指针相关操作赋予重载的类模板，所有的 STL 容器都有⾃⼰的迭代器。

仿函数：从实现的⻆度看，仿函数是⼀种重载了 operator() 的类或者类模板，可以帮助算法实现不同的策略。

适配器：⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东⻄。简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口，或调用现有的函数来实现所需要的功能。

空间配置器：负责空间配置与管理，从实现的⻆度讲，配置器是⼀个实现了动态空间配置、空间管理，空间释放的类模板。

## 常见容器及其原理

容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

1. 顺序式容器

   容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：

   （1）vector 

   动态数组。元素在内存连续存放，随机存取任何元素都能在常数时间完成，在尾端增删元素具有较佳的性能。

   （2）deque

   双向队列。元素在内存连续存放**，**随机存取任何元素都能在常数时间完成（仅次于vector），在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

   （3）list 

   双向链表。元素在**内存不连续存放**。在任何位置增删元素都能在常数时间完成，不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。

2. 关联式容器

   **元素是排序的**；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：

   （1）set/multiset 

   set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

   （2）map/multimap 

   map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first，另一个名为second。map根据first值对元素从小到大排序，并可快速地根据first来检索元素。

   **注意**：map同multimap的不同在于是否允许存在first值相同的元素。

3. 容器适配器

   封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。新得到的数据结构就叫适配器，包含stack, queue, priority_queue，具体实现原理如下：

   （1）stack 

   栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项），后进先出。

   （2）queue 

   队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行，先进先出。

   （3）priority_queue 

   优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部，最高优先级元素总是第一个出列。

## 迭代器

**什么是迭代器？**

Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。

```php
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v; //一个存放int元素的数组，一开始里面没有元素
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    
    vector<int>::const_iterator i; //常量迭代器
    for (i = v.begin(); i != v.end(); ++i) //v.begin()表示v第一个元素迭代器指针，++i指向下一个元素
        cout << *i << ","; //*i表示迭代器指向的元素
    cout << endl;

    vector<int>::reverse_iterator r; //反向迭代器
    for (r = v.rbegin(); r != v.rend(); r++)
        cout << *r << ",";
    cout << endl;
    
    vector<int>::iterator j; //非常量迭代器
    for (j = v.begin();j != v.end();j++)
        *j = 100;
    for (i = v.begin();i != v.end();i++)
        cout << *i << ",";
    return 0;
}

/*    运行结果：
          1,2,3,4,
          4,3,2,1,
          100,100,100,100,
*/                
```

容器的`end()`方法返回一个迭代器，需要注意：这个迭代器不指向实际的元素，而是表示末端元素的下一个元素，这个迭代器起一个哨兵的作用，表示已经处理完所有的元素。因此，在查找的时候，返回的迭代器不等于`end()`，说明找到了目标；等于end()，说明检查了所有元素，没有找到目标。


**迭代器的作用**

（1）用于指向顺序容器和关联容器中的元素

（2）通过迭代器可以读取它指向的元素

（3）通过非const迭代器还可以修改其指向的元素

**迭代器和指针的区别**

迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–>、++、--等。迭代器封装了指针，是一个可遍历STL容器内全部或部分元素的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

**迭代器产生的原因**

Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

**迭代器什么时候会失效？迭代器如何删除元素？**

对于顺序式容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。

对于关联式容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是**红黑树**，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。

对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

|      容器      | 容器上的迭代器类别 |
| :------------: | :----------------: |
|     vector     |      随机访问      |
|     deque      |      随机访问      |
|      list      |        双向        |
|  set/multiset  |        双向        |
|  map/multimap  |        双向        |
|     stack      |    不支持迭代器    |
|     queue      |    不支持迭代器    |
| priority_queue |    不支持迭代器    |


## vector原理

Vector在堆中分配了⼀段连续的内存空间来存放元素，随着元素的加⼊，它的内部机制会⾃⾏扩充空间以容纳新元素。vector 维护的是⼀个连续的线性空间，⽽且普通指针就可以满⾜要求，能作为 vector 的迭代器。

vector 的数据结构中其实就是三个迭代器构成的，⼀个指向⽬前使⽤空间头的 iterator，⼀个指向⽬前使⽤空间尾的iterator，⼀个指向⽬前可⽤空间尾的 iterator。当有新的元素插⼊时，如果⽬前容量够⽤则直接插⼊，如果容量不够，则容量扩充⾄两倍，如果两倍容量不⾜， 就扩张⾄⾜够⼤的容量。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206072029286.png" alt="image-20220607202913219" style="zoom:70%;" />

扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效。

**新增元素**

Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。插入新数据可以通过最后插入`push_back`和通过迭代器在任何位置插入`insert()`。通过迭代器与第一个元素的距离知道要插入的位置，即`int index = iter - begin()`，这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。

```php
//新增元素
void insert(const_iterator iter, const T &t){
    int index = iter - begin();
    if (index < size_){
        if (size_ == capacity_){
            int capa = calculateCapacity();
            newCapacity(capa);
        }
        memmove(buf + index + 1, buf + index, (size_ - index) * sizeof(T));
        buf[index] = t;
        size_++;
    }
}
```

**删除元素**

删除也分两种：删除最后一个元素`pop_back`和通过迭代器删除任意一个元素`erase(iter)`。通过迭代器删除要先找到要删除元素的位置，即`int index = iter - begin()`，这个位置后面的每个元素都想前移动一个元素的位置。`erase`不释放内存，只初始化成默认值。

删除全部元素`clear`：只是循环调用了`erase`，所以删除全部元素的时候不释放内存，内存是在析构函数中释放的。

```php
//删除元素
iterator erase(const_iterator iter){
    int index = iter - begin();
    if (index < size_ && size_ > 0){
        memmove(buf + index, buf + index + 1, (size_ - index) * sizeof(T));
        buf[--size_] = T();
    }
    return iterator(iter);
}
```

**push_back和emplace_back**

如果要将一个临时变量push到容器的末尾，`push_back()`需要先构造临时对象，再将这个对象拷贝到容器的末尾，最后销毁临时对象。而`emplace_back() `会在容器中原地创建一个对象，减少临时对象拷贝、销毁的步骤，所以性能更高。

如果插入vector的类型的构造函数接受多个参数，那么push_back只能接受该类型的对象，而emplace_back还能接受该类型的构造函数的参数。如果只有一个构造参数，push_back在c++11就支持只把单个的构造参数传进去了（写法更简洁，效果、性能跟传对象是一模一样的），会进行类型自动转换。

在性能上，对于内置类型性能都一样，而对于用户自定义的类，`emplace_pack`仅在通过使用**构造参数**传入的时候更高效。

1. 若通过构造参数向vector中插入对象，emplace_back更高效：

```php
std::vector<A> a;
a.emplace_back(1);  
a.push_back(2);
```

emplace_back：仅调用有参构造函数 A (int x_arg) ；

push_back：（1）调用有参构造函数 A (int x_arg) 创建临时对象；（2）调用移动构造函数 A (A &&rhs) 到vector中；（3）调用析构函数销毁临时对象；

2. 插入临时对象，二者一样，调用移动构造函数：

```php
std::vector<A> a;
a.emplace_back(A(1)); 
a.push_back(A(2));
```

插入对象都需要三步走：建临时对象->移动->销毁临时对象

3. 插入实例化的对象，二者还是一样，调用拷贝构造函数：

```php
std::vector<A> a;
A obj(1);
a.emplace_back(obj); 
a.push_back(obj);
```

注意：这里调用的是拷贝构造函数：拷贝->销毁临时对象。

**将N个元素使用push_back插入到vector中， 求push_back操作的复杂度**。参考：[1](https://blog.csdn.net/weixin_43343803/article/details/106708543)、[2](https://blog.csdn.net/yangshiziping/article/details/52550291)

考虑vector每次内存扩充两倍的情况。如果我们插入`N`个元素， 则会引发`lgN`次的内存扩充，而每次扩充引起的元素拷贝次数分别为2^0,  2^1, 2^2, ..., 2^lgN，把所有的拷贝次数相加得到 2^0 + 2^1 + 2^2 + ... + 2^lgN = 2 * 2^lgN - 1 约为 2N次，共拷贝了N次最后一个元素，所以总的操作大概为3N。所以每个push_back操作分摊3次， 是O(1) 的复杂度。

**为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？**

采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此使用成倍的方式扩容。

**为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？**

考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2倍的方式扩容，或者以1.5倍的方式扩容。以2倍的方式扩容，下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间。倍数过大容易使申请的新空间比之前已经申请的旧空间还大，导致空间的无法重复利用。

**resize和reserve**

首先必须弄清楚两个概念：

- capacity：该值在容器初始化时赋值，指的是容器能够容纳的最多的元素的个数，还不能通过下标来访问，因为此时容器中还没有创建任何对象。

- size：指的是此时容器中实际的元素个数，可以通过下标访问`0 ~ (size - 1)`范围内的对象。

resize和reserve区别主要有以下几点：

1. resize既分配了空间，也创建了对象；reserve表示容器预留空间，但没有创建对象，需要通过 insert() 或 push_back() 等创建对象。

2. resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。

3. 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留空间的大小。


### vector和数组的区别

1. 内存中的位置

   C++中数组为内置的数据类型，存放在**栈**中，其内存的分配和释放完全由系统自动完成；vector存放在**堆**中，由STL库中程序负责内存的分配和释放，使用方便。

2. 大小能否变化

   数组的大小在初始化后就固定不变，而vector可以通过push_back或pop等操作进行变化。

3. 初始化

   数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而vector可以。

4. 执行效率

   数组效率 > vector效率。主要原因是vector的扩容过程要消耗大量的时间。

## deque原理

vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）。deque和vector的最大差异一个是deque可以在常数时间内在头端进行元素操作，二是deque没有容量的概念，它是由分段连续空间组合而成的，可以随时增加一段新的空间并链接起来。

deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque。

deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。

deque的数据结构如下：

```php
class deque{
    ...
protected:
    typedef pointer* map_pointer;//指向map指针的指针
    map_pointer map;			//指向map
    size_type map_size;			//map的大小
public:
    ...
    iterator begin();
    itertator end();
    ...
}
```

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206082031596.png" alt="image-20220608203058478" style="zoom:90%;" />

deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点node，每个node都是一个指针，指向另一段较大的连续空间，称为**缓冲区**，这里就是deque中实际存放数据的区域，默认大小为512bytes。

deque的迭代器数据结构如下：

```php
struct __deque_iterator{
    ...
    T* cur;		//迭代器所指缓冲区当前的元素
    T* first;	//迭代器所指缓冲区第一个元素
    T* last;	//迭代器所指缓冲区最后一个元素
    map_pointer node;	//指向map中的node
    ...
}    
```

从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206082033790.png" alt="image-20220608203356715" style="zoom:80%;" />

deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区。当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。


## list原理

相比于vector的连续线型空间，list显得复杂许多，它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作是指针操作，list提供的迭代器类型是双向迭代器。

list节点的结构见如下源码：

```php
template <class T>
struct __list_node{
    typedef void* void_pointer;
    void_pointer prev;
    void_pointer next;
    T data;
}
```

从源码可看出list显然是一个双向链表。list与vector的另一个区别是，list在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。

此外list也是一个环形链表，因此只要一个指针便能完整遍历整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构。

list的空间管理默认采用alloc作为空间配置器，为了方便以节点大小为配置单位，还定义一个`list_node_allocator`函数一次性配置多个节点空间。

由于list的双向特性，支持在头部和尾部两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse等操作。

## vector 和 list 对比

**vector：一维数组**

动态数组，元素在内存中连续存放，随机访问任何元素都在常数时间内完成，在尾端增删元素性能较好。

特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。

优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。

缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O(n)，另外当空间不足时还需要进行扩容。

**list：双向链表**

双向链表，元素在内存不连续存放，在任何位置增删元素都能在常数时间完成，不支持随机访问。

特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。

优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。

缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n)，没有提供[]操作符的重载。

**应用场景**

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

**删除末尾的元素，指针和迭代器如何变化？删除中间的元素呢？**

对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。而对于list而言，删除某个元素，只有指向被删除元素的那个迭代器失效，其它迭代器不受任何影响。

## map和unordered_map

**内部实现机理**

`map`底层是**红黑树**，内部的元素是**有序的**。map中的元素是按照**二叉树搜索树**存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值，使用中序遍历可将键值按照从小到大遍历出来。

`unordered_map`底层是**哈希表**，内部的元素是**无序的**。哈希表采用了**函数映射**将存储位置与记录的关键字关联起来，从而实现快速查找。

**优缺点以及使用场景**

**map**

优点：`map`底层是**红黑树**，内部的元素是**有序的**，查找、增删操作都可以在`O(lgn)`的时间复杂度下完成，因此效率非常的高。

缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红黑性质，使得每一个节点都占用大量的空间。

适用：有顺序要求的问题，用map会更高效一些。

**unordered_map**

优点：底层是哈希表，查找速度非常的快。

缺点：哈希表的建立比较耗费时间。

适用：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑用unordered_map。

对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照**哈希表**从前往后依次遍历的。

**map下标操作 [ ] 和insert的区别**

**insert**

insert 含义是：在 map 中，如果key存在，则插入失败；如果key不存在，就创建这个key－value。实例: `map.insert((key, value))`。insert接受一个pair参数，并且返回值也是一个pair。

返回值pair中：

第一个元素是一个迭代器，如果数据插入成功，则指向插入关键字的位置，用->解引用可以提取pair类型元素； 若插入失败，迭代器指向已经存在的该元素的位置。

第二个元素是一个bool类型变量，如果关键字已在map中，insert什么也不做，second返回false，插入失败；如果关键字不存在，元素被插入，second返回true。

**下标操作 [ ]**

利用下标操作的含义是：如果key存在，就更新value；如果key不存在，就创建这个key－value对。实例：`map[key] = value`。

## 哈希冲突

对于不同的关键字，可能得到同一个哈希地址，这种现象称之为**哈希冲突**，也叫哈希碰撞。

**如何减少哈希冲突？**

**一个好的哈希函数可以有效的减少哈希冲突的出现**，那什么样的哈希函数才是一个好的哈希函数呢？通常来说，一个好的哈希函数对于关键字集合中的任意一个关键字，经过这个函数映射到地址集合中任何一个集合的概率是相等的。

常用的构造哈希函数的方法有以下几种：

1. 除留取余法：关键字key除以某个不大于哈希表长m的数p，所得余数为哈希地址。即：`f(key) = key % p, p ≤ m`；

2. 直接定址法：取关键字或关键字的某个线性函数值为哈希地址。即： `f(key) = key` 或者 `f(key) = a * key + b`；

3. 数字分析法：假设关键字是以r为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。

**如何处理哈希冲突？**

虽然我们可以通过选取好的哈希函数来减少哈希冲突，但是哈希冲突终究是避免不了的。那么，碰到哈希冲突应该怎么处理呢？

1. 链地址法：在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储，也就是哈希地址相同的元素都插入到同一个链表中，元素插入的位置可以是表头（头插法），也可以是表尾（尾插法）。

2. 开放定址法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。

3. 再哈希法：选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。

4. 建立公共溢出区：专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表中。

其中比较常用的是**链地址法**，比如HashMap就是基于链地址法的哈希表结构，所以unordered_map使用**开链法**解决哈希冲突。

但当链表过长时，哈希表就会退化成一个链表，查找某个元素的时间复杂度又变回了O(n)。因此，当哈希表中的链表过长时就需要我们对其进行优化。二叉搜索树的查询效率是远远高于链表的。因此，当哈希表中的链表过长时，可以把这个链表变成一棵**红黑树**。红黑树是一个可以自平衡的二叉搜索树，查询的时间复杂度为`O(lgn)`，通过这样的优化可以提高哈希表的查询效率。

## map和set

**参考回答**

1. set是一种关联式容器，其特性如下：

   （1）以红黑树作为底层容器，所有的元素都会被自动排序

   （2）元素只有key没有value，value就是key

   （3）不允许出现键值重复

   （4）不能通过迭代器来改变set的值，因为set的键值就是关键字，set的迭代器是const的

2. map和set一样是关联式容器，其特性如下：

   （1）map以红黑树作为底层容器，所有元素是通过键进行自动排序的

   （2）所有元素都是键+值存在

   （3）不允许键重复

   （4）map的键是不能修改的，但是其键对应的值是可以修改的

   综上所述，map和set**底层实现**都是红黑树；map和set的**区别**在于map的值不作为键，键和值是分开的。

## AVL树、红黑树、B+树

**二叉搜索树**

**二叉搜索树**的特点是一个节点的左子树的所有节点的值都小于这个节点，右子树的所有节点的值都大于这个节点。但是当每次插入的元素都是二叉搜索树中最大的元素，就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)。

**AVL树**

为了解决二叉搜索树在极端情况下退化成链表的问题，**平衡二叉搜索树（AVL 树）**在二叉搜索树的基础上增加了一些条件约束：**每个节点的左子树和右子树的高度差不能超过 1**，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 `O(logn)` 。

不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是十分耗时的，AVL树适合用于插入与删除次数比较少，但查找多的情况。

**红黑树**

除了平衡二叉搜索树，还有很多自平衡的二叉树，比如**红黑树**，它也是通过一些约束条件来达到自平衡。

红黑树也是一种二叉搜索树，红黑树每一个结点都会额外记录结点的颜色，红色或者黑色。通过对任何一条从根节点到叶子节点的路径上各个结点颜色的限制，**红黑树确保没有一条路径会比其他路径长两倍，因此，红黑树是一种弱平衡树。** 对于要求严格的AVL树来说，红黑树为了保持平衡旋转的次数较少，所以对于搜索、插入、删除操作较多的情况下，红黑树的综合能力较好。

红黑树是一种含有红黑结点并能自平衡的二叉搜索树，它必须满足下面性质：

- 性质1：每个结点要么是红色，要么是黑色
- 性质2：根节点是黑色
- 性质3：叶子结点都是黑色
- 性质4：每个红色结点的子结点一定都是黑色
- 性质5：任意一个结点到每个叶子结点的路径包含数量相同的黑色结点。

**红黑树的应用**：

1、广泛用于C++的STL中；

2、著名的Linux的的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;

3、IO多路复用的`epoll`的实现采用红黑树组织管理的的的sockfd，支持快速的增删改查;

**红黑树与AVL树的区别**：

红黑树是一种弱平衡二叉搜索树（红黑树确保没有一条路径比其它路径长出两倍），在相同的节点情况下，AVL树的高度低于红黑树，相对于要求严格的AVL树来说，红黑树的旋转次数少，所以对于插入与删除较多的情况，红黑树的综合能力较好。由于AVL树高度平衡，因此AVL树的查询效率更高。

**B+树**

自平衡二叉树虽然能保持查询操作的时间复杂度在`O(logn)`，但是本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。

为了解决降低树的高度的问题，后面就出来了 **B 树**，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M>2)，从而降低树的高度。

B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树。B+ 树与 B 树的差异主要有：

![图片](https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206012015597.png)

- 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
- 非叶子节点的索引也会同时存在于子节点中，并且是子节点中所有索引的最大（或最小）值；
- 非叶子节点中有多少个子节点，就有多少个索引；

MySQL 默认的存储引擎 InnoDB 采用 B+ 树作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比于同时存储索引和数据的 B 树来说，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，只能通过树的遍历来完成，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

## 容器适配器

标准库提供了三种顺序容器适配器：`queue`(FIFO队列)、`priority_queue`(优先级队列)、`stack`(栈)。

适配器对容器进行包装，使其表现出另外一种行为。例如，`stack<int, vector<int>>` 实现了栈的功能，但其内部使用顺序容器`vector<int>`来存储数据 ，相当于是`vector<int>`表现出了栈的行为。

堆建⽴在完全⼆叉树上，分为⼤根堆、⼩根堆。其在STL中做priority_queue的助⼿，即以任何顺序将元素推⼊容器中，然后取出时⼀定是从优先权最⾼的元素开始取，完全⼆叉树具有这样的性质，适合做priority_queue的底层。

优先级队列默认使用`vector`作为其底层存储数据的容器，在vector上又使用了**堆算法**将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue，默认情况下priority_queue是最大堆。

## stack和queue原理

**stack**（栈）是一种先进后出的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素。stack这种单向开口的数据结构很容易由双向开口的`deque`或者`list`形成，只需要根据stack的性质修改某些接口即可实现，stack的源码如下：

```php
template <class T, class Sequence = deque<T>>
class stack{
	...
protected:
    Sequence c;
public:
    bool empty(){return c.empty();}
    size_type size() const{return c.size();}
    reference top() const {return c.back();}
    const_reference top() const{return c.back();}
    void push(const value_type& x){c.push_back(x);}
    void pop(){c.pop_back();}
};
```

从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence**默认是deque数据结构**。stack修改某种接口来实现栈的操作，成为容器适配器。

stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。

**queue**（队列）是一种先进先出的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端。除了出口元素外，没有其他方法可以获取到内部的其他元素。

类似的，queue这种先进先出的数据结构很容易由双向开口的`deque`或者`list`形成，只需要根据queue的性质修改某些接口即可实现，queue的源码如下：

```php
template <class T, class Sequence = deque<T>>
class queue{
	...
protected:
    Sequence c;
public:
    bool empty(){return c.empty();}
    size_type size() const{return c.size();}
    reference front() const {return c.front();}
    const_reference front() const{return c.front();}
    void push(const value_type& x){c.push_back(x);}
    void pop(){c.pop_front();}
};
```

从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence**默认也是deque数据结构**。同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。

## heap原理

heap（堆）并不是STL的容器组件，是`priority_queue`的底层实现机制，因为大根堆总是最大值位于堆的根部，优先级最高。

**二叉堆本质是一种完全二叉树**，二叉树除了最底层的叶子节点之外，都是填满的，但是叶节点从左到右不会出现空隙。

完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用数组来存储所有的节点，因为当其中某个节点位于`i`处，其左节点必定位于`2i`处，右节点位于`2i + 1`处，父节点位于`i / 2`（向下取整）处。这种以数组表示二叉树的方式称为隐式表述法。

因此我们可以使用一个数组和一组堆算法来实现最大堆（每个节点的值大于等于其子节点的值）和最小堆（每个节点的值小于等于其子节点的值）。由于数组不能动态的改变空间大小，用vector代替数组是一个不错的选择。

那heap算法有哪些？常见有的插入、弹出、排序和构造算法：

**push_heap插入算法**

由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层`vector`的`end()`处，之后是上溯的过程。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111135337.png" alt="image-20220611113511261" style="zoom:83%;" />

新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足大根堆的性质。

**pop_heap算法**

堆的pop操作实际弹出的是根节点，将其和vector最后一个元素进行替换，然后再为这个被替换的元素找到一个合适的安放位置，使整颗二叉树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶子节点为止，这个过程称为下溯。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111132314.png" alt="image-20220611113159174" style="zoom:85%;" />

根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。

**sort算法**

因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。

**make_heap算法**

将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。

## priority_queue原理

priority_queue（优先级队列）是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面。

默认情况下，priority_queue使用一个大根堆完成，底层容器使用的是一般为vector，堆heap为处理规则来管理底层容器实现。

priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。关键的源码如下：

```php
template <class T, class Squence = vector<T>, 
class Compare = less<typename Sequence::value_tyoe>>
class priority_queue{
	...
protected:
    Sequence c; 	// 底层容器
    Compare comp; 	// 元素大小比较标准
public:
    bool empty() const {return c.empty();}
    size_type size() const {return c.size();}
    const_reference top() const {return c.front()}
    void push(const value_type& x){
        c.push_heap(x);
        push_heap(c.begin(), c.end(), comp);
    }
    void pop(){
        pop_heap(c.begin(), c.end(), comp);
        c.pop_back();
    }
};
```

priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器。

## STL的两级空间配置器

首先明白为什么需要二级空间配置器？

动态开辟内存时，要在堆上申请，但若需要频繁地开辟、释放堆内存，则就会在堆上造成很多外部碎片，浪费了内存空间。随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。一般默认选择二级空间配置器， 如果分配的内存大于128字节才选择一级空间配置器。

**一级空间配置器**

**一级空间配置器**中重要的函数就是allocate、deallocate、reallocate。一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：

1. 使用allocate来分配内存，内部会调用malloc来分配内存，成功则直接返回，失败就调用处理函数；
2. 如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常；
3. 如果自定义了处理函数就进行处理，处理完再继续尝试分配内存。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121655246.png" alt="image-20220612165502162" style="zoom:80%;" />

**二级空间配置器**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121703081.png" alt="image-20220612170324000" style="zoom:90%;" />

会维护16条链表，分别是0-15号链表，最小为8字节，以8字节逐渐递增，最大为128字节。传入一个字节参数，表示需要多大的内存，会自动校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中取出，将已经取出的指针向后移动一位。

如果对应的free_list为空，先看其内存池是不是空，如果内存池不为空：

先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小的空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接取出使用。 

如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。 

如果连一个节点的内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存。 二级空间配置器会使用malloc()从堆当中申请内存，（一次所申请的内存大小为 2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。 

如果malloc()失败了，说明堆上没有足够空间来分配，这时二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比所需节点空间大的free_list中取出一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。

释放时调用deallocate()函数，若释放的 n > 128，则调用一级空间配置器，否则就直接将内存块挂在自由链表的合适位置。

STL二级空间配置器虽然解决了外部碎片的问题，提高了效率，但它同时增加了一些缺点：

因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数。若需要1个字节，它会给你8个字节，浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片。

二级空间配置器是在堆上申请大块的内存池，然后用自由链表管理。在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：

（1）若不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若想开辟大块内存就会失败；

（2）若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。

# 算法

- 排序O(n)如何实现

  [排序算法（三）：时间复杂度O(n)的排序算法_我只是一只自动小青蛙的博客-CSDN博客_空间复杂度为o(n)的排序](https://blog.csdn.net/qq_42138662/article/details/118185549)

  [O(n)的排序方法 - 提笔书几行 - 博客园 (cnblogs.com)](https://www.cnblogs.com/happysml/p/13832482.html)

# 补充

- 


































