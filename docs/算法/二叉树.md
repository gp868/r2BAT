# 二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" />

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" />

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 二叉树深度

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：递归遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" />

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 110、平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 ：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202031331.jpeg" alt="img" style="zoom: 60%;" />

```php
输入：root = [3,9,20,null,null,15,7]
输出：true
```

本题依然是二叉树深度相关的题目，依然是把计算「高度差」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

只计算一次最大深度，计算的过程中在**后序遍历位置**顺便判断二叉树是否平衡：对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。

```php
class Solution {
public:
    // 记录二叉树是否平衡
    bool balance = true;

    bool isBalanced(TreeNode* root) {
        maxDepth(root);
        return balance;
    }
	// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root){
        if(!root) return 0;
        int leftDepth= maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        if(abs(leftDepth - rightDepth) > 1) balance = false;
        return max(leftDepth, rightDepth) + 1;
    }
};
```

## 翻转二叉树

### 226、翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**解法一**：递归遍历，回溯算法的思想

遍历二叉树的每个节点，每个节点的左、右子树交换位置。

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		traverse(root);
        return root;
    }
    // 二叉树遍历函数
    void traverse(TreeNode* root){
        if(!root){
            return;
        }
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};
```

**解法二**：分解为子树的问题，动态规划思想

用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点
    TreeNode* invertTree(TreeNode* root) {
		if(!root) {
            return root;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        // 然后交换左右子节点
		root->left = right;
        root->right = left;
        return root;
    }    
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

## 路径总和

### 112、路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**解法一**：递归遍历，回溯算法思想

前部遍历位置（进入节点）`sum += root->val`，顺便判断是否到达叶子节点且和为`targetSum`；后序遍历位置（离开节点）`sum -= root->val`。

```php
class Solution {
public:
    bool res = false;
    int sum = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        // 到达叶子节点且和为targetSum
        if(!root->left && !root->right && sum == targetSum) res = true;
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
    }
};
```

**解法二**：分解成子树问题，动态规划思想

遍历到一个节点，继续遍历左孩子和右孩子，且targetSum减去节点的数值。

```php
class Solution {
    
public:
    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && root->val == targetSum) return true;
        // 左子树或者右子树有一个满足即可
        return hasPathSum(root->left, targetSum - root->val) ||
                hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113、路径总和ii

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

相对于⌈**112、路径总和**⌋来说，前序和后序位置不仅要维护`sum`，还要维护路径`path`。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && sum == targetSum) res.push_back(path);
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
        path.pop_back();
    }
};
```

### 437、路径总和iii

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221609909.jpeg" alt="img" style="zoom: 50%;" />

```php
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示
```

这题及要求你准确理解二叉树的前序后序遍历，还要熟悉前缀和技巧，把前缀和技巧用到二叉树上。

这道题涉及到数组的技巧，暂定先不做。

## 二叉树是否对称/相等

**101、对称二叉树**和**100、相同的树**结合起来看，两道题方法和代码上非常相似。

### 100、相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" />

```php
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

解法一：分解成子树问题

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        bool left = isSameTree(p->left, q->left);	//比较左子树
        bool right = isSameTree(p->right, q->right);//比较右子树
        return left && right;
    }
};
```

代码简化为：

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

**解法二**：迭代法

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        //注意不能加上写成如下代码，否则会报错
        //if(p) que.push(p);   
        //if(q) que.push(q);  
        while (!que.empty()) {  // 接下来就要判断这两颗树是否相等
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是相等的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

**注意**：

```php
que.push(p);
que.push(q);
```

不能写为：

```
if(p) que.push(p);   
if(q) que.push(q);  
```

否则会报错：

```php
执行出错信息：
Line 15: Char 74: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'TreeNode', which requires 8 byte alignment (solution.cpp)
0xbebebebebebebebe: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:74
最后执行的输入：
[]
[0]
```

加上`if`判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。

### 101、对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251941296.png" alt="101. 对称二叉树" style="zoom:55%;" />

**解法一**：分解成子树问题

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两颗树（这两颗树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

正是因为要遍历两棵树而且要**比较内侧和外侧节点**，所以准确的来说是一个树的遍历顺序是**左右中**，一个树的遍历顺序是**右左中**，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。

**返回条件**：

- 左节点为空，右节点不为空，不对称，return false；
- 左不为空，右为空，不对称 return false；
- 左右都为空，对称，返回true；
- 左右都不为空，比较节点数值，不相同就return false；
- 左右节点相等的话，再递归判断子节点；

代码如下：

```
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false;
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        bool outside = compare(left->left, right->right);   //外侧节点比较
        bool inside = compare(left->right, right->left);    //内侧节点比较
        return outside && inside;   //左右子节点需要对称相同
    }
};
```

代码简化为：

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        // 其他节点是否对称
        return compare(left->left, right->right) && compare(left->right, right->left);
    }
};
```

**解法二**：迭代法，不是层序遍历，这里我们可以使用**队列**来比较两个树（根节点的左右子树）是否相互翻转。

把左右两个子树要比较的元素顺序放进一个容器，然后**成对**的取出来进行比较，那么其实使用**栈**也是可以的。

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 572、另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` ，检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点，`tree` 也可以看做它自身的一棵子树。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" />

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

遍历以 `root` 为根的这棵二叉树的所有节点，用 ⌈**100、相同的树**⌋ 中的 `isSameTree` 函数判断以该节点为根的子树是否和以 `subRoot` 为根的那棵树相同。

```php
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
		if(!root) return root == subRoot;
        // 判断以 root 为根的二叉树是否和 subRoot 相同
        if(isSameTree(root, subRoot)) return true;
        // 去左右子树中判断是否有和 subRoot 相同的子树
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    // 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 左叶子/左下角问题

### 404、左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202035803.jpeg" alt="img" style="zoom:50%;" />

```php
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

本题遍历二叉树即可，问题是如何判断节点是**左叶子**呢？

**如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子**，必须要通过节点的父节点来判断其左孩子是不是左叶子：

```php
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
```

```php
class Solution {
public:
    int sum = 0;
    
    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return sum;
    }
    
    void traverse(TreeNode* root){
        if(!root) return;
        // 找到左侧的叶子节点，记录累加值
        if(root->left && !root->left->left && !root->left->right){
            sum += root->left->val;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```

### 513、找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204212053339.jpeg" alt="img" style="zoom:60%;" />

```
输入: root = [2,1,3]
输出: 1
```

**解法一**：递归遍历二叉树

二叉树递归框架代码是先递归左子树，后递归右子树，所以**到最大深度时第一次遇到的节点就是左下角的节点**。

```php
class Solution {
public:
    int depth;		// 记录 traverse 递归遍历到的深度
    int maxDepth;	// 记录二叉树的最大深度
    TreeNode* res;

    int findBottomLeftValue(TreeNode* root) {
        traverse(root);
        return res->val;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        depth++;
        // 到最大深度时第一次遇到的节点就是左下角的节点
        if(depth > maxDepth){
            maxDepth = depth;
            res = root;
        }
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**解法二**：层序遍历，很好理解

```php
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;	//后续循环会不断刷新result的值
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

找树左下角的值会做了，找树右下角的值自然也会做了，也就是把遍历的顺序改变一下：先遍历右子树，再遍历左子树。

## 完全二叉树

### [BM35 判断是不是完全二叉树](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树，确定他是否是一个**完全二叉树**。

**完全二叉树**的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

样例图1：叶子节点出现在最后一层

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012041648.png" alt="img" style="zoom:80%;" />

样例图2：叶子节点出现在最后一次和倒数第二层

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012050113.png" alt="img" style="zoom:60%;" />

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

本道题的解题关键就是要紧紧抓住**完全二叉树的定义**，使用**层序遍历**。如果遇到某个节点为空，进行标记，代表访问到完全二叉树的最下层，若是后续还有访问，则不符合完全二叉树的定义。

注意：

```php
que.push(node->left);
que.push(node->right);
```

不能写成：

```php
if(node->left) push(node->left);
if(node->right) que.push(node->right);
```

否则， 完全二叉树最后一层的空节点是访问不到的。


```php
class Solution {
  public:
    bool isCompleteTree(TreeNode* root) {
        //空树一定是完全二叉树
        if(root == NULL)  return true;
        queue<TreeNode*> que;
        if(root) que.push(root); 
        //定义一个首次出现的标记位
        bool flag = false; 
        while(!que.empty()){ 
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                //标记第一次遇到空节点
                if (!node) 
                    flag = true; 
                else{
                    //后续访问已经遇到空节点了，说明经过了叶子
                    if (flag) return false;
                    que.push(node->left);
                    que.push(node->right);
                }
            }
        }
        return true;
    }
};
```

### 222、完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202028146.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [1,2,3,4,5,6]
输出：6
```

首先要搞清楚什么是 ⌈**完全二叉树**⌋ 和 ⌈**满二叉树**⌋ ：

**完全二叉树**如下图，每一层都是紧凑靠左排列的，除了最底层节点可能没填满外，其余每层节点数都达到最大值：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211628453.png" alt="img" style="zoom:50%;" />

**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211629053.png" alt="img" style="zoom:80%;" />

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```php
int countNodes(TreeNode* root) {
    if (root == null) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```php
int countNodes(TreeNode* root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root->left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (2 << h) - 1;
}
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211649576.png" alt="image-20220421164919517" style="zoom:60%;" />

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211652510.png" alt="image-20220421165226452" style="zoom:40%;" />

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

```php
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 这里初始为0是有目的的，为了下面求指数方便
        int leftHeight = 0;
        int rightHeight = 0; 
        // 记录左、右子树的高度
        while (left) {
            left = left->left;
            leftHeight++;
        }
        while (right) {
            right = right->right;
            rightHeight++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

这个算法的时间复杂度是 `O(logN*logN)`，但直觉感觉好像最坏情况下是 O(N*logN) ，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```php
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `leftHeight == rightHeight` 而立即返回，不会递归下去**。

所以，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

## 二叉树展开为链表

### 114、二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 前序遍历 顺序相同。

**示例 ：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**解法一**：递归遍历

对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。

```php
class Solution {
public:
    // 虚拟头节点，res->right 就是结果
    TreeNode* res = new TreeNode(-1);
    // 用来构建链表的指针
    TreeNode* p = res;
    TreeNode* flatten(TreeNode* root) {
        traverse(root);
        return res->right;
    }
    
    void traverse(TreeNode* root){
		if(!root) return;
        p = new TreeNode(root->val);
        p = p->right;
        traverse(root->left);
        traverse(root->right);
    }
};
```

但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**解法二**：分解成子树的问题

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" />

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表
    void flatten(TreeNode* root) {
		if(!root) return;
        // 利用定义，把左右子树拉平
        flatten(root->left);
        flatten(root->right);
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 2、将左子树作为右子树
        root->left =  nullptr;
        root->right = left;
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        // 注意这里的条件是 p->right，而不是 p ，即有右孩子则移动指针
        while(p->right){
            p = p->right;
        }
        p->right = right;
    }
};
```

## 填充每个节点的下一个右侧节点指针

### 116、填充每个节点的下一个右侧节点指针

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```php
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" />

```php
输入：root = [1,2,3,4,5,6,7]
输出：[1,##,2,3,##,4,5,6,7,##]
```

这道题若使用**常规的**遍历二叉树的话，只能将一个节点的左子树指向右子树，**不同节点的子树之间无法建立联系**，所以要改变遍历的方式。传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「**空隙**」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" />

**解法一**：递归遍历二叉树

**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

```php
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        traverse(root->left, root->right);
        return root;
    }
    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2){
        if(!node1 || !node2){
            return;
        }
        node1->next = node2;
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        traverse(node1->right, node2->left);
    }
};
```

**解法二**：层序遍历

在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" />

核心代码逻辑为：

- 遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；

- 向后每遍历一个节点，用node记录该节点，然后节点出队，**pre指向node**，pre指针向后移动一位；

- 该层最后一个节点指向nullptr；

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* pre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    pre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = pre;
                } else {
                    node = que.front();
                    que.pop();
                    pre->next = node; // 本层前一个节点next指向本节点
                    pre = pre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            pre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```

二刷：

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node* pre;
            for(int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();
                if(i == 0){
                    pre = node;
                }else{
                    pre->next = node;
                    pre = node;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            pre->next = NULL;
        }
        return root;
    }
};
```

## 二叉树序列化

### 297. 二叉树的序列化与反序列化

**序列化**是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012111971.jpeg" alt="img" style="zoom:40%;" />

```php
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

使用**拼接字符串**的方式把二叉树**序列化**。

```php
class Codec {
public:

    // 序列化
    string serialize(TreeNode* root) {
        if(!root) return "##";
        return to_string(root->val) + " " + serialize(root->left) + " " + serialize(root->right);
    }

     TreeNode* build(istringstream& iss){
        string tmp;
        iss>>tmp;
        if(tmp == "##") return NULL;
        TreeNode* root = new TreeNode(stoi(tmp));
        root->left = build(iss);
        root->right = build(iss);
        return root;
    }
    // 反序列化
    TreeNode* deserialize(string data) {
        istringstream iss(data);
        return build(iss);
    }
};
```

### 652、寻找重复的子树

给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

**示例**：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？

**你需要知道以下两点**：

1、以我为根的这棵二叉树（子树）长啥样？——**后序遍历**

2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过**拼接字符串**的方式把二叉树**序列化**。

```php
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
		traverse(root);
		return res;
    }
    //定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串
    string traverse(TreeNode* root){
		if(!root) return "##";
       	string left = traverse(root->left);
        string right = traverse(root->right);
        // 后序位置获取二叉树序列化后的字符串
        string str = left + "," + right + "," + to_string(root->val);
        if(map[str] == 1){
            res.push_back(root);
        }
        map[str]++;
        return str;
    }
};
```

## 构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 617、合并二叉树

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221505893.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

```php
class Solution {
public:
    //定义：输入两二叉树根节点，返回二叉树处理后的根节点
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        root1->val += root2->val; 
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的**最大二叉树**。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" />

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" />

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" />

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值，注意不能写成 int rootVal = preorder[0];
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" />

 `postoder` 和 `inorder` 对应的状态如下：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" />

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" />

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" />

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```

## 层序遍历

### 102、二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" />

需要借用一个辅助数据结构即**队列**来实现，队列**先进先出**，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" />

```php
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 107、二叉树的层次遍历II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" />

相对于102.二叉树的层序遍历，就是最后把`result`数组反转一下就可以了。

```php
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end()); // 在这里反转一下数组即可
        return result;
    }
};
```

### 103、 二叉树的锯齿形层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251142392.jpeg" alt="img" style="zoom:60%;" />

```php
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

这题和 ⌈[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)⌋ 类似，只是要控制遍历方向，另外使用**双向队列**`deque`来记录遍历路径path。

**解法一**：使用数组的**深度奇偶变化**来控制遍历顺序

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        int depth = 0;
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // 深度为奇数则从左到右
                if(depth % 2 != 0) path.push_back(node->val);
                // 深度为偶数则从右到左
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

**解法二**：用一个**布尔变量** `flag` 控制遍历方向

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        bool flag = true;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // flag为true则从左到右
                if(flag == true) path.push_back(node->val);
                // flag为
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            flag = !flag;
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

### 515、在每个树行中找最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" />

**解法一**：递归遍历二叉树

我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

`traverse`遍历函数的参数当中只包含`TreeNode* root `可以吗？**不行！**还要加上节点所在的层数`level`，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在`traverse`函数参数当中维护。

**如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在`traverse`遍历函数的参数当中添加层数`level`。**

```php
// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    //注意如下代码中的 level + 1
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 人为设定根节点位于第1层
traverse(root, 1);
```

回到本题当中，本质上是一个求节点最大值的问题，但问题是**如何保证参与比大小求最值的节点来自于同一层呢**？

🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说**这是一个涉及二叉树层数的问题，要在`traverse`遍历函数的参数当中添加层数`level`。**

假设二叉树的层数从第0层开始算，res数组所以默认从0开始：

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**2**个元素（已获取前两层的最大值），即`level == res.size()`，表示res数组当中无该层任何节点，**将该节点添加到res数组中**；

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" />

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**3**个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则**比大小取最值**；

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" />

所以也就是说，核心代码逻辑要使用`if`语句分以上两种情况讨论。

版本一：

```php
class Solution {
public:
	vector<int> res;
    void traverse(TreeNode* root,int level){
        if(root == NULL){
            return;
        }
        if(level == res.size()){//每层第一个节点
            res.push_back(root->val);
        } else{					//每层第一个节点之外的节点
            res[level] = max(res[level], root->val);
        } 
        traverse(root->left, level + 1);
        traverse(root->right, level + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        //二叉树层数从第0层开始算
        traverse(root,0);
        return res;
    }
};
```

版本二：

```php
class Solution {
public:
    vector<int> res;
    int depth = 0;
    vector<int> largestValues(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        if(depth == res.size()) res.push_back(root->val);
        else{
            res[depth] = max(res[depth], root->val);
        }
        depth++;
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**注意**：这个版本的代码会把根节点当成第一层，但是本题是要将根节点当作第0层，所以主要代码逻辑要写在`depth++;`前面，或者初始化`int depth = -1`。

**解法二**：层序遍历

层序遍历，取每一层的最大值。

- while循环开始遍历每一层时，创建最大值`maxValue`；
- for循环遍历该层每一个节点，顺便更新`maxValue`；
- 退出for循环，该层所有节点遍历完成，`maxValue`放入结果数据`result`中；

```php
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```

### 199、二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" />

**解法一**：递归遍历

要找到每一层最右边的节点，涉及**二叉树节点所在层数**的问题，还是使用 ⌈**515、在每个树行中找最大值**⌋ 中的遍历框架。

**注意**：由于本题是要找每层最右侧节点，所以**先遍历右子树再遍历左子树**，这样每层遍历时首先访问到的就是要求的节点。

```php
class Solution {
public:
    vector<int> res;

    vector<int> rightSideView(TreeNode* root) {
        traverse(root, 0);
        return res;
    }

    void traverse(TreeNode* root, int level){
        if(!root) return;
		//这一层还没有记录值，说明 root 就是右侧视图的第一个节点
        if(res.size() == level){
            res.push_back(root->val);
        }
		// 注意，这里反过来，先遍历右子树再遍历左子树
        // 这样，首先遍历的一定是右侧节点
        traverse(root->right, level + 1);
        traverse(root->left, level + 1);
    }
};
```

那如果是要求二叉树的**左视图**呢，那就**先遍历左子树再遍历右子树**呗，又AC了一题😜。

**解法二**：层序遍历

```php
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		queue<TreeNode*> que;
        vector<int> res;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == (size - 1)){
                    res.push_back(node->val);
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### 637、二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。

**示例 ：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" />

```php
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
```

层序遍历轻松完成，**注意**：先求一层所有节点的和，最后再作除法。


```php
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 记录当前层所有节点之和
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            // 记录当前行的平均值
            res.push_back(sum / size);
        }
        return res;
    }
};
```

## 二叉树的所有路径

### 257、二叉树的所有路径

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202033263.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

遍历二叉树，这道题和 ⌈**515、在每个树行中找最大值**⌋ 在思路上很相似——回溯，遍历函数 `traverse `的参数中还需要加入路径 `path`。再说的通俗一点儿就是，左右子树都需要对路径`path`进行操作，所以左子树操作完需要**回溯**，右子树才能再操作，不然右子树操作的就是左子树操作完的结果。

```php
class Solution {
public:
    // 记录所有从根节点到叶子节点的路径
    vector<string> res;
	string path;
    vector<string> binaryTreePaths(TreeNode* root) {
        // 记录 traverse 函数递归时的路径
        traverse(root, path);
        return res;
    }
    
    void traverse(TreeNode* root, string path){
        if(!root) return;
        path += to_string(root->val);
        //遍历到叶子节点，路径path加入res数组
        if(!root->left && !root->right){
            res.push_back(path);
        }
        traverse(root->left, path + "->");
        traverse(root->right, path + "->");
    }
};
```

## 最近公共祖先

何为最近公共祖先呢？

**如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

先来实现一个简单的算法：输入一棵**没有重复元素**的二叉树根节点`root`和目标值`val1`，`val2`，写一个函数寻找树中值为`val1`**或**`val2`的节点。

```php
//定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点
TreeNode* find(TreeNode* root, int val1, int val2){
    if(!root) return nullptr;
    // 前序位置，在每一个节点处判断
    if(root->val == val1 || root->val == val2) return root;
    //左右子树寻找
    TreeNode* left = find(root->left, val1, val2);
    TreeNode* right = find(root->right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值
	return left != nullptr ? left : right;
}
```

**最近公共祖先系列问题的解法都是把这个函数作为框架的**。

### 236、二叉树的最近公共祖先

给你输入一棵**不含重复值**的二叉树，以及**存在于树中的**两个节点`p`和`q`，请你计算`p`和`q`的最近公共祖先节点。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241139188.jpg" alt="640" style="zoom:40%;" />

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" />

在`find`函数的后序位置，如果发现`left`和`right`都非空，就说明当前节点是`LCA`节点，即解决了第一种情况；

在`find`函数的前序位置，如果找到一个值为`val1`或`val2`的节点则直接返回，恰好解决了第二种情况。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return find(root, p->val, q->val);
    }
    // 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
    TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(root->val == val1 || root->val == val2) return root;
        //左右子树寻找
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

因为题目说了`p`和`q`一定存在于二叉树中(这点很重要），所以即便我们遇到`q`就直接返回，根本没遍历到`p`，也依然可以断定`p`在`q`底下，`q`就是`LCA`节点。

### 1676、二叉树的最近公共祖先 IV

给定一棵[二叉树](https://so.csdn.net/so/search?q=二叉树&spm=1001.2101.3001.7020)的根节点 `root `和 TreeNode 类对象的数组（列表） `nodes`，返回 `nodes `中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都**存在于该二叉树中**，且二叉树中所有节点的值都是互不相同的。

**示例 3:**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241156790.png" alt="在这里插入图片描述" style="zoom:100%;" />

```php
输入: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
输出: 5
解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。
```

依然给你输入一棵不含重复值的二叉树，但这次不是给你输入`p`和`q`两个节点了，而是给你输入一个包含若干节点的列表`nodes`（这些节点都存在于二叉树中），其实换汤不换药，还是使用这个框架。

为了高效地查找数组`nodes`中的元素，使用**哈希表**来装载数组元素，`unordered_set` 来实现。

```php
class Solution {
public:
	unordered_set<int> set; 
    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {
    	for(TreeNode* node: nodes){
            set.insert(node->val);
        }
        return find(root);
    }
    
    // 在二叉树中寻找 val 的最近公共祖先节点
    TreeNode* find(TreeNode* root){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(set.count(root->val)) return root;
        //左右子树寻找
        TreeNode* left = find(root->left);
        TreeNode* right = find(root->right);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

不过需要注意的是，这两道题的题目都明确告诉我们**这些节点必定存在于二叉树中**，如果没有这个前提条件，就需要修改代码了。

### 1644、二叉树的最近公共祖先 II

给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一**不存在于该二叉树中**，返回 null。树中的每个节点值都是互不相同的。

在解决标准的最近公共祖先问题时，我们在`find`函数的前序位置有这样一段代码：

```php
// 前序位置
if (root.val == val1 || root.val == val2) {
    // 如果遇到目标值，直接返回
    return root;
}
```

因为`p`和`q`都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" />

但对于这道题来说，`p`和`q`不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行**完全搜索**（遍历每一个节点），如果发现`p`或`q`不存在于树中，那么是不存在`LCA`的。

哪种写法能够对二叉树进行完全搜索呢？只需要**把前序位置的判断逻辑放到后序位置**即可：

```php
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 先去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 后序位置，判断 root 是不是目标节点
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，再去看看哪边的子树找到了
    return left != null ? left : right;
}
```

同时还要使用`bool`变量记录一下`p` 和 `q `是否存在于二叉树中，若有一个不存在，则返回NULL；若两者都存在，则找到了`LCA`。

```php
class Solution{
    // 用于记录 p 和 q 是否存在于二叉树中
    bool findP = false;
    bool findQ = false;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
		if(!findP || !findQ) return nullptr;
        // p 和 q 都存在二叉树中，才有公共祖先
        return find(root, p->val, q->val);
	}
	
	// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
		// 后序位置，判断当前节点是不是 LCA 节点
        if(left && right) return root;
        // 后序位置，判断当前节点是不是目标值
        if(root->val == val1 || root->val == val2){
            if(root->val == val1) findP = true;
            if(root->val == val2) findQ = true;
            return root;
        }
        return left != nullptr ? left : right;
    }
};
```

### 235、二叉搜索树的最近公共祖先

输入一棵不含重复值的**二叉搜索树**，以及**存在于树中**的两个节点`p`和`q`，请计算`p`和`q`的最近公共祖先节点。

把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「**左小右大**」的性质，显然效率不是最高的。

在标准的最近公共祖先问题中，我们要在**后序位置**通过左右子树的搜索结果来判断当前节点是不是`LCA`：

```php
TreeNode left = find(root.left, val1, val2);
TreeNode right = find(root.right, val1, val2);

// 后序位置，判断当前节点是不是 LCA 节点
if (left != null && right != null) {
    return root;
}
```

但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，**将当前节点的值与`val1`和`val2`作对比**，即可判断当前节点是不是`LCA`：

- 假设`val1 < val2`，那么`val1 <= root->val <= val2`，则说明当前节点就是`LCA`；

- 若`root->val`比`val1`还小，则需要去值更大的右子树寻找`LCA`；

- 若`root->val`比`val2`还大，则需要去值更小的左子树寻找`LCA`。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 保证 val1 较小，val2 较大
        int val1 = min(p->val, q->val);
        int val2 = max(p->val, q->val);
        return find(root, val1, val2);
    }
    // 在 BST 中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 当前节点太大，去左子树找
        if(root->val > val2) return find(root->left, val1, val2);
        // 当前节点太小，去右子树找
        if(root->val < val1) return find(root->right, val1,val2);
        // val1 <= root.val <= val2
    	// 则当前节点就是最近公共祖先
        return root;
    }
};
```

### 1650、二叉树的最近公共祖先 III

给定一棵二叉树中的两个节点 `p` 和 `q`，返回它们的最近公共祖先节点（LCA）。每个节点都包含其父节点的引用（指针），`Node `的定义如下：

```php
class Node {
    int val;
    Node* left;
    Node* right;
    Node* parent;
};
```

**这道题其实不是公共祖先的问题，而是单链表相交的问题**，你把`parent`指针想象成单链表的`next`指针，题目就变成了：给你输入两个单链表的头结点`p`和`q`，这两个单链表必然会相交，请你返回相交点。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241502457.png" alt="image-20220424150259400" style="zoom:60%;" />

**解法一**：双指针法

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
		// 链表双指针技巧
    	node* a = p;
        node* b = q;
        while(a != b){
            // a 走一步，如果走到根节点，转到 q 节点
            if(!a) a = q;
            else a = a->parent;
            // b 走一步，如果走到根节点，转到 p 节点
            if(!b) b = p;
            else b = b->parent;
        }
        return a;
    };
```

**解法二**：哈希表

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
        unordered_set<int> sign;
        // 将节点p的元素存入哈希表
        while(p!=NULL){
            sign.insert(p->val);
            p=p->parent;
        }
        // 节点q的元素在哈希表中查询，第一次出现的即LCA
        while(q!=NULL){
            if(sign.count(q->val)){
                return q;
            }
            q=q->parent;
        }
        return NULL;
    }
};
```

## 二叉搜索树

二叉搜索树（Binary Search Tree，后文简写 BST）有如下特性：

1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。

2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有**AVL 树**，**红黑树**等等，拥有了自平衡性质，可以提供 **logN**级别的增删查改效率；还有 **B+** 树，线段树等结构都是基于 BST 的思想来设计的。

从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：**BST 的中序遍历结果是有序的（升序）**。

也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->left);
    // 这里添加中序遍历代码
    traverse(root->right);
}
```

那么根据这个性质，我们来做两道算法题。

BST 相关的问题，要么利用 **BST 左小右大**的特性提升算法效率，要么利用**中序遍历**的特性满足题目的要求。

### 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251501802.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [3,1,4,null,2], k = 1
输出：1
```

最直接的思路就是**升序排序**，然后找第 `k` 个元素，BST 的中序遍历其实就是升序排序的结果。

```php
class Solution {
public:
    // 记录当前元素的排名
    int count = 0;
    int res;
    int kthSmallest(TreeNode* root, int k) {
        // 利用 BST 的中序遍历特性
        traverse(root, k);
        return res;
    }

    void traverse(TreeNode* root, int k){
        if(!root) return;
        traverse(root->left, k);
        /* 中序遍历代码位置 */
        count++;
        // 找到第 k 小的元素
        if(count == k){
            res = root->val;
            return;
        }
        traverse(root->right, k);
    }
};
```

### 538. 把二叉搜索树转换为累加树

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251517895.png" alt="img" style="zoom:50%;" />

```php
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

 BST 的中序遍历代码可以升序打印节点的值，那降序打印节点的值怎么办呢？

只要把递归顺序改一下就行了：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->right);
    // 这里添加中序遍历代码
    traverse(root->left);
}
```

这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗？

```php
class Solution {
public:
    //记录累加和
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->right);
        // 维护累加和
        sum += root->val;
        // 将 BST 转化成累加树
        root->val = sum;
        traverse(root->left);
    }
};
```

### 530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271647211.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [4,2,6,1,3]
输出：1
```

中序遍历会有序遍历 BST 的节点，遍历过程中计算最小差值即可。因为要做差，所以需要维护一个`pre`指针来记录上一个节点。

```php
class Solution {
public:
    int res = INT_MAX;
    TreeNode* pre = nullptr;
    int getMinimumDifference(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        //这里的if(pre)判断条件不能掉
        if(pre) res = min(root->val - pre->val, res);
        pre = root;
        traverse(root->right);
    }
};
```

### 501. 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有众数（即出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271843086.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [1,null,2,2]
输出：[2]
```

首先，需要统计节点出现的频率，维护一个`pre`指针：

- 若`pre`为空，则为第一个节点；
- 若`pre->val == root->val`，则频率加1；
- 若`pre->val != root->val`，则出现新的节点，频率为1；

然后，与最大频率作比较：

- 若频率等于最大频率，节点加入数组；
- 若频率大于最大频率，则更新最大数值，清空数组后加入该节点；

```php
class Solution {
public:
    int count = 0;
    int maxCount = 0;
    TreeNode* pre = nullptr;
    vector<int> res;

    vector<int> findMode(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        // 统计root节点出现的频率
        if(!pre) count = 1;						//第一个节点
        else if(pre->val == root->val) count++;	//与前一个节点值相等
        else count = 1;							//与前一个节点值不等
        pre = root;
        
        // 和最大频率作比较，判断是否加入数组
        if(count == maxCount) res.push_back(root->val);
        else if(count > maxCount){
            maxCount = count;
            res.clear();
            res.push_back(root->val);
        }
        traverse(root->right);
    }
};
```

### 剑指 Offer 36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

以下面的二叉搜索树为例：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301207350.png" alt="img" style="zoom:40%;" />

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

1. **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点。
2. **双向链表：** 在构建相邻节点的引用关系时，设前驱节点 `pre` 和当前节点 `cur` ，不仅应构建 `pre->right = cur` ，也应构建 `cur->left = pre` 。
3. **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head->left = tail` 和 `tail->right = head` 。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301210130.png" alt="Picture1.png" style="zoom:50%;" />

```php
class Solution {
public:
    Node* head = NULL;
    Node* pre = NULL;
    Node* treeToDoublyList(Node* root) {
        if(!root) return head;
        traverse(root);
        head->left = pre;
        pre->right = head;
        return head;
    }

    void traverse(Node* root){
        if(!root) return;
        traverse(root->left);
        if(pre){
            pre->right = root;
            root->left = pre;
        }else{
            head = root;
        }
        pre = root;
        traverse(root->right);
    }
};
```



------

BST 的完整定义如下：

1、BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。

2、BST 中任意一个节点的左右子树都是 BST。

有了 BST 的这种特性，就可以在二叉树中做类似**二分搜索**的操作，搜索一个元素的效率很高。

比如下面这就是一棵合法的二叉树：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251601659.png" alt="img" style="zoom:18%;" />

对于 BST 相关的问题，经常会看到类似下面这样的代码逻辑：

```php
void BST(TreeNode* root, int target) {
    if (root->val == target)
        // 找到目标，做点什么
    if (root->val < target) 
        BST(root->right, target);
    if (root->val > target)
        BST(root->left, target);
}
```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST **左小右大**的特性而已。

### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251606314.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [2,1,3]
输出：true
```

**解法一**：中序遍历，需要比较节点和上一个节点的大小关系，所以引入指针`pre`。

```php
class Solution {
public:
    TreeNode* pre = nullptr; //记录前一个节点
    bool isValidBST(TreeNode* root) {
        // 二叉搜索树也可以为空
        if(!root) return true;
        bool left = isValidBST(root->left);
        if(pre && pre->val >= root->val) return false;
        pre = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

**解法二**：二叉树定义，左小右大

这里有一个陷阱：BST 不是左小右大么，那我只要检查 `root->val > root->left->val` 且 `root->val < root->right->val` 不就行了？

这样是**错误**的，因为 BST**左小右大**的特性是指 `root->val` 要比左子树的所有节点都更大，要比右子树的所有节点都小，只检查左右两个子节点当然是不够的。

**正确解法**是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。

```php
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return valid(root, nullptr, nullptr);
    }

    bool valid(TreeNode* root, TreeNode* min, TreeNode* max){
        if(!root) return true;
        if(min && root->val <= min->val) return false;
        if(max && root->val >= max->val) return false;
        return valid(root->left, min, root) && valid(root->right, root, max);
    }
};
```

### 669. 修剪二叉搜索树

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271918176.jpeg" alt="img" style="zoom:40%;" />

```php
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

明确了递归函数的定义之后进行思考，如果一个节点的值没有落在 `[lo, hi]` 中，有两种情况：

1、`root.val < lo`，这种情况下 `root` 节点本身和 `root` 的左子树全都是小于 `lo` 的，都需要被剪掉，返回`root` 的右子树；

2、`root.val > hi`，这种情况下 `root` 节点本身和 `root` 的右子树全都是大于 `hi` 的，都需要被剪掉， 返回`root` 的左子树；

```php
class Solution {
public:
    // 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root) return root;
        // 直接返回 root.right，等于删除 root 以及 root 的左子树
        if(root->val < low) return trimBST(root->right, low,high);
        // 直接返回 root.left，等于删除 root 以及 root 的右子树
        if(root->val > high) return trimBST(root->left, low, high);
        // 闭区间 [lo, hi] 内的节点什么都不做
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### 700. 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204270954033.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

解法一：二叉树定义，左小右大

```php
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return root;
        //比目标值大，到左子树寻找
        if(root->val > val) return searchBST(root->left, val);
        //比目标值小，到右子树找
        if(root->val < val) return searchBST(root->right, val);
        //等于目标值，返回节点
        return root;
    }
};
```

解法二：中序遍历

```php
class Solution {
public:
    TreeNode* res;
    TreeNode* searchBST(TreeNode* root, int val) {
        traverse(root, val);
        return res;
    }

    void traverse(TreeNode* root, int val){
        if(!root) return;
        traverse(root->left, val);
        if(root->val == val){
            res = root;
            return;
        }
        traverse(root->right, val);
    }
};
```

### 701. 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树，返回插入后二叉搜索树的根节点。 输入数据 **保证**新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271015149.jpeg" alt="img" style="zoom:50%;" />

```php
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
```

如果要递归地插入或者删除二叉树节点，递归函数一定要有返回值，而且返回值要被正确的接收。

插入的过程可以分两部分：

1、寻找正确的插入位置，类似 [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree)。

2、把元素插进去，这就要把新节点以返回值的方式接到父节点上。

```php
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 找到空位置插入新节点
        if(!root) return new TreeNode(val);
        if(root->val > val) root->left = insertIntoBST(root->left, val);
        if(root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变，返回二叉搜索树（有可能被更新）的根节点的引用。

跟插入操作类似，先「找」再「改」，先把框架写出来：

```php
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root->val == key) {
        // 找到啦，进行删除
    } else if (root->val > key) {
        // 去左子树找
        root->left = deleteNode(root->left, key);
    } else if (root.val < key) {
        // 去右子树找
        root->right = deleteNode(root->right, key);
    }
    return root;
}
```

删除比插入和搜索都要复杂一些，分三种情况：

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么直接删除：

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044120.png" alt="img" style="zoom:25%;" />

```php
if (root->left == null && root->right == null)
    return null;
```

**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044561.png" alt="img" style="zoom:48%;" />

```php
// 排除了情况 1 之后
if (root->left == null) return root->right;
if (root->right == null) return root->left;
```

**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到**左子树中最大的那个节点**，或者**右子树中最小的那个节点**来接替自己，下列为第二种方式。

![img](https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271046754.png)

```php
if (root->left != null && root->right != null) {
    // 找到右子树的最小节点
    TreeNode* minNode = getMin(root->right);
    // 把 root 改成 minNode
    root->val = minNode->val;
    // 转而去删除 minNode
    root->right = deleteNode(root->right, minNode->val);
}
```

三种情况分析完毕，填入框架，简化一下代码：

```php
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return root;
        if(root->val == key){
        	// 这两个 if 把情况 1 和 2 都正确处理了
            if(!root->left) return root->right;
            if(!root->right) return root->left;
        	// 处理情况 3
        	// 获得右子树最小的节点
            TreeNode* minNode = getMin(root->right);
            // 删除右子树最小的节点
            root->right = deleteNode(root->right, minNode->val);
            // 用右子树最小的节点替换 root 节点
            minNode->left = root->left;
            minNode->right = root->right;
            root = minNode;
        }else if(root->val > key){
            root->left = deleteNode(root->left, key);
        }else if(root->val < key){
            root->right = deleteNode(root->right, key);
        }
        return root;
    }

    TreeNode* getMin(TreeNode* root){
        // BST 最左边的就是最小的
        while(root->left) root = root->left;
        return root;
    }
};
```

### 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" />

```php
输入：n = 3
输出：5
```

`dp[i]`：1到`i`为节点组成的二叉搜索树的个数为`dp[i]`，也可以理解是`i`的不同元素节点组成的二叉搜索树的个数为`dp[i]`，都是一样的。

`dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]`，`j`相当于是头结点的元素，从1遍历到`i`为止。所以递推公式：`dp[i] += dp[j - 1] * dp[i - j]`，`j - 1` 为`j`为头结点的左子树节点数量，`i - j` 为以`j`为头结点的右子树节点数量。

初始化：从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，所以初始化`dp[0] = 1`。

 ```php
 class Solution {
 public:
     int numTrees(int n) {
         vector<int> dp(n + 1);
         dp[0] = 1;
         for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= i; j++) {
                 dp[i] += dp[j - 1] * dp[i - j];
             }
         }
         return dp[n];
     }
 };
 ```

### 95. 不同的二叉搜索树 II

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** ，可以按 **任意顺序** 返回答案。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271559371.jpeg" alt="img" style="zoom:50%;" />

```php
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

想要构造出所有合法 BST，分以下三步：

1、穷举 `root` 节点的所有可能；

2、递归构造出左右子树的所有合法 BST；

3、给 `root` 节点穷举所有左右子树的组合。

```php
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n == 0) return {};
        return build(1, n);
    }
    //定义：构造闭区间 [lo, hi] 组成的 BST
    vector<TreeNode*> build(int lo, int hi){
        vector<TreeNode*> res;
        if(lo > hi){
            res.push_back(nullptr);
            return res;
        }
        //1、穷举root节点所有可能
        for(int i = lo; i <= hi; i++){
            // 2、递归构造出左右子树的所有合法 BST
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);
            // 3、给 root 节点穷举所有左右子树的组合
            for(TreeNode* left: leftTree){
                for(TreeNode* right: rightTree){
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

### 108. 将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例：**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271942183.jpeg" alt="img" style="zoom:50%;" />

```php
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
```

二叉树的构建问题很简单，说白了就是：构造根节点，然后构建左右子树。

一个有序数组对于 BST 来说就是**中序遍历**结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。

```php
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int left, int right){
        if(left > right) return nullptr;
        int mid = (left + right + 1) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums, left, mid - 1);
        root->right = build(nums, mid + 1, right);
        return root;
    }
};
```

### 109、有序链表转换二叉搜索树

给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。

**示例:**

<img src="https://gcore.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301023724.jpeg" alt="img" style="zoom:40%;" />

```php
输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
```

链表和数组相比的一个关键差异是无法通过索引快速访问元素，所以这题有几个思路：

1、把链表转化成数组，然后直接复用 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法。

2、稍微改写 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法，用 [单链表的六大解题套路](https://labuladong.github.io/article/fname.html?fname=链表技巧) 说到的双指针方法获取链表的中点，时间复杂度略高一些。

3、如果深刻理解二叉树算法，可以利用中序遍历的特点写出最优化的解法。

**解法一**：中序遍历，分冶的思想

```php
class Solution {
public:
    TreeNode* buildTree(ListNode* &p, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        int mid = (left + right + 1) / 2;
        TreeNode* leftTree = buildTree(p, left, mid - 1);
        TreeNode* root = new TreeNode(p->val);
        p = p->next;
        TreeNode* rightTree = buildTree(p, mid + 1, right);
        root->left = leftTree;
        root->right = rightTree;
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int len = 0;
        for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next){
            len++;
        }
        return buildTree(head, 0, len - 1);
    }
};
```

**解法二**：**双指针**获取链表的中点

```php
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return build(head, nullptr);
    }

    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST
    TreeNode* build(ListNode* begin, ListNode* end){
        if(begin == end) return nullptr;
        ListNode* mid = getMid(begin, end);
        TreeNode* root = new TreeNode(mid->val);
        root->left = build(begin, mid);
        root->right = build(mid->next, end);
        return root;
    }

    // 获取链表左闭右开区间 [begin, end) 的中心节点
    ListNode* getMid(ListNode* begin, ListNode* end){
        ListNode* slow = begin;
        ListNode* fast = begin;
        while(fast != end && fast->next != end){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 剑指 Offer 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例：**

```php
输入: [1,6,3,2,5]
输出: false
```

- 利用二叉搜索树**左大右小**的性质划分左右子树：

  遍历后序遍历的`[start, end]`区间的元素，寻找第一个大于根节点的节点，索引记为 `midIndex `。此时，可划分出左子树区间 `[start, midIndex - 1]`，右子树区间` [midIndex, end - 1] `、根节点索引 `end`。

- 判断是否为二叉搜索树：
  左子树区间 `[start, midIndex - 1]`内的所有节点都应 `< postorder[end]` 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
  右子树区间 ` [midIndex, end - 1] ` 内的所有节点都应 `> postorder[j]` 。实现方式为遍历，当遇到 `≤postorder[j]`的节点则跳出；则可通过`index == end`判断是否为二叉搜索树。

- 返回值： 

  所有子树都需正确才可判定正确，因此使用 与逻辑符 && 连接。
  

```php
class Solution {
public:
    bool traversal(vector<int>& postorder, int start, int end) {
        /* 递归终止条件 */
        if(start > end) return true;
        int index = start;
        /* 中间处理逻辑 */
        while(postorder[index] < postorder[end]) index++;
        /* 记录分割点 */
       int midIndex = index;
        while(postorder[index] > postorder[end]) index++;
        /* 递归左右子树 */
        bool left = traversal(postorder, start, midIndex - 1);
        bool right = traversal(postorder, midIndex, end - 1);
        return index == end && left && right;
    }

    bool verifyPostorder(vector<int>& postorder) {
        return traversal(postorder, 0, postorder.size() - 1);
    }
};
```







## 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)

[题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)](https://leetcode-cn.com/problemset/all/)













