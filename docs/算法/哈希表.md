# 哈希表

## 剑指 Offer 03. 数组中重复的数字

找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```php
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

用一个哈希表`unordered_map<int, bool> map`来记录数组中的元素，若为true则重复。

```php
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, bool> map;
        for(int num : nums) {
            if(map[num]) return num;
            map[num] = true;
        }
        return -1;
    }
};
```

## 349. 两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```php
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序，使用 `unordered_set`。

```php
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> res;
        unordered_set<int> set(nums1.begin(), nums1.end());
        for(int num : nums2){
            if(set.count(num)){
                res.insert(num);
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};
```

## 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```php
输入: s = "anagram", t = "nagaram"
输出: true
```

定义一个数组叫做record用来上记录字符串s里字符出现的次数。需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。

再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。这样就将字符串s中字符出现的次数，统计出来了。

那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

```php
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                return false;
            }
        }
        return true;
    }
};
```

## 剑指 Offer 39. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 ```php
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
 ```

哈希表：

```php
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int res, n = nums.size();
        unordered_map<int, int> map;
        for(int i = 0; i < n; i++){
            map[nums[i]]++;
            if(map[nums[i]] > n / 2){
                return nums[i];
            }
        }
        return -1;
    }
};
```

## 560. 和为 K 的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

```php
输入：nums = [1,1,1], k = 2
输出：2
```

```php
输入：nums = [1,2,3], k = 3
输出：2
```

遍历数组nums，计算从第0个元素到当前元素的和，用哈希表保存出现过的累积和sum的次数。如果sum - k在哈希表中出现过，则代表从当前下标i往前有连续的子数组的和为sum。时间复杂度为$O(n)$，空间复杂度为$O(n)$。

```php
class Solution {
public:
    int subarraySum(vector<int> &nums, int k) {
        int sum = 0, res = 0;
        unordered_map<int, int> map;
        map[0] = 1;
        for (int &num : nums) {
            sum += num;
            res += map[sum - k];
            map[sum]++;
        }
        return res;
    }
};

```

## 387. 字符串中的第一个唯一字符

给定一个字符串 `s` ，找到 它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 `-1` 。

```
输入: s = "leetcode"
输出: 0
输入: s = "loveleetcode"
输出: 2
```

考察哈希表的使用。

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char, int> map;
        for(char ch : s){
            map[ch]++;
        }
        for(int i = 0; i < s.size(); i++){
            if(map[s[i]] == 1){
                return i;
            }
        }
        return -1;
    }
};
```

## 217. 存在重复元素

给你一个整数数组 `nums` 。如果任一值在数组中出现**至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

```php
输入：nums = [1,2,3,1]
输出：true
输入：nums = [1,2,3,4]
输出：false
```

哈希表：

```php
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> set;
        for(int num : nums){
            if(set.count(num)){
                return true;
            }
            set.insert(num);
        }
        return false;
    }
};
```

## 219. 存在重复元素 II

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

```php
输入：nums = [1,2,3,1], k = 3
输出：true
输入：nums = [1,0,1,1], k = 1
输出：true
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```

哈希表：

```php
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            if (map.count(num) && i - map[num] <= k) {
                return true;
            }
            map[num] = i;
        }
        return false;
    }
};
```

滑动窗口：

```php
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n = nums.size();
        if(n < 2) return false;
        int left = 0, right = 0;
        unordered_map<int, int> window;
        while(right < n){
            int a = nums[right];
            window[a]++;
            right++;
            while(right - left > k){
                int b = nums[left];
                left++;
                if(right - left == k){
                    if(window[a] > 1){
                        return true;
                    }
                }
                window[b]--;
            }
            // 达不到k的时候个数大于1返回true
            if(window[a] > 1){
                return true;
            }
        }
        return false;
    }
};
```

## 187. 重复的DNA序列

**DNA序列** 由一系列核苷酸组成，缩写为 `'A'`, `'C'`, `'G'` 和 `'T'`.。例如，`"ACGAATTCCG"` 是一个 **DNA序列** 。在研究 **DNA** 时，识别 DNA 中的重复序列非常有用。

给定一个表示 **DNA序列** 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 **长度为 `10`** 的序列(子字符串)。你可以按 **任意顺序** 返回答案。

```php
输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]
解释：子串 "AAAAACCCCC" 和 "CCCCCAAAAA" 都重复出现了两次。
```

哈希表：

```php
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        unordered_map<string, int> cnt;
        int n = s.length();
        for (int i = 0; i <= n - 10; ++i) {
            string sub = s.substr(i, 10);
            if (++cnt[sub] == 2) {
                ans.push_back(sub);
            }
        }
        return ans;
    }
};
```

滑动窗口：

你把 `AGCT` 四种字符等价为 `0123` 四个数字，那么长度为 `L = 10` 的一个碱基序列其实就可以等价为一个十位数，这个数字可以唯一标识一个子串。**而且窗口移动的过程，其实就是给这个数字的最低位添加数字，并删除最高位数字的过程**，可以在 `O(1)` 的时间完成。

不在哈希集合中直接存储子串了，而是存储子串对应的十位数。因为一个十位数可以唯一标识一个子串，所以也可以起到识别重复的作用。这样就避免了直接生成子串存入集合，而是生成一个十位数来表示子串，而且生成这个十位数的时间花费为 `O(1)`，从而降低了匹配算法的时间复杂度。

```php
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        // 先把字符串转化成四进制的数字数组
        int n = s.size();
        vector<int> nums(n);
        for(int i = 0; i < n; i++){
            switch(s[i]){
                case 'A':
                    nums[i] = 0;
                    break;
                case 'G':
                    nums[i] = 1;
                    break;
                case 'C':
                    nums[i] = 2;
                    break;
                case 'T':
                    nums[i] = 3;
                    break;
            }
        }
        
        // 记录重复出现的哈希值
        unordered_set<int> set;
        // 记录重复出现的字符串结果
        unordered_set<string> res;
        // 数字位数
        int L = 10;
        // 进制
        int R = 4;
        // 存储 R^(L - 1) 的结果
        int RL = (int) pow(R, L - 1);
        // 维护滑动窗口中字符串的哈希值
        int windowHash = 0;

        // 滑动窗口代码框架，时间 O(N)
        int left = 0, right = 0;
        while(right < n){
            windowHash = R * windowHash + nums[right];
            right++;
            if(right - left == L){
                if(set.count(windowHash)){
                    res.insert(s.substr(left, right - left));
                }else{
                    set.insert(windowHash);
                }
                windowHash = windowHash - nums[left] * RL;
                left++;
            }
        }
        return vector<string>(res.begin(), res.end());
    }
};
```

## 169. 多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊n / 2⌋` 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```php
输入：nums = [3,2,3]
输出：3
```

哈希表：

```php
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int target = n / 2;
        unordered_map<int, int> map;
        for(int num : nums){
            map[num]++;
            if(map[num] > target){
                return num;
            }
        }
        return 0;
    }
};
```

消消乐：

使用两个变量，一个存储要比较的元素，一个存储当前剩余的可以比较消除的次数。在遍历的过程中，遇到相同的数字则将次数加一，遇到不同的数字则减一，若是遇到零，则更新当前元素，重新计数比较。

```php
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 1;
        int maj = nums[0];
        for(int i = 1; i < nums.size(); i++){
            if(maj == nums[i]){
                count++;
            }else{
                count--;
                if(count == 0){
                    // 此时与nums[i]相同和不同的元素个数相等
                    maj = nums[i + 1];
                }
            }
        }
        return maj;
    }
};
```

## 229. 多数元素 II

给定一个大小为 *n* 的整数数组，找出其中所有出现超过 `⌊ n / 3 ⌋` 次的元素。

```php
输入：nums = [3,2,3]
输出：[3]
```

哈希表：

```php
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int n = nums.size();
        int target = n / 3;
        unordered_map<int, int> map;
        unordered_set<int> res;
        for(int num : nums){
            map[num]++;
            if(map[num] > target){
                res.insert(num);
            }
        }
        return vector<int>(res.begin(), res.end());
    }
};
```

## 49. 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

```php
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```php
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        /* 根据返回值定义存储结果的变量 */
        vector<vector<string>> result;
        unordered_map<string, vector<string>> map;
        for (string& str: strs) {
            string key = str;
            /* 将串排序后便于统一作为键 */
            sort(key.begin(), key.end());
            /* 将相同键值的字符串放入vector容器中 */
            map[key].push_back(str);
        }
        /* 取出相同键值的vector */
        for (auto it = map.begin(); it != map.end(); ++it){
            result.push_back(it->second);
        }
        return result;
    }
};
```





