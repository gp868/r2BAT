# 数组

## 平方数（根）

### 367. 有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

```c
输入：num = 16
输出：true
```

可使用二分查找，因为`num`是正整数，所以若正整数`a`满足`a x a = num`，则一定满足`1 < a < num`，于是我们可以将`1`和`num`作为二分查找搜索区间的初始边界。

```c
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0, right = num;
        while(left <= right){
            int mid = left + (right - left) / 2;
            long a = (long)mid * mid;
            if(a < num){
                left = mid + 1;
            }else if(a > num){
                right = mid - 1;
            }else{
                return true;
            }
        }
        return false;
    }
};
```

### 69  x的平方根

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

```
输入：x = 4
输出：2
```

二分查找。

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0, right = x;
        int res = 0;
        while(left <= right){
            int mid = left + (right - left) / 2;
            long num = (long)mid * mid;
            if(num <= x){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return right;
    }
};
```

## 极值

### 162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。你可以假设 `nums[-1] = nums[n] = -∞` 。你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

```c
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

二分搜索：

根据左右指针计算中间位置 mid，并比较 nums[mid] 与 nums[mid + 1] 的值：如果 nums[mid] 较大，则左侧存在峰值，right = mid；如果 nums[mid + 1] 较大，则右侧存在峰值，left = mid + 1。

```c
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(left < right){ 
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[mid + 1]){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left; 
    }
};
```

### 153 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转，( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中**不存在重复元素**。

```
输入: [3,4,5,1,2]
输出: 1
```

1. 使用二分搜索；
2. 每次比较中间值和右侧值的大小，若是小于右侧值，说明右侧有序，且最小值在左侧；
3. 否则，说明右侧的值是无序的，且最小值在右侧；

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[right]){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return nums[left];
    }
};
```

### 剑指 Offer 11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个**可能存在重复**元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转，请返回旋转数组的最小元素。

```c
输入：numbers = [3,4,5,1,2]
输出：1
```

二分法，思路：

1. 若是区间中点值大于区间右界值，则最小的数字一定在中点右边；
2. 若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界；
3. 若是区间中点值小于区间右界值，则最小的数字一定在中点左边；

```c
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int n = numbers.size();
        int left = 0, right = n - 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if(numbers[mid] < numbers[right]){
                right = mid;
            }else if(numbers[mid] > numbers[right]){
                left = mid + 1;
            }else{
                right--;
            }
        }
        return numbers[left];
    }
};
```

### 33. 搜索旋转排序数组

整数数组 nums 按**升序排列**，数组中的值互不相同。给你**旋转后**的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

```c
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

二分法，主要思路：

1. 原来有序的数组旋转后，从中间分成两部分之后，则一定是一半是有序的，一半是无序的；
2. 从中间分割后，先判断出哪一半是有序的，然后使用有序的部分，判断当前的目标是否在该有序部分内。若在，则使用该部分接着做分割查找；若不在，则使用另外的部分做分割查找；

```c
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < nums[right]){
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }else{
                if(nums[left] <= target && target < nums[mid]){
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
};
```

## 二分其他

### 704. 二分查找

给定一个 `n `个元素有序的（升序）整型数组 `nums `和一个目标值 `target  `，写一个函数搜索 `nums `中的 `target`，如果目标值存在返回下标，否则返回 -1。

```c
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
```

版本一：

```c
//闭区间[left, right]
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target)  right = mid - 1;
            else if (nums[mid] < target)  left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

版本二：

```c
//左闭右开区间[left, right)
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }
        return -1;
   }
};
```

🔥while 循环的条件是 <=还是 <？

`right = nums.size() - 1`相当于两端都闭区间 `[left, right]`，`right = nums.size()`相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```c
if(nums[mid] == target) return mid; 
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

版本一：

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

版本二：

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right)`，或者带个具体的数字进去 `[2, 2)`，**这时候区间为空**，所以这时候 while 循环终止是正确的，直接返回 -1 即可。



### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照**升序**排列的整数数组 `nums`，和一个目标值 `target`，找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```c
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

1. **寻找左侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 `target `的最左侧索引，所以当 `nums[mid] == target `时不要立即返回，而要收紧右侧边界以锁定左侧边界。

2. **寻找右侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 target 的最右侧索引，所以当 `nums[mid] == target` 时不要立即返回，而要收紧左侧边界以锁定右侧边界。又因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，必须减一。


```c
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = leftBound(nums, target);
        int right = rightBound(nums, target);
        // [left, right)
        if(left == right) return {-1, -1};
        return {left, right - 1};
    }
	// 找左边界
    int leftBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) right = mid;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
	//找右边界
    int rightBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) left = mid + 1;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return right;
    }
};
```

这道题和剑指 Offer 53 - I. 在排序数组中查找数字 I几乎是一模一样的，只是返回值不一样。剑指 Offer 53 - I. 在排序数组中查找数字 I：统计一个数字在排序数组中出现的次数。

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```c
输入: nums = [1,3,5,6], target = 5
输出: 2
```

当目标元素 `target` 不存在数组 `nums` 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：

1. 返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引；
2. 返回的这个值是 `target` 应该插入在 `nums` 中的索引位置；
3. 返回的这个值是 `nums` 中小于 `target` 的元素个数；

比如在有序数组 `nums = [2,3,5,7]` 中搜索 `target = 4`，**搜索左边界**的二分算法会返回 2，带入上面的说法，都是对的。

所以以上三种解读都是等价的，可以根据具体题目场景灵活运用，显然这里我们需要的是第二种。

```c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

### 剑指 Offer 53 - II. 0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 ```
输入: [0,1,3]
输出: 2
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
 ```

二分查找，找出第一个不相等于其索引的值。

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == mid){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return left;
    }
};
```

### 540.  有序数组中的单一元素

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次，请你找出并返回只出现一次的那个数。 

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

如果不考虑单一元素的话，成对元素中的第一个所对应的下标必然是偶数，成对元素中的第二个所对应的下标必然是奇数。

再考虑存在单一元素的情况，假如单一元素所在的下标为 x，那么下标 x 之前（左边）的位置仍满足上述结论，而下标 x 之后（右边）的位置由于 x 的插入，导致结论翻转。所以可以根据当前二分点 mid 的奇偶性分情况讨论：

- mid 为偶数下标：根据上述结论，正常情况下偶数下标的值会与下一值相同，因此如果满足该条件，可以确保 mid 之前并没有插入单一元素。正常情况下，此时应该更新 l = mid，否则应当让 r = mid-1；
- mid 为奇数下标：同理，根据上述结论，正常情况下奇数下标的值会与上一值相同，因此如果满足该条件，可以确保 mid 之前并没有插入单一元素，相应的更新 l 和 r。

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if(mid % 2 == 0){
                if(nums[mid] == nums[mid + 1]){
                    left = mid + 1;
                }else{
                    right = mid;
                }
            }else{
                if(nums[mid] == nums[mid - 1]){
                    left = mid + 1;
                }else{
                    right = mid;
                }
            }
        }
        return nums[left];
    }
};
```



## 双指针

### 42. 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202206221405020.png" alt="img" style="zoom:100%;" />

```c
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

创建两个长度为n的数组`leftMax`和`rightMax`。对于0<i<n，`leftMax[i]`表示下标i及其左边的位置中height的最大高度，`rightMax[i]`表示下标i及其右边的位置中height的最大高度，且`leftMax[0] = height[0]`，`rightMax[n - 1] = height[n - 1]`。

当1<i<n-1时，`leftMax[i] = max(leftMax[i - 1], height[i])`；当0<i<n-2时，`rightMar[i] = max(rightMax[i + 1], height[i])`。

因此可以正向遍历数组height得到数组leftMax的每个元素值，反向遍历数组height得到数组rightMax的每个元素值。

在得到数组`leftMax`和`rightMax`的每个元素值之后，对于`0<i<n`,下标i处能接的雨水量等于`min(leftMax[i], rightMax[i]) - height[i]`，遍历每个下标位置即可得到能接的雨水总量。

**动态规划**做法可以由下图体现：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202206221145895.png" alt="image-20220622114545706" style="zoom:80%;" />

```c
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;
        vector<int> leftMax(n), rightMax(n);
        leftMax[0] = height[0];
        rightMax[n - 1] = height[n - 1];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = max(leftMax[i - 1], height[i]);
        }
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = max(rightMax[i + 1], height[i]);
        }
        int res = 0;
        for (int i = 0; i < n; ++i) {
            res += min(leftMax[i], rightMax[i]) - height[i];
        }
        return res;
    }
};
```

优化：双指针

```c
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int res = 0;
        while(left < right){
            leftMax = max(leftMax, height[left]);
            rightMax = max(rightMax, height[right]);
            if(leftMax < rightMax){
                res += leftMax - height[left];
                left++;
            }else{
                res += rightMax - height[right];
                right--;
            }
        }
        return res;
    }
};
```

### 11. 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水，返回容器可以储存的最大水量。说明：你不能倾斜容器。

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202206161627294.jpeg" alt="img" style="zoom:80%;" />

```c
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

这题和 **42. 接雨水** 几乎一模一样，区别在于：接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个坐标是一条竖线，没有宽度。用 `left` 和 `right` 两个指针从两端向中心收缩，一边收缩一边计算 `[left, right]` 之间的矩形面积，取最大的面积值即是答案。

```c
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int left = 0, right = n - 1;
        int s = 0, res = 0;
        while(left < right){
            s = min(height[left], height[right]) * (right - left);
            res = max(res, s);
            if(height[left] < height[right]){
                left++;
            }else{
                right--;
            }
        }
        return res;
    }
};
```

### 26. 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums `，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序 应该保持 一致 。

示例：

```c
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是不重复元素。

```c
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 数组长度为 索引 + 1
        return slow + 1;
    }
};
```

### 27. 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```c
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
```

题目要求我们把 `nums` 中所有值为 `val` 的元素原地删除，依然需要使用快慢指针技巧：如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步。

注意这里和有序数组去重的解法有一个细节差异，我们这里是先给 `nums[slow]` 赋值然后再给 `slow++`，这样可以保证`nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow`。

```c
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

### 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

示例：

```c
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

可以直接复用 [27. 移除元素](https://leetcode.cn/problems/remove-element) 的解法，先移除所有 0，然后把最后的元素都置为 0，就相当于移动 0 的效果。

```c
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 去除nums中的所有0
        int len = remove(nums, 0);
        // 将len之后的所有元素赋值为 0
        while(len < nums.size()){
            nums[len] = 0;
            len++;
        }
    }
	// 定义：在数组nums中移除值为val的元素，返回数组长度
    int remove(vector<int>& nums, int val){
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

### 75. 颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。必须在不使用库的sort函数的情况下解决这个问题。

```c
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

这里使用了三个指针，其中`left`指向0区间的下一个位置，`right`指向2区间的前一个位置，`curr`指向当前处理的位置。遍历整个数组，如果当前元素是0，则将其与`left`指向的元素交换，同时将`left`往后移动一位；如果当前元素是2，则将其与`right`指向的元素交换，同时将`right`往前移动一位；如果当前元素是1，则直接将`curr`往后移动一位。遍历完成后，数组就被分成了三个区间，分别是0、1、2。

```c
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1, curr = 0;
        while (curr <= right) {
            if (nums[curr] == 0) {
                swap(nums[curr], nums[left]);
                left++;
                curr++;
            } else if (nums[curr] == 2) {
                swap(nums[curr], nums[right]);
                right--;
            } else {
                curr++;
            }
        }
    }
};
```

### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 ```c
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
 ```

双指针：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202206261343517.png" alt="image-20220626134322283" style="zoom:80%;" />

```c
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(left < right){
            while(left < right && nums[left] % 2 != 0) left++;
            while(left < right && nums[right] % 2 == 0) right--;
            swap(nums[left], nums[right]);
        }
        return nums;
    }
};
```

### 581. 最短无序连续子数组

给你一个整数数组 `nums` ，你需要找出一个 **连续子数组** ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 **最短** 子数组，并输出它的长度。

```c
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

可以假设把这个数组分成三段，左段和右段是标准的升序数组，中段数组虽是无序的，但满足最小值大于左段的最大值，最大值小于右段的最小值。找中段的左右边界，我们分别定义为 begin 和 end，分两头开始遍历：

![](https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202207031148754.png)

从左到右维护一个最大值max，在进入右段之前，那么遍历到的nums[i]都是小于max的，我们要求的end就是遍历中最后一个小于max元素的位置。同理，从右到左维护一个最小值min，在进入左段之前，那么遍历到的nums[i]也都是大于min的，要求的begin也就是最后一个大于min元素的位置。

```c
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int n = nums.size();
        int min = nums[n - 1];
        int max = nums[0];
        int start = 0, end = -1;
        for(int i = 0; i < n; i++){
            // 从左到右维持最大值，寻找右边界end
            if(nums[i] < max){
                end = i;
            }else{
                max = nums[i];
            }
            // 从右到左维持最小值，寻找左边界start
            if(nums[n - i - 1] > min){
                start = n - i - 1;
            }else{
                min = nums[n - i - 1];
            }            
        }
        return end - start + 1;
    }
};
```

## NSUM 问题

### 167. 两数之和-输入有序数组

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。

```c
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
```

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 `left` 和 `right` 就可以调整 `sum` 的大小：

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                return {left + 1, right + 1}; 
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

### 1. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

```c
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
```

若要求返回数组元素，则可以可将数组排序后使用双指针：

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size() - 1;
        while(left < right){
            int sum = nums[left] + nums[right];
            if(sum == target){
                return {nums[left], nums[right]};
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

若要求返回数组元素的索引，则无法使用上述的双指针，因为排序后数组元素的索引有变动，可使用哈希表：

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for(int i = 0; i < nums.size(); i++){
            auto it = map.find(target - nums[i]);
            if(it != map.end()) return {it->second, i};
            map[nums[i]] = i;
        }
        return {};
    }
};
```

魔改题目：

`nums` 中可能有多对元素之和都等于 `target`，请你的算法返回所有和为 `target` 的元素对，**其中不能出现重复**。

```c
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 记录索引 lo 和 hi 最初对应的值
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            // 跳过所有重复的元素
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```

### 15. 三数之和

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums `中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且**不重复**的三元组。

```c
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

这个问题怎么解决呢？**很简单，穷举呗**。现在我们想找和为 `target` 的三个数字，那么对于第一个数字，可能是什么？`nums` 中的每一个元素 `nums[i]` 都有可能！

那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 `target - nums[i]` 的两个数字呗，那不就是 `twoSum` 函数解决的问题么🤔。

**关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 `twoSum` 函数会保证它们不重复**。所以代码中必须用一个 while 循环来保证 `3Sum` 中第一个元素不重复。

```c
class Solution {
public:

    /* 计算数组 nums 中所有和为 target 的三元组 */
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 数组得排个序
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<vector<int>> res;
        // 穷举 threeSum 的第一个数
        for (int i = 0; i < n; i++) {
            // 对 target - nums[i] 计算 twoSum
            vector<vector<int>> tuples = twoSumTarget(nums, i + 1, - nums[i]);
            // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
            for (vector<int>& tuple : tuples) {
                tuple.push_back(nums[i]);
                res.push_back(tuple);
            }
            // 跳过第一个数字重复的情况，否则会出现重复结果
            while (i < n - 1 && nums[i] == nums[i + 1]) i++;
        }
        return res;
    }
    vector<vector<int>> twoSumTarget(vector<int>& nums, int start, int target) {
        // nums 数组必须有序
        sort(nums.begin(), nums.end());
        int lo = start, hi = nums.size() - 1;
        vector<vector<int>> res;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            // 记录索引 lo 和 hi 最初对应的值
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                // 跳过所有重复的元素
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
        return res;
    }    
};
```

代码优化一下：

再比如 LeetCode 的 `3Sum` 问题，找 `target == 0` 的三元组：

```c
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    // n 为 3，从 nums[0] 开始计算和为 0 的三元组
    return nSumTarget(nums, 3, 0, 0);        
}
```

`nSumTarget`函数实现见下一题。

### 18. 四数之和

给你一个由 `n `个整数组成的数组 `nums `，和一个目标值 `target `。请你找出并返回满足下述全部条件且不重复的四元组` [nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- 0 <= a, b, c, d < n

- a、b、c 和 d 互不相同

- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按任意顺序返回答案 。

```c
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

都到这份上了，`4Sum` 完全就可以用相同的思路：穷举第一个数字，然后调用 `3Sum` 函数计算剩下三个数，最后组合出和为 `target` 的四元组。总结 `nSum` 函数：

```c
/* 注意：调用这个函数之前一定要先给 nums 排序 */
// n为整数个数，start为双指针初始值，target为目标值
vector<vector<int>> nSumTarget(vector<int>& nums, int n, int start, int target) {
    int size = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || size < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = size - 1;
        while (lo < hi) {
            int left = nums[lo], right = nums[hi];
            int sum = left + right;                
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < size; i++) {
            vector<vector<int>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < size - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

实际上就是把之前的题目解法合并起来了，`n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举第一个数字，然后递归调用计算 `(n-1)Sum`，组装答案。

**需要注意的是，调用这个 `nSum` 函数之前一定要先给 `nums` 数组排序**，因为 `nSum` 是一个递归函数，如果在 `nSum` 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

比如说现在我们写 LeetCode 上的 `4Sum` 问题：

```c
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    // n 为 4，从 nums[0] 开始计算和为 target 的四元组
    return nSumTarget(nums, 4, 0, target);
}
```

那么，如果让你计算 `100Sum` 问题，直接调用这个函数就完事儿了。

### 259. 较小的三数之和

给定一个长度为 n 的整数数组和一个目标值 target，寻找能够使条件 `nums[i] + nums[j] + nums[k] < target` 成立的三元组 i, j, k 个数（0 <= i < j < k < n）。

```c
输入: nums = [-2,0,1,3], target = 2
输出: 2
解释: 因为一共有两个三元组满足累加和小于 2:
[-2,0,1]
[-2,0,3]
```

先对数组进行排序，然后固定第一数，对后面的两个数之和使用正常的双指针进行判断：当满足条件`nums[left] + nums[right] < target`时，说明right和left之间的数字都可以和left组合满足要求，则满足要求的组合增加为 `count += (right - left)`，然后将left自增1；若不满足要求，则将right自减 1。

```c
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
		sort(nums.begin(), nums.end());
         int count = 0;
		for(int i = 0; i < nums.size() - 2; i++){
            count += twoSumSmaller(nums, target - nums[i], i + 1);
        }
		return count;
	}
    
    int twoSumSmaller(vector<int>& nums, int target, int start){
        int count = 0;
        int lo = start, hi = nums.size() - 1;
        while(lo < hi){
            int sum = nums[lo] + nums[hi];
            if(sum < target){
                count += hi - lo;
                lo++;
            }else{
                hi--;
            }
        }
        return count;
    }
};
```

### 16. 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和，假定每组输入只存在恰好一个解。

```c
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

一样是先排序，然后固定第一个数，再去 `nums[start..]` 中寻找最接近 `target - delta` 的两数之和。

```c
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        // 记录三数之和与目标值的偏差
        int delta = INT_MAX;
        for(int i = 0; i < nums.size() - 2; i++){
            // 固定 nums[i] 为三数之和中的第一个数，
            // 然后对 nums[i+1..] 搜索接近 target - nums[i] 的两数之和
            int sum = nums[i] + twoSumClosest(nums, target - nums[i], i + 1);
            if(abs(delta) > abs(target - sum)){
                delta = target - sum;
            }
        }
        return target - delta;
    }

    // 在 nums[start..] 搜索最接近 target 的两数之和
    int twoSumClosest(vector<int>& nums, int target, int start){
        int lo = start, hi = nums.size() - 1;
        // 记录两数之和与目标值的偏差
        int delta = INT_MAX;
        while(lo < hi){
            int sum = nums[lo] + nums[hi];
            if(abs(delta) > abs(target - sum)){
                delta = target - sum;
            }
            if(sum < target){
                lo++;
            }else{
                hi--;
            }
        }
        return target - delta;
    }
};
```

## 滑动窗口

### 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: s = "abcabcbb"
输出: 3 
```

这就是变简单了，连 `need` 和 `valid` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 `window` 即可。当 `window[c]` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 `left` 缩小窗口了。

唯一需要注意的是，在哪里更新结果 `res` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 `res`，因为窗口收缩的 `while `条件是存在重复元素的，换句话说收缩完成后一定保证窗口中没有重复。

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;
        int left = 0, right = 0, res = 0;
        while(right < s.size()){
            char c = s[right];
            right++;
            window[c]++;
            while(window[c] > 1){
                char d = s[left];
                left++;
                window[d]--;
            }
            res = max(res, right - left);
        }
        return res;
    }
};
```

### 209. 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` ，找出该数组中满足其和` ≥ target` 的长度最小的 连续子数组` [numsl, numsl+1, ..., numsr-1, numsr] `，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```c
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
```

不过需要强调的是，**题目说了 `nums` 数组中的元素都是正数，有了这个前提才能使用滑动窗口算法**，因为窗口扩大时窗口内元素之和必然增大，窗口缩小时窗口内元素之和必然减小。

如果 `nums` 数组中包含负数，则窗口扩大时元素和不见得就增大，窗口缩小时元素和不见得就减小，这种情况就不能单纯使用滑动窗口技巧了，可能需要混合动态规划和单调队列来做。

```c
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0, sum = 0, res = INT_MAX;
        while(right < nums.size()){
            sum += nums[right];
            right++;
            while(sum >= target && left < right){
                res = min(res, right - left);
                sum -= nums[left];
                left++;
            }
        }
        return res == INT_MAX ? 0 : res;

    }
};
```

### 76. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t `，返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串`""` 。

```c
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

滑动窗口的思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「**滑动窗口**」这个名字的来历。

初始状态：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205201152976.png" alt="image-20220520115217917" style="zoom:80%;" />

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205201153833.png" alt="image-20220520115349776" style="zoom:80%;" />

现在开始增加 `left`，缩小窗口 `[left, right)`：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205201154016.png" alt="image-20220520115450943" style="zoom:80%;" />

直到窗口中的字符串不再符合要求，`left` 不再继续移动：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205201155927.png" alt="image-20220520115526871" style="zoom:80%;" />

之后重复上述过程，先移动 `right`，再移动 `left`…… 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

首先，初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```c
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left` 和 `right` 变量初始化窗口的两端，不要忘了，区间 `[left, right)` 是**左闭右开**的，所以初始情况下窗口没有包含任何元素：

```c
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

**其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数**，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

```c
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t){
        need[c]++;
    }
    int left = 0, right = 0, valid = 0; // valid表示窗口中满足 need 条件的字符个数
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d]) valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

需要注意的是，当我们发现某个字符在 `window` 的数量满足了 `need` 的需要，就要更新 `valid`，表示有一个字符已经满足要求，而且两次对窗口内数据的更新操作是完全对称的。

当 `valid == need.size()` 时，说明 `T` 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 `left` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

### 567. 字符串的排列

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true `；否则，返回 `false `。

```c
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```

注意哦，输入的 `s1` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：

1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

```c
class Solution {
public:
    // 判断 s2 中是否存在 s1 的排列
    bool checkInclusion(string s1, string s2) {
        unordered_map<char, int> need, window;
        for(char c : s1){
            need[c]++;
        }
        int left = 0, right = 0, valid = 0;
        while(right < s2.size()){
            char c = s2[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(valid == need.size()){
                // 判断是否找到了合法的子串
                if(right - left == s1.size()) return true;
                char d = s2[left];
                left++;
                if(need.count(d)){
                    if(window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }
};
```

### 438. 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p`的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```c
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
```

所谓的**字母异位词**就是**排列**，相当于输入一个串 `S`，一个串 `T`，找到 `S` 中所有 `T` 的排列，返回它们的起始索引。跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 `res` 即可。

```c
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char, int> need, window;
        for(char c : p) need[c]++;
        int left = 0, right = 0, valid = 0;
        vector<int> res;
        while(right < s.size()){
            char c = s[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(valid == need.size()){
                // 当窗口符合条件时，把起始索引加入 res
                if(right - left == p.size()) res.push_back(left);
                char d = s[left];
                left++;
                if(need.count(d)){
                    if(need[d] == window[d]) valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

### 剑指 Offer 57 - II. 和为s的连续正数序列

输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```
输入：target = 9
输出：[[2,3,4],[4,5]]
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

双指针，滑动窗口。

```cpp
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int left = 1, right = 1, sum = 0;
        vector<vector<int>> res;
        deque<int> add;
        while(left <= target / 2){
            sum += right;
            add.push_back(right);
            right++;
            while(sum >= target){
                if(sum == target){
                    res.push_back(vector<int>(add.begin(), add.end()));
                }
                sum -= left;
                add.pop_front();
                left++;
            }
            
        }
        return res;      
    }
};
```

## 数组遍历/旋转

### [BM97 旋转数组](https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=295&sfm=html&channel=nowcoder)

一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M >=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

```
输入：6,2,[1,2,3,4,5,6]
输出：[5,6,1,2,3,4]
```

使用三次翻转，思路：

- step 1：因为m可能大于n，因此需要对n取余，因为每次长度为n的旋转数组相当于没有变化；
- step 2：第一次将整个数组翻转，得到数组的逆序，它已经满足了右移的整体出现在了左边；
- step 3：第二次就将左边的m个元素单独翻转，因为它虽然移到了左边，但是逆序了；
- step 4：第三次就将右边的n−m个元素单独翻转，因此这部分也逆序了；

```c
class Solution {
public:
    vector<int> solve(int n, int m, vector<int>& a) {
        //取余，因为每次长度为n的旋转数组相当于没有变化
        m = m % n; 
        //第一次逆转全部数组元素
        reverse(a.begin(), a.end()); 
        //第二次只逆转开头m个
        reverse(a.begin(), a.begin() + m); 
        //第三次只逆转结尾m个
        reverse(a.begin() + m, a.end()); 
        return a;
    }
};
```

### 48. 旋转图像

给定一个 `n × n` 的二维矩阵 matrix 表示一个图像。请你将图像**顺时针**旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205211142216.jpeg" alt="img" style="zoom:50%;" />

```c
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。

我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205211151127.png" alt="image-20220521115152062" style="zoom:80%;" />

然后再对矩阵的每一行进行反转：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205211153864.png" alt="image-20220521115345798" style="zoom:80%;" />

发现结果就是 `matrix` 顺时针旋转 90 度的结果：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205211155575.png" alt="image-20220521115523512" style="zoom:80%;" />

```c
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```


**那如何将矩阵逆时针旋转 90 度呢**？

思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果：

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202205211156783.png" alt="image-20220521115657715" style="zoom:80%;" />

```c
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n - i; j++){
                swap(matrix[i][j], matrix[n - j - 1][n - i - 1]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

### 54. 螺旋矩阵

给你一个 `m `行 `n` 列的矩阵 matrix ，请按照 **顺时针**螺旋顺序 ，返回矩阵中的所有元素。

<img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" />

```c
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界。

<img src="https://s1.ax1x.com/2022/05/21/OjGnXt.png" style="zoom:40%;" />

随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：

<img src="https://s1.ax1x.com/2022/05/21/OjJ1Dx.png" style="zoom:40%;" />

```c
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int upper = 0, lower = m - 1, left = 0, right = n - 1;
        vector<int> res;
        // res.size() == m * n 则遍历完整个数组
        while(res.size() < m * n){
            // 在顶部从左向右遍历
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res.push_back(matrix[upper][j]);
                }
                // 上边界下移
                upper++;
            }
            if(left <= right){
                // 在右侧从上向下遍历
                for(int i = upper; i <= lower; i++){
                    res.push_back(matrix[i][right]);
                }
                // 右边界左移
                right--;
            }
            if(upper <= lower){
                // 在底部从右向左遍历
                for(int j = right; j >= left; j--){
                    res.push_back(matrix[lower][j]);
                }
                // 下边界上移
                lower--;
            }
            if(left <= right){
                // 在左侧从下向上遍历
                for(int i = lower; i >= upper; i--){
                    res.push_back(matrix[i][left]);
                }
                // 左边界右移
                left++;
            }
        }
        return res;
    }
};
```

### 59. 螺旋矩阵II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

<img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" />

```c
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

和上一道题类似的思路：

```c
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int upper = 0, lower = n - 1, left = 0, right = n - 1;
        int num = 1;
        while(num <= n * n){
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res[upper][j] = num++;
                }
                upper++;
            }
            if(left <= right){
                for(int i = upper; i <= lower; i++){
                    res[i][right] = num++;
                }
                right--;
            }
            if(upper <= lower){
                for(int j = right; j >= left; j--){
                    res[lower][j] = num++;
                }
                lower--;
            }
            if(left <= right){
                for(int i = lower; i >= upper; i--){
                    res[i][left] = num++;
                }
                left++;
            }
        }
        return res;
    }
};
```

### 498 对角线遍历

给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

![diag1-grid.jpg (334×334)](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

从左上角开始，先向右上方遍历一段距离，再向右下方遍历一段距离，然后交替上述两个方向进行遍历，直到遍历完所有元素为止。

具体实现时，我们可以使用一个变量flag来标记当前遍历的方向，其中flag=1表示向右上方遍历，flag=-1表示向左下方遍历。然后，我们可以使用两个变量i和j来记录当前遍历到的位置，初始时i=0，j=0。在遍历过程中，我们需要不断更新i和j的值，同时将经过的元素加入结果数组中。

在遍历过程中，我们先将当前遍历到的元素加入结果数组res中，然后根据当前遍历的方向，更新i和j的值。具体地，如果flag=1，表示当前是向右上方遍历，我们需要判断当前位置是否在矩阵的边缘，如果是，则需要转向；否则，我们需要继续向右上方遍历。如果flag=-1，表示当前是向左下方遍历，我们同样需要根据当前位置是否在矩阵的边缘来判断是否需要转向，如果不需要，则继续向右下方遍历。

```cpp
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        vector<int> res;
        int i = 0, j = 0, flag = 1;
        while (res.size() < m * n) {
            res.push_back(mat[i][j]);
            if (flag == 1) { // 右上角遍历
                if (j == n - 1) {
                    i++;
                    flag = -1;
                } else if (i == 0) {
                    j++;
                    flag = -1;
                } else {
                    i--;
                    j++;
                }
            } else { // 左下角遍历
                if (i == m - 1) {
                    j++;
                    flag = 1;
                } else if (j == 0) {
                    i++;
                    flag = 1;
                } else {
                    i++;
                    j--;
                }
            }
        }
        return res;
    }
};
```

## 杨辉三角

### 118. 杨辉三角

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行，在「杨辉三角」中，每个数是它左上方和右上方的数的和。

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202207031413836.png" alt="image-20220703141313905" style="zoom:60%;" />

```c
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

```c
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res(numRows);
        for (int i = 0; i < numRows; ++i) {
            res[i].resize(i + 1);
            res[i][0] = res[i][i] = 1;
            for (int j = 1; j < i; ++j) {
                res[i][j] = res[i - 1][j] + res[i - 1][j - 1];
            }
        }
        return res;
    }
};
```

### 119. 杨辉三角 II

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。

```c
输入: rowIndex = 3
输出: [1,3,3,1]
```

由于只要输出指定的某一行，故只需保存当前行的前一行结果即可。

```c
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        if(rowIndex == 0) return {1};
        if(rowIndex == 1) return {1, 1};
        vector<int> res(2, 1);
        for(int i = 2; i <= rowIndex; i++){
            vector<int> tmp(i + 1, 1);
            for(int j = 1; j < i; j++){
                tmp[j] = res[j - 1] + res[j];
            }
            swap(res, tmp);
        }
        return res;
    }
};
```

## 索引对应元素

### 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

 ```
输入：nums = [1,3,4,2,2]
输出：2
输入：nums = [3,1,3,4,2]
输出：3
 ```

由于数组中的元素都是正数，且都在1到n 的范围内，故可以使用数组的下标作为辅助。

将和数组元素值相同的数组下标中对应的值置为其对应的负数，这样，当两个相同的元素映射到同一个位置，会发现元素值已经为负数了，既该值为重复的值。由于有映射负数的步骤，故使用数组元素时，需要使用其绝对值。

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        for(int num : nums){
            if(nums[abs(num)] < 0){
                return abs(num);
            }
            nums[abs(num)] *= -1;
        }
        return 0;
    }
};
```

### 442. 数组中重复的数据

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。

 ```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
 ```

和上一题一样的思路，但是需要注意索引的取值范围。

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for(int num : nums){
            if(nums[abs(num) - 1] < 0){
                res.push_back(abs(num));
            }
            nums[abs(num) - 1] *= -1;
        }
        return res;
    }
};
```

### 448. 找到所有数组中消失的数字

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

 ```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
 ```

`nums` 中的元素取值都在 `[1, n]` 之间，即元素本身就和索引成一一映射关系，所以可以用 `nums` 本身模拟哈希集合的效果。那么最终缺失的那些元素对应的索引就不会被标记，我们也就可以把缺失的那些元素找出来。

注意：用乘 -1 的方式给索引做标记的前提是，`nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for(int num : nums){
            // 注意索引，元素大小从 1 开始，有一位索引偏移
            if(nums[abs(num) - 1] < 0) continue; // 索引重复出现
            nums[abs(num) - 1] *= -1; // 把索引 num - 1 置为负数
        }
        vector<int> res;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > 0){
                // 说明没有元素和这个索引对应，即找到一个缺失元素
                res.push_back(i + 1);
            }
        }
        return res;
    }
};
```

### 41  缺失的第一个正数

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

```
输入：nums = [1,2,0]
输出：3
输入：nums = [3,4,-1,1]
输出：2
```

1. 使用数组本身的索引作为标识，这样把正数分成了两组，一组是数组的索引，另一组是索引之外的正数；
2. 将数组元素中，其值可以映射到数组索引的元素，映射到对应的数组索引位置；
3. 然后遍历数组元素，找到第一个元素值和其索引值不一致的值即为缺失的第一个正数，若没有在数组内找到，则第一个缺失的整数就成了数组大小对应的值；
4. 为了避免可能出现的在交换数组元素时，造成的死循环，则需要加上判断条件`nums[nums[i]-1]!=nums[i]`；

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        // 将数组内的可能映射到数组对应索引位置的元素，交换到对应的位置
        for(int i = 0; i < n; i++){
            // 前两个判断是为了保证元素是可以映射到对应的索引位置
            // 后面的判断条件是为了避免死循环
            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
            }
        }
        for(int i = 0; i < n; i++){
            if(nums[i] != i + 1){
                return i + 1;
            }
        }
        return n + 1;
    }
};
```

## 其他

### 870. 优势洗牌（田忌赛马）

给定两个大小相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums2` 的优势可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。返回 `nums1` 的**任意**排列，使其相对于 `nums2` 的优势最大化。 

```
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
```

田忌赛马算法实现。比得过最弱的，则正常放置；比不过，则用来消耗最强的。

```cpp
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        vector<int> res(n);
        vector<int> index(n);
        // 给数组递增赋值
        for(int i = 0; i < n; i++){
            index[i] = i;
        }
        sort(nums1.begin(), nums1.end());
        // 按照nums2的顺序给index排序
        sort(index.begin(), index.end(), [&](int i, int j){
            return nums2[i] < nums2[j];
        });
        int left = 0, right = n - 1;
        for(int num : nums1){
            if(num > nums2[index[left]]){
                // 比得过最小的，则正常放置
                res[index[left]] = num;
                left++;
            }else{
                // 比不过最小的，则用来消耗最强的
                res[index[right]] = num;
                right--;
            }
        }
        return res;
    }
};
```

### 334. 递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

 ```
输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意
输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
 ```

把所有的数分成了三部分，一部分小于等于 first，中间部分小于等于 second，以及最后的一部分大于second。只要出现了第三部分，就满足条件，返回true；否则，跳出循环后，返回false。

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX;
        int second = INT_MAX;
        for(int& num : nums){
            //不停的将后面的数据分成三部分
            if(num <= first){
                //先更新first
                first = num;
            }else if(num <= second){
                //然后才能更新second
                second = num;
            }else if(num > second){
                //则出现大于second的数据时，直接返回true
                return true;
            }
        }
        return false;
    }
};
```

### 179. 最大数

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

```c
输入：nums = [10,2]
输出："210"
```

此题求拼接起来的最小数字，本质上是一个排序问题。设数组nums中任意两数字的字符串为x和y，则规定排序判断规则为：若拼接字符串`x + y > y + x`，则x“大于”y；反之，若`x + y < y + x`，则x"小于”y。x“小于”y代表：排序完成后，数组中x应在y左边；“大于”则反之。根据以上规则，套用任何排序方法对nums执行排序即可。

```c
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> strs;
        string res;
        for(int num : nums){
            strs.push_back(to_string(num));
        }
        sort(strs.begin(), strs.end(), [&](string a, string b){
            return a + b > b + a;
        });
        for(string str : strs){
            res += str;
        }
        //避免全部为0的情形
        return res[0] == '0' ? "0" : res;
    }
};
```

### 剑指 Offer 66. 构建乘积数组

给定一个数组 `A[0,1,…,n-1]`，请构建一个数组 `B[0,1,…,n-1]`，其中 `B[i]` 的值是数组 `A` 中除了下标 `i` 以外的元素的积，即`B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]`。不能使用除法。

```c
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

分别迭代计算下三角和上三角两部分的乘积，再相乘，即可 **不使用除法** 就获得结果。

<img src="https://gcore.jsdelivr.net/gh/gp868/myFigures/img/202206281627227.png" alt="image-20220628162754163" style="zoom:80%;" />

```c
class Solution{
public:
    vector<int> constructArr(vector<int> &a){
        vector<int> res(a.size(), 1);
        int left = 1;	// 左侧乘积
        int right = 1;	// 右侧乘积
        for (int i = 0; i < a.size(); ++i){
            //左侧的乘积
            res[i] *= left; 
            left *= a[i];
            //右侧的乘积
            res[a.size() - 1 - i] *= right; 
            right *= a[a.size() - 1 - i];
        }
        return res;
    }
};
```

### 66. 加一

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

```c
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

其实就是一个数的各位储存在数组里，然后要按照整数加法的法则来计算，然后同样返回一个数组：

```c
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int len = digits.size();
        for(int i = len - 1; i >= 0; i --){
            digits[i] ++;
            digits[i] %= 10;
            if(digits[i] != 0){
                return digits;
            }
        }
        digits.resize(n + 1);
        digits[0] = 1;
        return digits;
    }
};
```

### 88 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。

将双指针初始化在数组的尾部，然后从后向前进行合并。

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1;
        int p = nums1.size() - 1;
        while(i >= 0 && j >= 0){
            if(nums1[i] > nums2[j]){
                nums1[p] = nums1[i];
                i--;
            }else{
                nums1[p] = nums2[j];
                j--;
            }
            p--;
        }
        // 剩余元素
        while(j >= 0){
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
};
```







