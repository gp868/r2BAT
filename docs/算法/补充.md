## 位运算

### 剑指 Offer 56 - I. 数组中数字出现的次数

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

```php
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

相同的数异或为0，不同的异或为1，0和任何数异或等于这个数本身。所以，数组里面所有数异或 = 目标两个数异或 。由于这两个数不同，所以异或结果必然不为0。假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的，那么**可以根据数组里面所有数的第二位为0或者1将数组划分为2个**。这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。这两个数组里面的数各自进行异或，得到的结果就是答案。

```php
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int x = 0, y = 0, n = 0, m = 1;
        for(int num : nums)         // 1. 遍历异或
            n ^= num;
        while((n & m) == 0)         // 2. 循环左移，计算 m
            m <<= 1;
        for(int num : nums) {       // 3. 遍历 nums 分组
            if(num & m) x ^= num;   // 4. 当 num & m == 0
            else y ^= num;          // 4. 当 num & m != 0
        }
        return vector<int> {x, y};  // 5. 返回出现一次的数字
    }
};
```

>&(按位与)、|(按位或)、^(按位异或)、~ (按位取反)：
>
>1. 按位与运算符(&)：0 & 0 = 0, 0 & 1 = 0, 1 & 0 = 0, 1 & 1 = 1，有0则0，无0则1；
>2. 按位或运算符(|)：0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1，有1则1，无1则0；
>3. 按位异或运算符(^)：0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0，消消乐；

## 数组





## 回溯算法





## 动态规划









## 其他

### 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。

```php
输入：x = 123
输出：321
```

```php
class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            if (rev < INT_MIN / 10 || rev > INT_MAX / 10) {
                return 0;
            }
            int digit = x % 10;
            x /= 10;
            rev = rev * 10 + digit;
        }
        return rev;
    }
};
```

### 146. LRU 缓存

请你设计并实现一个满足  **LRU (最近最少使用) **缓存约束的数据结构。实现 LRUCache 类：

- LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存

- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。

- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

```php
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]
解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

哈希表 + 双向链表：

[<img src="https://s1.ax1x.com/2022/07/01/jMq0i9.md.png" alt="jMq0i9.md.png" style="zoom:80%;" />](https://imgtu.com/i/jMq0i9)

```php
struct Node{
    int key, val;
    Node *prev;
    Node *next;
    Node() : key(0), val(0), prev(nullptr), next(nullptr){};
    Node(int _key, int _val) : key(_key), val(_val), prev(nullptr), next(nullptr){};
};

class LRUCache{
private:
    unordered_map<int, Node*> cache;
    Node *head;
    Node *tail;
    //大小
    int size;
    //容量
    int capacity;

public:
    LRUCache(int _capacity) : capacity(_capacity), size(0){
        // 使用伪头部和伪尾部节点
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }

    int get(int key){
        if (!cache.count(key)){
            return -1;
        }
        Node *node = cache[key];
        moveToHead(node);
        return node->val;
    }

    void put(int key, int val){
        if (!cache.count(key)){
            // 如果 key 不存在，创建一个新的节点
            Node *node = new Node(key, val);
            // 添加到哈希表
            cache[key] = node;
            // 添加到双向链表的头部
            addToHead(node);
            size++;
            if (size > capacity){
                // 超过容量，删除双向链表的尾部节点
                Node *removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                size--;
            }
        }else{
            // 如果 key 存在，先通过哈希表定位，再修改 val，并移到头部
            Node *node = cache[key];
            node->val = val;
            moveToHead(node);
        }
    }

    void addToHead(Node *node){
        node->prev = head;
        head->next->prev = node;
        node->next = head->next;
        head->next = node;
    }

    void removeNode(Node *node){
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(Node *node){
        removeNode(node);
        addToHead(node);
    }

    Node* removeTail(){
        Node *node = tail->prev;
        removeNode(node);
        return node;
    }
};
```



### 172. 阶乘后的零

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，也就是说，问题转化为：`n!` 最多可以分解出多少个因子 2 和 5？这主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。

逐个的将 n 中可分离的5的个数求出，即为阶乘中尾数中0的个数。

```php
class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        for(int i = n; i / 5 > 0; i /= 5){
            count += i / 5;
        }
        return count;
    }
};
```

### （理解不了）793. 阶乘函数后 K 个零

`f(x)` 是 `x!` 末尾是 0 的数量，给定 `k`，找出返回能满足 `f(x) = k` 的非负整数 `x` 的数量。

```php
输入：k = 0
输出：5
解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。
```



```php
class Solution {
public:
    int preimageSizeFZF(int k) {
        int num = 0, count = 0, temp;
        for(num = 1; count < k; num++){
            temp = num;
            count++;
            while(temp % 5 == 0){
                count++;
                temp /= 5;
            }
        }
        if(count == k) return 5;
        else return 0;
    }
};
```

### 187. 重复的DNA序列

**DNA序列** 由一系列核苷酸组成，缩写为 `'A'`, `'C'`, `'G'` 和 `'T'`.。例如，`"ACGAATTCCG"` 是一个 **DNA序列** 。在研究 **DNA** 时，识别 DNA 中的重复序列非常有用。

给定一个表示 **DNA序列** 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 **长度为 `10`** 的序列(子字符串)。你可以按 **任意顺序** 返回答案。

```php
输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]
解释：子串 "AAAAACCCCC" 和 "CCCCCAAAAA" 都重复出现了两次。
```

哈希表：

```php
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> ans;
        unordered_map<string, int> cnt;
        int n = s.length();
        for (int i = 0; i <= n - 10; ++i) {
            string sub = s.substr(i, 10);
            if (++cnt[sub] == 2) {
                ans.push_back(sub);
            }
        }
        return ans;
    }
};
```

滑动窗口：

你把 `AGCT` 四种字符等价为 `0123` 四个数字，那么长度为 `L = 10` 的一个碱基序列其实就可以等价为一个十位数，这个数字可以唯一标识一个子串。**而且窗口移动的过程，其实就是给这个数字的最低位添加数字，并删除最高位数字的过程**，可以在 `O(1)` 的时间完成。

不在哈希集合中直接存储子串了，而是存储子串对应的十位数。因为一个十位数可以唯一标识一个子串，所以也可以起到识别重复的作用。这样就避免了直接生成子串存入集合，而是生成一个十位数来表示子串，而且生成这个十位数的时间花费为 `O(1)`，从而降低了匹配算法的时间复杂度。

```php
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        // 先把字符串转化成四进制的数字数组
        int n = s.size();
        vector<int> nums(n);
        for(int i = 0; i < n; i++){
            switch(s[i]){
                case 'A':
                    nums[i] = 0;
                    break;
                case 'G':
                    nums[i] = 1;
                    break;
                case 'C':
                    nums[i] = 2;
                    break;
                case 'T':
                    nums[i] = 3;
                    break;
            }
        }
        
        // 记录重复出现的哈希值
        unordered_set<int> set;
        // 记录重复出现的字符串结果
        unordered_set<string> res;
        // 数字位数
        int L = 10;
        // 进制
        int R = 4;
        // 存储 R^(L - 1) 的结果
        int RL = (int) pow(R, L - 1);
        // 维护滑动窗口中字符串的哈希值
        int windowHash = 0;

        // 滑动窗口代码框架，时间 O(N)
        int left = 0, right = 0;
        while(right < n){
            windowHash = R * windowHash + nums[right];
            right++;
            if(right - left == L){
                if(set.count(windowHash)){
                    res.insert(s.substr(left, right - left));
                }else{
                    set.insert(windowHash);
                }
                windowHash = windowHash - nums[left] * RL;
                left++;
            }
        }
        return vector<string>(res.begin(), res.end());
    }
};
```

### 28. 实现 strStr()

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 `-1` 。

**说明：**当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

```php
输入：haystack = "hello", needle = "ll"
输出：2
```

暴力匹配：

```cpp
class Solution
{
public:
    int strStr(string haystack, string needle)
    {
        //处理特殊的情形
        if (needle.empty())
            return 0;
        if (needle.size() > haystack.size())
            return -1;
        //字符串中找第一个相同字符的终点位置
        int end_pos = haystack.size() - needle.size() + 1;
        for (int i = 0; i < end_pos; ++i)
        { //遍历字符
            if (haystack[i] == needle[0])
            { //若找到第一个相同的字符
                int j = 0;
                //则在此基础上判断后面的字符串是否相同
                while (j < needle.size() && haystack[i + j] == needle[j]) {
                    ++j;
                }
                //若到了needle的末尾，则说明到了终点
                if (j == needle.size()) 
                    return i;
            }
        }
        //跳出循环，则说明没有找到，返回-1
        return -1;
    }
};

```

滑动窗口：

ASCII 码其实就是 0~255 这 256 个数字，分别对应所有英文字符和英文符号。那么一个长度为 `L` 的 ASCII 字符串，我们就可以等价理解成一个 `L` 位的 256 进制的数字，这个数字就可以唯一标识这个字符串，也就可以作为哈希值。

但是进制太大了容易造成整形溢出，那就需要使用**取模**来把一个很大的数字映射到一个较小的范围内。无论一个数字多大，你让它除以 `Q`，余数一定会落在 `[0, Q-1]` 的范围内。对于一个字符串，我们不需要把完整的 256 进制数字存下来，而是对这个巨大的 256 进制数求 `Q` 的余数，然后把这个余数作为该字符串的哈希值即可。

但是有可能会发生哈希冲突，可用拉链法和线性探查法来解决。对于 Rabin-Karp 算法来说，当发现 `windowHash == patHash` 时，使用暴力匹配算法检查一下窗口中的字符串和 `pat` 是否相同就可以避免哈希冲突了。因为希冲突出现的概率比较小，所以偶尔用一下暴力匹配算法是不影响总体的时间复杂度的。

Rabin-Karp 算法的时间复杂度是 `O(N + L)`，`N` 为文本串 `txt` 的长度，`L` 为模式串 `pat` 的长度。当然，每次出现哈希冲突时会使用 `O(L)` 的时间进行暴力匹配，但考虑到只要 `Q` 设置的合理，哈希冲突的出现概率会很小，所以可以忽略不计。

Q选取要尽可能大，而且要选取为素数，可以降低哈希冲突的概率。

```php
class Solution {
public:
    int strStr(string haystack, string needle) {
        // 位数
        int L = needle.size();
        // 进制
        int R = 256;
        // 取一个比较大的素数作为求模的除数
        long Q = 1658598167;
        // R^(L - 1) 的结果
        long RL = 1;
        for(int i = 1; i < L - 1; i++){
            RL = (RL * R) % Q;
        }
        
        // 计算模式串的哈希值，时间 O(L)
        long needleHash = 0;
        for(int i = 0; i < L; i++){
            needleHash = (R * needleHash + needle[i]) % Q;
        }

        // 滑动窗口中子字符串的哈希值
        long windowHash = 0;
        
        int left = 0, right = 0;
        while(right < haystack.size()){
            windowHash = ((R * windowHash) % Q + haystack[right]) % Q;
            right++;
            // 当子串的长度达到要求
            if(right - left == L){
                if(needleHash == windowHash){
                    // 当前窗口中的子串哈希值等于模式串的哈希值
                    // 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突
                    if(needle.compare(haystack.substr(left, right))){
                        return left;
                    }
                }
                // 缩小窗口，移出字符
                windowHash = (windowHash - (haystack[left] * RL) % Q + Q) % Q;
                // X % Q == (X + Q) % Q 是一个模运算法则
                // 因为 windowHash - (txt[left] * RL) % Q 可能是负数
                // 所以额外再加一个 Q，保证 windowHash 不会是负数
                left++;
            }
        }
        // 没有找到模式串
        return -1;
    }
};
```



### 217. 存在重复元素

给你一个整数数组 `nums` 。如果任一值在数组中出现**至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。

```php
输入：nums = [1,2,3,1]
输出：true
输入：nums = [1,2,3,4]
输出：false
```

哈希表：

```php
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> set;
        for(int num : nums){
            if(set.count(num)){
                return true;
            }
            set.insert(num);
        }
        return false;
    }
};
```

### 219. 存在重复元素 II

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

```php
输入：nums = [1,2,3,1], k = 3
输出：true
输入：nums = [1,0,1,1], k = 1
输出：true
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```

哈希表：

```php
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            if (map.count(num) && i - map[num] <= k) {
                return true;
            }
            map[num] = i;
        }
        return false;
    }
};
```

滑动窗口：

```php
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n = nums.size();
        if(n < 2) return false;
        int left = 0, right = 0;
        unordered_map<int, int> window;
        while(right < n){
            int a = nums[right];
            window[a]++;
            right++;
            while(right - left > k){
                int b = nums[left];
                left++;
                if(right - left == k){
                    if(window[a] > 1){
                        return true;
                    }
                }
                window[b]--;
            }
            // 达不到k的时候个数大于1返回true
            if(window[a] > 1){
                return true;
            }
        }
        return false;
    }
};
```

### （不太会）220. 存在重复元素 III

给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。如果存在则返回 `true`，不存在返回 `false`。

```php
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
```











### 258. 各位相加

给定一个非负整数 `num`，反复将各个位上的数字相加，直到结果为一位数，返回这个结果。

```php
输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
```

```cpp
class Solution {
public:
    int addDigits(int num) {
        int sum = 0;
        while(1){
            // 求取当前数字的各个位之和
            while(num){
                sum += num % 10;
                num /= 10;
            }
            if(sum < 10){
                // 判断当前和是否满足要求，若是满足，则直接返回
                return sum;
            }else{
                // 否则更新数据，重新判断
                num = sum;
                sum = 0;
            }
        }
        return 0;
    }
};
```



### 326. 3 的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x。

```
输入：n = 27
输出：true
输入：n = 0
输出：false
```

使用循环对3进行分解。

```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n == 0) return false;
        while(true){
            if(n == 1){
                return true;
            }
            if(n % 3){
                return false;
            }
            n /= 3;  
        }
        return true;
    }
};
```



### 334. 递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

 ```
 输入：nums = [1,2,3,4,5]
 输出：true
 解释：任何 i < j < k 的三元组都满足题意
 输入：nums = [5,4,3,2,1]
 输出：false
 解释：不存在满足题意的三元组
 ```

直观的想，就是把后面出现的所有的数分成了三部分，一部分是小于等于 first,中间部分是 小于等于 second，以及最后的一部分是大于second，只要出现了第三部分，就是满足条件，返回true；否则，跳出循环后，返回false。

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX;
        int second = INT_MAX;
        for(int& num : nums){
            //不停的将后面的数据分成三部分
            if(num <= first){
                //先更新first
                first = num;
            }else if(num <= second){
                //然后才能更新second
                second = num;
            }else if(num > second){
                //则出现大于second的数据时，直接返回true
                return true;
            }
        }
        return false;
    }
};
```



### 338. 比特位计数

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

 ```
 输入：n = 2
 输出：[0,1,1]
 解释：
 0 --> 0
 1 --> 1
 2 --> 10
 ```

数字分奇数和偶数：

- 偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明`dp[i] = dp[i / 2]`；

- 奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明dp[i] = dp[i-1] + 1，当然也可以写成`dp[i] = dp[i / 2] + 1`；

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> d(n + 1, 0);
        for(int i = 0; i <= n; i++){
            if(i % 2 == 0){
                d[i] = d[i / 2];
            }else{
                d[i] = d[i / 2] + 1;
            }
        }
        return d;
    }
};
```



### 371. 两整数之和

给你两个整数 a 和 b ，不使用 运算符 + 和 - ，计算并返回两整数之和。

```cpp
输入：a = 1, b = 2
输出：3
```

位操作，主要思路：

1. 使用异或操作，获得a，b之间的不能进位的位置的数字和；
2. 使用与操作，获得a，b之间的能进位的位置上的1的表示，然后将其左移一位，作为进位值；
3. 然后在循环中，再重复上述操作，直到b为0为止；

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while(b){//终止条件为 b 为0，既两数相加时，其二进制表示上，没有进位
            int tmp = a ^ b;//获得两数之和的非进位的两个数的各个位上的表示
            b = (unsigned int)(a & b) << 1;//获得两数之和的进位上的位置表示，然后将其左移一位，相当于进位
            a = tmp;//保存tmp，循环计算
        }
        return a;
    }
};
```



### 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
输入：s = "3[a2[c]]"
输出："accaccacc"
```

使用**栈**来解压中括号中的内容：

1. 一个栈用于存储字符串，一个栈用于存储数字；
2. 根据遇到的中括号的左括号或右括号，执行不同的操作；
3. 遇到左括号，就把当前解析出来的内容压入到对应的两个栈中；
4. 遇到右括号，就把之前的字符串和数字拿出来进行解压，既去除当前左括号对应的字符串的压缩；

```cpp
class Solution
{
public:
    string decodeString(string s){
        stack<string> strs;
        stack<int> nums;
        int num = 0;
        string str;
        for (char &ch : s){
            //解析数字
            if (ch >= '0' && ch <= '9'){
                num = num * 10 + ch - '0';
            }
            //解析字符串
            else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')){
                str += ch;
            }
            //说明是新的一层
            else if (ch == '['){
                strs.push(str);
                str = "";
                nums.push(num);
                num = 0;
            }
            //可以将当前层解压出来
            else if (ch == ']'){
                int times = nums.top();
                nums.pop();
                for (int i = 0; i < times; ++i){
                    strs.top() += str;
                }
                str = strs.top();
                strs.pop();
            }
        }
        return str;
    }
};

```





### 402. 移掉 K 位数字

给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

```
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

主要思路：

1. 使用单调栈的思想，去除k个字符；
2. 先按照单调升的顺序，去除部分元素（可能全部的k个）；
3. 注意对前导 0 的处理；
4. 对最后的字符进行可能的剩余字符的删除；

```cpp
class Solution{
public:
    string removeKdigits(string num, int k){
        string res;
        for (char &ch : num){
            //维护单调栈的上升顺序
            while (!res.empty() && k > 0 && res.back() > ch){
                res.pop_back();
                k--;
            }
            //处理前导零
            if (res.empty() && ch == '0'){
                continue;
            }
            res.push_back(ch);
        }
        //处理剩余的元素
        while (k > 0 && !res.empty()){
            res.pop_back();
            k--;
        }
        return res.empty() ? "0" : res; //返回可能的结果
    }
};
```



### 409. 最长回文串

给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

```
输入:s = "abccccdd"
输出:7
解释:我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

「回文串」是指倒序后和自身完全相同的字符串，即具有关于中心轴对称的性质：

- 当回文串长度为偶数时，则所有字符都出现了偶数次；
- 当回文串长度为奇数时，则位于中心的字符出现了奇数次，其余所有字符出现偶数次；

根据以上分析，字符串能被构造成回文串的充要条件为：除了一种字符出现奇数次外，其余所有字符出现偶数次。判别流程如下：

- 借助一个 HashMap ，统计字符串 s 中各字符的出现次数；
- 遍历 HashMap ，统计构造回文串的最大长度：
  - 将当前字符的出现次数向下取偶数（即若为偶数则不变，若为奇数则减 1 ），出现偶数次则都可组成回文串，因此计入 res ；
  - 若此字符出现次数为奇数，则可将此字符放到回文串中心，因此将 odd 置 1 ；
- 返回 res + odd 即可。

```cpp
class Solution {
public:
    int longestPalindrome(string s) {
        // 统计各字符数量
        unordered_map<char, int> counter;
        for (char c : s)
            counter[c]++;
        // 统计构造回文串的最大长度
        int res = 0, odd = 0;
        for (auto kv : counter) {
            // 将当前字符出现次数向下取偶数，并计入 res
            int count = kv.second;
            int rem = count % 2;
            res += count - rem;
            // 若当前字符出现次数为奇数，则将 odd 置 1
            if (rem == 1) odd = 1;
        }
        return res + odd;
    }
};
```



### 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
输入：s = "cbbd"
输出："bb"
```

双指针中心扩散，主要思路：

1. 遍历字符串的每一个位置，以该位置作为基点，向两端进行扩展，判断回文；
2. 针对每一个基点，需要判断回文字符串可能是偶数或者奇数的两种情形；
3. 判断回文字符串时，终止条件是左右方向不越界，且一直满足回文要求；

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        string res = "";
        for(int i = 0; i < s.size(); i++){
            // 回文字符串可能为奇数的情形
            string s1 = Palindrome(s, i, i);
            // 回文字符串可能为偶数的情形
            string s2 = Palindrome(s, i, i + 1);
            res = res.size() > s1.size() ? res : s1;
            res = res.size() > s2.size() ? res : s2;
        }
        return res;
    }

    // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
    string Palindrome(string s, int left, int right){
        // 防止索引越界
        while(left >= 0 && right < s.size() && s[left] == s[right]){
            // 双指针，向两边展开
            left--;
            right++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substr(left + 1, right - left - 1);
    }
};
```

如何判断是否是回文串：

```cpp
boolean isPalindrome(String s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```





### 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

 ```
输入：nums = [1,3,4,2,2]
输出：2
输入：nums = [3,1,3,4,2]
输出：3
 ```

由于数组中的元素都是正数，且都在1到n 的范围内，故可以使用数组的下标作为辅助。

既将和数组元素值相同的数组下标中对应的值置为其对应的负数，这样，当两个相同的元素映射到同一个位置，会发现元素值已经为负数了，既该值为重复的值。由于有映射负数的步骤，故使用数组元素时，需要使用其绝对值。

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        for(int num : nums){
            if(nums[abs(num)] < 0){
                return abs(num);
            }else{
                nums[abs(num)] *= -1;
            }
        }
        return 0;
    }
};
```



### 442. 数组中重复的数据

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。

 ```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
 ```

和上一题一样的思路。

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for(int num : nums){
            if(nums[abs(num) - 1] < 0){
                res.push_back(abs(num));
            }else{
                nums[abs(num) - 1] *= -1;
            }
        }
        return res;
    }
};
```



### 448. 找到所有数组中消失的数字

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

 ```
 输入：nums = [4,3,2,7,8,2,3,1]
 输出：[5,6]
 ```

`nums` 中的元素取值都在 `[1, n]` 之间，即元素本身就和索引成一一映射关系，所以可以用 `nums` 本身模拟哈希集合的效果。那么最终缺失的那些元素对应的索引就不会被标记，我们也就可以把缺失的那些元素找出来。

注意：用乘 -1 的方式给索引做标记的前提是，`nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for(int num : nums){
            // 注意索引，元素大小从 1 开始，有一位索引偏移
            if(nums[abs(num) - 1] < 0) continue; // 索引重复出现
            nums[abs(num) - 1] *= -1; // 把索引 num - 1 置为负数
        }
        vector<int> res;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > 0){
                // 说明没有元素和这个索引对应，即找到一个缺失元素
                res.push_back(i + 1);
            }
        }
        return res;
    }
};
```



### 461. 汉明距离





### 476. 数字的补数





### 496. 下一个更大元素 I

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

单调栈的模板：

输入一个数组 `nums`，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。

比如说，输入一个数组 `nums = [2,1,2,4,3]`，你返回数组 `[4,2,4,-1,-1]`。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

```java
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(nums.size());
	stack<int> st;
    for (int i = n - 1; i >= 0; i--) { // 倒着往栈里放
        while (!st.empty() && st.top() <= nums[i]) {
            st.pop();
        }
        res[i] = st.empty() ? -1 : s.top();
        st.push(nums[i]);
    }
    return res;
}
```

本题答案：

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> hashmap;
        stack<int> st;
        for (int i = nums2.size() - 1; i >= 0; --i) {
            int num = nums2[i];
            while (!st.empty() && num >= st.top()) {
                st.pop();
            }
            hashmap[num] = st.empty() ? -1 : st.top();
            st.push(num);
        }
        vector<int> res(nums1.size());
        for (int i = 0; i < nums1.size(); ++i) {
            res[i] = hashmap[nums1[i]];
        }
        return res;
    }
};
```



### 739. 每日温度

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n);
        stack<int> st;
        for(int i = n - 1; i >= 0; i--){
            while(!st.empty() && temperatures[i] >= temperatures[st.top()]){
                st.pop();
            }
            res[i] = st.empty() ? 0 : st.top() - i;
            st.push(i);
        }
        return res;
    }
};
```



### 503. 下一个更大元素 II

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

比如输入是 `[2,1,2,4,3]`，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素？

思路：将数组长度翻倍，索引用 % 运算符求模（余数）。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        stack<int> st;
        for(int i = 2 * n - 1; i >= 0; i--){
            while(!st.empty() && nums[i % n] >= st.top()){
                st.pop();
            }
            res[i % n] = st.empty() ? -1 : st.top();
            st.push(nums[i % n]);
        }
        return res;
    }
};
```



### 767. 重构字符串（复杂）

给定一个字符串 `s` ，检查是否能重新排布其中的字母，使得两相邻的字符不同。返回 `s` 的任意可能的重新排列。若不可行，返回空字符串 `""` 。

```
输入: s = "aab"
输出: "aba"
输入: s = "aaab"
输出: ""
```









### 946. 验证栈序列

给定 `pushed` 和 `popped` 两个序列，每个序列中的 **值都不重复**，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 `true`；否则，返回 `false` 。

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

模仿压栈和出栈的动作。

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if(pushed.size()!=popped.size()){
            return false;
        }
        stack<int> st;
        int j = 0;
        for(int i = 0; i < pushed.size(); i++){
            // 入栈
            st.push(pushed[i]);
            // 能出栈，则尽量出栈
            while(j < popped.size() && !st.empty() && st.top() == popped[j]){
                st.pop();
                j++;
            }
        }
        //若栈为空，则说明满足要求
        return st.empty();
    }
};
```



 

### 387. 字符串中的第一个唯一字符

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

```
输入: s = "leetcode"
输出: 0
输入: s = "loveleetcode"
输出: 2
```

考察哈希表的使用。

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char, int> map;
        for(char ch : s){
            map[ch]++;
        }
        for(int i = 0; i < s.size(); i++){
            if(map[s[i]] == 1){
                return i;
            }
        }
        return -1;
    }
};
```







### 剑指 Offer 57 - II. 和为s的连续正数序列

输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```
输入：target = 9
输出：[[2,3,4],[4,5]]
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

双指针，滑动窗口。

```cpp
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int left = 0, right = 0, sum = 0;
        vector<vector<int>> res;
        deque<int> add;
        while(left <= target / 2){
            right++;
            sum += right;
            add.push_back(right);
            while(sum >= target){
                if(sum == target){
                    res.push_back(vector<int>(add.begin(), add.end()));
                }
                left++;
                sum -= left;
                add.pop_front();
            }
            
        }
        return res;      
    }
};
```



### 263. 丑数

**丑数** 就是只包含质因数 `2`、`3` 和 `5` 的正整数。给你一个整数 `n` ，请你判断 `n` 是否为 **丑数** 。如果是，返回 `true` ；否则，返回 `false` 。

```
输入：n = 6
输出：true
解释：6 = 2 × 3
输入：n = 1
输出：true
解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的。习惯上将其视作第一个丑数。
```

数字使用因数 2,3,5逐渐的缩小，直到为1返回true，或没有这三个因数返回false。

```cpp
class Solution {
public:
    bool isUgly(int n) {
    if (n <= 0) return false;
    // 如果 n 是丑数，分解因子应该只有 2, 3, 5
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    // 如果能够成功分解，说明是丑数
    return n == 1;
    }
};
```

### 264. 丑数 II

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

如果一个数 x 是丑数，那么 x * 2, x * 3, x * 5 都一定是丑数。可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数，这三类丑数就好像三条有序链表，如下：

能被 2 整除的丑数：

```
1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...
```

能被 3 整除的丑数：

```
1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...
```

能被 5 整除的丑数：

```
1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...
```

三条「有序链表」合并在一起并去重，合并的结果就是丑数的序列。然后求合并后的这条有序链表中第 `n` 个元素是什么。

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        // 三个指向有序链表头结点的指针
        int p2 = 1, p3 = 1, p5 = 1;
        // 三个有序链表的头节点的值
        int val2 = 1, val3 = 1, val5 = 1;
        // 最终合并的有序链表（结果链表）
        int res[n + 1];
        // 结果链表上的指针
        int p = 1;
        // 合并三个有序链表
        while(p <= n){
            // 取三个链表的最小结点
            int minVal = min(val2, min(val3, val5));
            // 接到结果链表上
            res[p] = minVal;
            p++;
            // 前进对应有序链表上的指针
            if(minVal == val2){
                val2 = 2 * res[p2];
                p2++;
            }
            if(minVal == val3){
                val3 = 3 * res[p3];
                p3++;
            }
            if(minVal == val5){
                val5 = 5 * res[p5];
                p5++;
            }
        }
        // 返回第 n 个丑数
        return res[n];
    }
};
```



### 313. 超级丑数（不太会）

**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数**。题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内。

```
输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
```





### 2. 两数之和

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

注意要根据进位的结果，判断是否需要在链表的结尾添加结点。

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* p1 = l1, * p2 = l2;
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        int cur = 0, add = 0;
        while(p1 || p2 || add){
            int val1 = p1 ? p1->val : 0;
            int val2 = p2 ? p2->val : 0;
            if(p1) p1 = p1->next;
            if(p2) p2 = p2->next;
            int sum = val1 + val2 + add;
            cur = sum % 10;
            add = sum / 10;
            p->next = new ListNode(cur);
            p = p->next;
            // 若最后的进位是1，则还要加上去
            if(add == 1){
                p->next = new ListNode(1);
            }
        }
        return dummy->next;
    }
};
```





### 10. 正则表达式匹配（hard级）









### 32. 最长有效括号（困难）







### 44. 通配符匹配（困难）














## 参考资料

- [labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)
- [代码随想录 (programmercarl.com)](https://programmercarl.com/)
- [题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)](https://leetcode-cn.com/problemset/all/)













