# MySQL

- 主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

  - 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
  - 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。


- 联合索引的最左匹配原则

  InnoDB中的联合索引是指由多个列组成的索引，也称为组合索引或复合索引。与单列索引不同，联合索引是通过多个列的值来确定索引的位置，因此可以提高查询效率和性能。

  例如，一个表中有两个列a和b，需要查询a和b的值，那么可以使用联合索引来优化查询。在创建联合索引时，可以将a和b列一起作为索引列，这样就可以在查询时直接使用联合索引来定位数据行，而不需要对两个列进行分别查询，可以大大提高查询效率和性能。

  联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。

  例子：

  `select * from t_table where a > 1 and b = 2`， a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引；

  `select * from t_table where a >= 1 and b = 2`，a 和 b 字段都用到了联合索引进行索引查询；

  `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，a 和 b 字段都用到了联合索引进行索引查询；

  `SELECT * FROM t_user WHERE name like 'j%' and age = 22`， a 和 b 字段都用到了联合索引进行索引查询；

- 最左匹配原则为什么会失效

  最左匹配原则在一些情况下会失效，主要是因为以下原因：

  1. 不符合索引顺序：最左匹配原则要求查询条件必须从联合索引的最左侧开始匹配，如果查询条件的顺序与联合索引的顺序不一致，则无法使用索引进行查询优化。

  2. 未使用第一个索引列：最左匹配原则要求查询条件必须包含联合索引的第一个列，如果查询条件不包含联合索引的第一个列，则无法使用索引加速查询。

  3. 使用了函数或表达式：如果查询条件使用了函数或表达式，例如 WHERE YEAR(col1) = 2021，则无法使用索引进行查询优化。

  4. 数据列类型不同：如果联合索引的列类型不同，例如一个是字符串类型，另一个是数字类型，则最左匹配原则无法生效。

  5. 模糊匹配：如果查询条件使用了模糊匹配符号，例如 LIKE '%abc%'，则最左匹配原则无法生效。

  需要注意的是，最左匹配原则失效并不意味着查询一定会变慢，而是无法使用索引进行查询优化。在这种情况下，可以考虑对查询条件进行优化，例如调整查询条件的顺序、避免使用函数或表达式、使用全文索引等方式来提高查询效率。

- 什么时候适用索引？

  - 字段有唯一性限制的，比如商品编码；
  - 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
  - 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

- 什么时候不需要创建索引？

  - WHERE条件， GROUP BY， ORDER BY 里用不到的字段；
  - 字段中存在大量重复数据，不需要创建索引；
  - 表数据太少的时候，不需要创建索引；
  - 经常更新的字段不用创建索引；

- 防止索引失效

  - 使用左或者左右模糊匹配，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
  - 查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
  - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
  - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

- MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

  - B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

  - B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；

  - B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。


- 有哪些手段可以优化数据库的 SQL 查询效率？
  - 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引；
  - 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
  - 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描；
  - 使用左或者左右模糊匹配，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
  - 应尽量避免在 where 子句中对字段进行表达式操作或者函数操作，这将导致引擎放弃使用索引而进行全表扫描；

- 主键和唯一索引的区别

  - 主键是一种约束，而唯一索引是一种索引；

  - 主键一定会创建一个唯一索引，有唯一索引的列不一定为主键；
  - 主键不允许空值，唯一索引列允许空值；
  - 一个表只能有一个主键，但是可以有多个唯一索引；
  - 主键可以被其它表引用为外键，唯一索引列不可以；

- 事务的ACID特性：

  - 原子性（Atomicity）

    一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

  - 一致性（Consistency）

    数据库总是从一个一致性的状态转移到另一个一致性的状态。一致性确保了即使在执行第三、第四条语句之间时系统崩溃，前面执行的第一、第二条语句也不会生效，因为事务最终没有提交，所有事务中所作的修改也不会保存到数据库中。

  - 隔离性（Isolation）

    一个事务的执行不能其它事务干扰，一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

  - 持久性（Durability）

    事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。


- InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

  - 原子性是通过 undo log（回滚日志） 来保证的；

  - 一致性则是通过持久性+原子性+隔离性来保证；

  - 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
  - 持久性是通过 redo log （重做日志）来保证的；

- 并发事务引发的问题

  在同时处理多个事务的时候，就可能出现**脏读、不可重复读、幻读**的问题。

  - 脏读

    读到其他事务未提交的数据；

  - 不可重复读

    前后读取的数据不一致；

  - 幻读

    前后读取的记录数量不一致。

- 事务的隔离级别

  三种现象的严重性排序：脏读 > 不可重复读 > 幻读

  四种隔离级别：

  - 读未提交

    一个事务还没提交时，它做的变更就能被其他事务看到；

  - 读已提交

    一个事务提交之后，它做的变更才能被其他事务看到；

  - 可重复读

    一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；

  - 串行化

    会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

  隔离水平高低排序：串行化  > 可重复读 > 读已提交 > 读未提交，隔离级别越高，性能效率就越低。

  - 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
  - 在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
  - 在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
  - 在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

  所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。

  MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象，解决的方案有两种：

  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题；
  - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

  对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

  - 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
  - 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

  这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

- InnoDB 的普通索引和主键索引有什么区别

  Mysql各种索引区别：

  - 普通索引：最基本的索引，没有任何限制

  - 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。

  - 主键索引：它是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值；索引列的值必须是唯一的。简单来说：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个；

  - 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。

  - 联合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。

- MySQL用char和varchar什么区别？

  1. varchar比char更节省空间。

     varchar类型用于存储可变长度字符串，实际存储的空间=字符串内容+字符串长度，需要使用1或2个额外字节记录字符串的长度。char类型是固定长度的，一旦定义了字段类型char(10)，哪怕只是存了3个字符，那么也是用了10个字符长度的存储空间，其中7个为空字符/无效字符。

  2. char的性能比varchar要更好。

     char根据定义的字符串长度分配了足够的空间。varchar在更新长度时（比原来长度更长），有可能导致分裂页，导致出现碎片问题。根据存储结构的特性，也导致了更新数据时，char的性能比varchar要更好。

  3. 适合varchar的场景：

     - 字符串的最大长度比平均长度大很多；

     - 列的更新很少，所以碎片不是问题。

  4. 适合char的场景:

     - 存储很短的字符串或者所有值都接近同一个长度，例如md5、ip等信息。

     - 经常变更的数据，不容易产生碎片。

- MySQL数据库有哪两种引擎？它们之间有什么区别和联系

  MyISAM和InnoDB都是MySQL数据库的存储引擎，它们之间有以下区别：

  1. 事务支持：InnoDB支持事务处理，可以使用ACID（原子性、一致性、隔离性、持久性）来保证数据的完整性和一致性。而MyISAM不支持事务处理，不能保证数据的一致性。
  2. 锁机制：InnoDB采用行级锁定，只锁定需要修改的行，提高并发性能。而MyISAM采用表级锁定，会锁定整个表，如果多个用户同时访问一个表，就会出现互相等待的情况，降低并发性能。
  3. 外键约束：InnoDB支持外键约束，可以通过外键约束实现关联查询和级联删除等功能。而MyISAM不支持外键约束。
  4. 性能：MyISAM在读取数据方面的性能表现较好，在大量读取的情况下效率更高。而InnoDB在处理事务和大量并发查询的情况下性能更好。

  综上所述，如果需要支持事务处理、外键约束和高并发性能，建议使用InnoDB存储引擎。如果主要是用于大量读取数据的应用程序，建议使用MyISAM存储引擎。

- 联合索引有什么性质？

  联合索引是由多个列组成的索引，它具有以下性质：

  1. 联合索引可以加速多列条件查询。当查询语句中包含联合索引中的多个列时，数据库可以使用联合索引来快速定位符合条件的行，从而提高查询效率。

  2. 联合索引的顺序很重要。联合索引的顺序决定了索引的使用效果，因为数据库只能使用索引的最左边一部分来加速查询。因此，需要将最常用的列放在联合索引的最左边，以获得最佳的查询性能。

  3. 联合索引对单个列的查询效率可能不如单独的列索引。如果查询语句只包含联合索引中的一部分列，那么数据库可能无法使用联合索引来加速查询，这时单独为每个列建立索引可能更为有效。

  4. 联合索引的维护成本较高。由于联合索引包含多个列，因此它的维护成本较高。当表中的数据发生变化时，需要更新联合索引的所有列，这可能会导致索引的更新成本和存储空间成本增加。

  总的来说，联合索引可以加速多列条件查询，但是需要注意索引的顺序和维护成本，以获得最佳的查询性能。

- 可重复读和读已提交如何实现

  可重复读和读已提交是数据库中常用的两种事务隔离级别，它们的实现方式有所不同。

  1. 可重复读的实现方式：

  在可重复读隔离级别下，数据库需要为每个事务开启一个独立的视图，用于保存事务开始时读取的数据快照。当事务需要读取数据时，数据库会从该视图中读取数据，而不是从实际的数据表中读取。同时，数据库会对事务读取的数据进行加锁，以保证其他事务不能修改已经读取的数据。当事务结束时，数据库会将该视图和相关的锁释放。

  2. 读已提交的实现方式：

  在读已提交隔离级别下，数据库需要为每个事务开启一个独立的视图，用于保存事务开始时读取的数据快照。当事务需要读取数据时，数据库会从实际的数据表中读取最新的数据，而不是从事务自己的视图中读取。同时，数据库会对事务读取的数据进行加锁，以保证其他事务不能修改已经读取的数据。当事务提交时，数据库会将相关的锁释放。

  实现可重复读和读已提交的方式有很多种，具体的实现方式取决于数据库的具体实现。常见的实现方式包括基于锁的实现、基于多版本并发控制（MVCC）的实现、基于快照隔离的实现等。不同的实现方式各有优缺点，需要根据具体的业务场景和性能需求选择合适的实现方式。

- Innodb 的行锁是怎么实现的

  InnoDB是MySQL的一种存储引擎，其行锁是通过多版本并发控制（MVCC）实现的。MVCC是保证并发控制的一种机制，通过为每个事务分配一个唯一的事务ID，以及为每个数据行分配一个版本号来实现。

  以下是InnoDB的行锁实现过程：

  1. 当一个事务更新一行数据时，InnoDB会为该行数据创建一个新的版本，并将该版本的版本号与事务ID关联。同时，在该行数据的版本链表中记录该版本，并将该行数据的当前版本号更新为新版本号。

  2. 当另一个事务需要锁定该行数据时，InnoDB会查找该行数据的版本链表，并根据事务ID和版本号来判断是否可以进行锁定。如果该行数据的当前版本号与事务ID相关，则表示该事务已经锁定该行数据。否则，InnoDB会创建一个新的版本，并将该版本的版本号与事务ID相关联。

  3. 当一个事务提交时，InnoDB会将该事务所修改的行数据的版本号更新为当前版本号，并将该事务ID从该行数据的版本链表中删除。同时，InnoDB会清理已经提交的事务所创建的所有版本。

  需要注意的是，InnoDB的行锁是基于索引实现的。如果没有使用索引或使用了全表扫描，InnoDB将会使用表锁来保证并发控制。此时，多个事务需要争用同一个锁，可能会导致性能瓶颈。

  InnoDB的行锁实现过程是复杂的，但是可以提供高并发的支持，保证数据的一致性和可靠性。同时，需要注意事务的设计和隔离级别的选择，以避免死锁等并发控制问题。

- msyql 间隙锁：什么时候会产生间隙锁？

  MySQL的间隙锁（Gap Lock）是一种用于保护事务并发操作的锁机制。它的作用是锁定一个范围内的值，而不是具体的某个值，从而避免其他事务在同一范围内进行插入或更新操作。

  在MySQL中，间隙锁会在以下情况下产生：

  1. 当使用范围查询语句（例如WHERE col BETWEEN 1 AND 10）时，MySQL会为查询范围中的每个间隙（即两个相邻的值之间的空隙）产生一个间隙锁。这样，其他事务就无法在这些间隙中插入新的数据。

  2. 当使用锁定读（FOR UPDATE）或共享锁（LOCK IN SHARE MODE）时，MySQL会产生间隙锁来保护查询结果中的间隙。例如，如果一个事务使用FOR UPDATE查询了id列在1和10之间的数据，那么MySQL会为id=1和id=10之间的间隙产生一个间隙锁，防止其他事务在这个范围内进行插入或更新操作。

  需要注意的是，间隙锁只会在使用范围查询、锁定读或共享锁时产生，而不会在使用普通的等值查询时产生。此外，间隙锁只会在InnoDB存储引擎中产生，而不会在MyISAM等其他存储引擎中产生。

  在实际应用中，间隙锁可以有效地避免并发操作的冲突，但是也会增加锁的数量和粒度，可能会影响系统的性能。因此，在使用间隙锁时需要仔细考虑锁的范围和粒度，以提高系统的并发性能。

- next-key 锁？如何实现？

  Next-key锁是MySQL InnoDB存储引擎中的一种锁机制，它的作用是避免幻读问题。Next-key锁是InnoDB存储引擎中行锁和间隙锁的组合，通过同时锁定索引上的行和间隙来保证数据的一致性。

  Next-key锁的实现过程可以分为以下几个步骤：

  1. 当一个事务需要锁定一个索引上的行时，InnoDB会先锁定该行，然后锁定该行之前的间隙（如果存在）。这样，其他事务就无法在这个间隙中插入新的数据，从而保证了数据的一致性。

  2. 当一个事务需要锁定一个索引上的间隙时，InnoDB会先锁定该间隙，然后锁定该间隙后面的行（如果存在）。这样，其他事务就无法在这个行和间隙之间插入新的数据，从而保证了数据的一致性。

  需要注意的是，Next-key锁只会在使用范围查询、锁定读或共享锁时产生，而不会在使用普通的等值查询时产生。此外，Next-key锁只会在InnoDB存储引擎中产生，而不会在MyISAM等其他存储引擎中产生。

  在实际应用中，Next-key锁可以有效地避免幻读问题，提高系统的数据一致性。但是，Next-key锁也会增加锁的数量和粒度，可能会影响系统的性能。因此，在使用Next-key锁时需要仔细考虑锁的范围和粒度，以提高系统的并发性能。

- sql：表格中有人员 id与歌 id，找到被不同人听了两次以上的歌（每个人可能会听很多次）

  ```sql
  SELECT song_id
  FROM person_song
  GROUP BY song_id, person_id
  HAVING COUNT(DISTINCT person_id) >= 2
  ```


- 什么是聚类索引和非聚类索引

  在数据库中，索引是一种数据结构，用于加速数据查询操作。聚集索引和非聚集索引是两种不同类型的索引。

  1. 聚集索引（Clustered Index）：聚集索引是一种索引方式，它是按照索引的顺序来存储表中的数据。在聚集索引中，数据行的物理顺序与索引顺序相同。每个表只能有一个聚集索引，它通常是主键索引。聚集索引可以提高数据的查询性能，因为它可以减少磁盘 I/O 操作。

  2. 非聚集索引（Non-Clustered Index）：非聚集索引是一种索引方式，它是在独立的数据结构中存储索引和数据。在非聚集索引中，数据行的物理顺序与索引顺序不同。每个表可以有多个非聚集索引。非聚集索引可以提高数据的查询性能，因为它可以减少磁盘 I/O 操作。

  总之，聚集索引和非聚集索引都是数据库中常见的索引类型，它们在索引的存储方式和数据访问方式上有所不同。聚集索引按照索引顺序来存储表中的数据，而非聚集索引是在独立的数据结构中存储索引和数据。需要根据具体的数据访问需求来选择合适的索引类型。

- 给出一个表 A 有 a1~a5 个列，联合索引（a2,a1），select a5 from A where a2=1 and a1=2。请问用到联合索引了吗？ 它的具体过程呢，怎么回的表？

  根据给出的联合索引（a2,a1），查询条件中包含了联合索引的前两个列a2和a1，因此可以使用联合索引来优化查询，查询过程如下：

  1. 首先，根据联合索引（a2,a1）查找a2=1和a1=2的数据行在索引中的位置。

  2. 然后，通过索引定位到数据行的位置后，可以直接获取该数据行中a5列的值。

  因此，使用了联合索引来定位数据行，查询效率会比较高。

  具体过程如下：

  1. 根据联合索引（a2,a1）查找a2=1和a1=2的数据行在索引中的位置。

  2. 找到索引中a2=1的第一个数据行，然后在该数据行的后面逐个查找，直到找到a2=1且a1=2的数据行。

  3. 找到a2=1且a1=2的数据行后，可以直接获取该数据行中a5列的值。

  注意，如果表A中的a2和a1列的组合存在多个相同的值，那么可能会有多个数据行满足查询条件a2=1和a1=2，此时需要逐个定位每个数据行，直到找到第一个满足条件的数据行为止。

- 为什么 Myisam 查询插入效率高

  MyISAM 存储引擎的查询和插入效率相对较高，主要原因如下：

  1. MyISAM 存储引擎采用的是表级锁定，对于插入操作来说，只需要锁定整个表，而不需要锁定具体的行，从而避免了锁的竞争和死锁的发生，提高了插入效率。

  2. MyISAM 存储引擎在插入数据时使用的是追加写入的方式，即将新的数据追加到数据文件的末尾。这种方式可以避免数据的移动和重组，从而减少了插入操作的时间和开销，提高了插入效率。

  3. MyISAM 存储引擎在查询操作时，采用的是全表扫描的方式，对于大量数据的查询效率相对较高。这种方式可以避免使用索引造成的额外开销，同时也可以利用磁盘预读技术，提高查询效率。

  需要注意的是，MyISAM 存储引擎虽然查询和插入效率相对较高，但是在并发访问和事务处理方面相对较弱。因此，在实际应用中，需要根据具体情况选择合适的存储引擎，同时也需要进行适当的优化和调整，以保证系统的稳定性和性能。

- 乐观锁和悲观锁、乐观锁实现方式

  乐观锁和悲观锁都是并发控制的方式，用于解决多个线程同时访问共享资源时可能出现的数据不一致问题。

  悲观锁是一种悲观的思想，它认为在并发环境下，每次访问共享资源时都会发生冲突，因此采用加锁的方式对资源进行保护，防止其他线程对资源的访问。常见的悲观锁实现方式包括数据库中的行级锁、表级锁等。

  乐观锁则是一种乐观的思想，它认为并发环境下，冲突不是每次都会发生，因此不采用加锁的方式，而是采用版本号等方式来进行控制。当多个线程同时访问同一个共享资源时，每个线程会先获取该资源的版本号等信息，然后进行操作。在操作完成后，如果该资源的版本号等信息发生了变化，则说明有其他线程对该资源进行了修改，此时需要重新操作，直到修改成功。

  乐观锁的实现方式有多种，常见的方式包括：

  1. 版本号控制：在数据库中添加版本号字段，每次更新时检查版本号是否一致，如果一致则进行更新，否则抛出异常或重新尝试。

  2. 时间戳控制：在数据库中添加时间戳字段，每次更新时检查时间戳是否一致，如果一致则进行更新，否则抛出异常或重新尝试。

  3. CAS（Compare and Swap）操作：CAS 是一种无锁算法，用于解决并发环境下的原子性问题。在进行更新操作时，先获取资源的当前值和版本号等信息，在本地进行修改，然后使用 CAS 操作将新值和版本号等信息写回到共享资源中。如果写回成功，则说明没有其他线程对该资源进行了修改，操作完成；否则需要重新获取最新的资源信息，重新进行操作。

  总的来说，乐观锁和悲观锁都有各自的优缺点和适用场景。在并发量较高、冲突较为频繁的情况下，悲观锁可能更适合；而在并发量较低、冲突较少的情况下，乐观锁可能更适合。

- 下⾯语句查询索引的过程有什么区别？

  ```mysql
  select * from table where b = xx; b is index
  select id from table where b = xx; id is primary key
  ```

  在查询过程中，如果使用索引列 `b` 进行查询，那么数据库会首先在索引树上查找符合条件的行，然后再根据行指针到主键索引或数据页上获取数据行的具体内容。由于索引树的结构通常比数据页的结构更紧凑，因此使用索引列进行查询可以更快地定位到符合条件的行，从而提高查询效率。

  如果使用主键列 `id` 进行查询，那么数据库会直接在主键索引或数据页上查找符合条件的行，由于主键索引是表中数据的唯一标识，因此直接使用主键进行查询可以更快地获取到对应的数据行。

- SQL注⼊

  SQL注入（SQL Injection）是指攻击者通过在应用程序中注入恶意的SQL代码，从而让应用程序执行非预期的SQL查询或命令，从而获取敏感信息或者对数据库进行非法操作的一种攻击手段。

  SQL注入攻击的原理是利用应用程序没有对用户输入的数据进行充分的验证和过滤，将恶意的SQL代码作为用户输入的一部分，从而使得攻击者能够绕过应用程序的安全机制，直接操作数据库。

  以下是一些常用的 SQL 注入攻击方式：

  1. 基于 UNION 的注入：攻击者通过在 SQL 语句中使用 UNION 关键字，将恶意的 SQL 语句插入到应用程序的 SQL 查询中。

  2. 基于 Boolean 的盲注：攻击者通过构造一些条件判断语句，来判断数据库中是否存在某些数据，从而获取敏感信息。

  3. 基于时间的盲注：攻击者通过在 SQL 语句中增加一些等待时间的指令，来判断应用程序是否对 SQL 注入攻击有过滤机制。

  以下是一些防范 SQL 注入攻击的建议：

  1. 对用户输入的数据进行充分的验证和过滤，确保输入的数据格式和类型正确，并且符合预期的范围和规则。

  2. 使用参数化的 SQL 查询语句，而不是直接拼接 SQL 语句，避免注入攻击。

  3. 限制数据库用户的权限，确保数据库用户只能执行合法的操作，并且只能访问合法的数据。

  4. 定期对应用程序进行安全审计和漏洞扫描，及时发现并修复可能存在的漏洞和安全问题。

  总之，防范 SQL 注入攻击需要多方面的措施，包括对用户输入的数据进行充分的验证和过滤、使用参数化的 SQL 查询语句、限制数据库用户的权限等等。

- select A from table where B=1 orderby C，如何构建索引来加速查找过程？

  要优化 `select A from table where B=1 orderby C` 查询语句的性能，可以在表的 B 字段上创建一个索引，并且在 C 字段上也创建一个索引。

  在 B 字段上创建的索引可以加速 WHERE 子句的查找，它可以快速定位满足 B=1 条件的行，从而减少扫描整个表的开销。

  在 C 字段上创建的索引可以加速 ORDER BY 子句的排序过程，它可以快速定位并按照 C 字段的值进行排序，从而减少排序算法的开销。

  需要注意的是，创建索引也会带来一些额外的开销，如索引的创建和维护，以及额外的存储空间。因此，在创建索引之前，应该仔细评估索引的必要性和影响，避免过度索引和滥用索引带来的性能问题。

  此外，为了进一步优化查询性能，还可以考虑以下几点：

  1. 尽量减少查询结果集的大小，可以使用 SELECT 子句来限制返回的列数，避免不必要的数据传输和处理。

  2. 尽量减少 ORDER BY 子句的使用，不必要的排序会降低查询性能。

  3. 尽量避免使用通配符和模糊查询，它们会导致全表扫描，降低查询性能。

  4. 对于经常查询的语句，可以使用缓存机制来避免重复查询和重复计算。

  总的来说，通过合理地创建索引、优化查询语句和使用缓存等手段，可以有效地提高查询性能和系统响应速度。

- 数据库insert和replace区别

  在数据库中，INSERT 和 REPLACE 都是用于向表中插入新行的 SQL 命令，但它们之间有一些重要的区别。

  INSERT 命令用于向表中插入新行。如果插入的行与表中已有的行有重复的唯一键（或主键），那么将会导致插入失败并抛出错误。例如，如果表中已经有一个具有相同主键的行，则插入操作将会失败。在这种情况下，必须修改主键或唯一键以避免重复，然后再次尝试插入。

  REPLACE 命令也用于向表中插入新行，但是，如果插入的行与表中已有的行有重复的唯一键（或主键），那么 REPLACE 命令将会删除已有的行，然后插入新的行。如果表中没有重复的唯一键，则 REPLACE 命令将会像 INSERT 命令一样插入新行。

  需要注意的是，REPLACE 命令会删除已有的行，这可能会导致与该行相关的数据被删除，因此应该谨慎使用。通常，应该使用 INSERT 命令，并在插入之前确保要插入的行不会与已有的行重复。

  此外，需要注意的是，INSERT 和 REPLACE 命令在执行时会锁定表，这可能会影响并发性能。因此，在高并发的应用程序中，应该使用更高级的技术，例如批量插入或使用事务，以提高性能并确保数据的一致性。

- 关系型数据库和非关系型数据库区别

  关系型数据库（Relational Database）和非关系型数据库（NoSQL，Not-Only-SQL）是两种不同类型的数据库管理系统。它们有不同的数据模型、查询方式和适用场景。以下是关系型数据库和非关系型数据库的主要区别：

  1. 数据模型

     关系型数据库基于系模型，数据以表格的形式存储。表格中的每行代表一个数据记录，每列表示一个属性。关系型数据库使用主键、外键等概来实现表之间的关联和数据约束。

     非关系型数据库具有多种数据模型，如键值存储（Key-Value）、文档存储（Document）、列族存储（Column Family）和图数据库（Graph）。这些数据模型允许更灵活的数据结构，如嵌套数组和键值对。

  2. 查询语言

      关系型数据库用结构化查询语言（SQL）作为标准的查询方式。SQL是一种功能强大且通用的查询语言，允许用户进行复杂数据操作，如联表查询、聚合函数和事务处理。

     非关系数据库的查询语言因数据库类型而异。许多NoSQL数据库提供自己的查询接口，如MongoDB的查询语句、Redis的命令等。这些查询语言通常针对本数据库特点进行优化，但功能和通用性可能不如SQL。

  3. 数据完整性和事务支持

     关系型数据库通常遵循ACID（Atomicity, Consistency, Isolation, Durability）原则来保数据完整性和事务的一致性。

     非关系型数据库对ACID原则的支持不一。一些NoSQL数据库（如MongoDB、Couchbase）提供了一定程度的事务支持，但大部分非关系型数据库在分布式环境下更关注性能和可扩展性，以部分牺牲数据整性为代价。

  4. 扩展性

     关系型数据库通常支持垂直扩展（Vertical Scaling），即通过增加硬件资源（CPU、存等）提高数据库性能。

     非关系型数据库更注重水平扩展（Horizontal Scaling），即将数据分布在多个节点上以实现高并发和高可用。这使得非关系型数据库更适合应对大数据和高并发场景

  5. 适用场景

     关系型数据库适用于需要复杂查询、数据完整性要求较高的场景，例如金融、电商。

     非关系型数据库适合用于处理非结构化或半结构化数据，需要快速响应、高并发访问和灵活扩展的场景，例如社交网络、物联网和实时分析等。

  两者各有优势，根据项目需求和场景选择合适的数据库类型非常重要。实际应用中，关系型数据库和非关系型数据库也可以混合使用以提供更全面的数据解决方案。

- 聚集索引和非聚集索引

  聚集索引（Clustered Index）和非聚集索引（Non-Clustered Index）是数据库中两种不同类型的索引结构，分别具有不同的特点和用途。它们在性能、结构和存储方式方面有很大差异。下面是它们之间的主要区别和特点。

  聚集索引（Clustered Index）：

  1. 聚集索引将表中的数据行按照某种顺序存储，这个顺序与键值匹配。在表中，每个数据页都有一个键值且只能有一个聚集索引。
  2. 由于聚集索引的数据存储方式，查询速度通常比非聚集索引快，这是因为聚集索引使数据更容易被物理顺序访问。
  3. 插入、删除和更新操作中，聚集索引可能会导致数据页重新排序，以保持顺序因此，在大量插入、和更新操作中性能较低。

  非聚集索引（Non-Clustered Index）：

  1. 非聚集索引在表中存储索引键值以及指向相应数据行的指针。非聚集索引指向的数据行与索引顺序无关，因此表可以按任意顺序存储。
  2. 使用非聚集索引时，查询速度可能较慢单独使用聚集索引。这是因为非聚索引需要查找索引键值，然后通过指针查找相应的数据行。
  3. 插入、删除和更新操作中，非聚集索引可以避免数据页重新排序的问题，因为它们不受物理数据存储顺序影响。因此，非聚集索引在大量插入、删除和更新操作时可能性能较高。
  4. 一个表可以有多个非聚集引。

  总结：

  聚集索引是一种数据存储和查询优化策略，主要提高了数据的顺序访问性能。相比下，非聚集索引则是一种灵活的键值查询优化策略，适用于在大量数据修改操作的场景。选择聚集索引还是非聚集索引取决于实际应用场景、数据访问模式和性能要求。在许多情况下，聚索引和非聚集索引同时使用以优化不同类型的数据库查询。

- 

