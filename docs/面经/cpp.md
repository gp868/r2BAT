# cpp


## 语言基础

- i++和++i 的区别，哪个效率高？i++线程安全吗？

  1. 区别：

  - i++是先赋值，然后再自增；++i是先自增，后赋值；
  - i++ 不能作为左值，而++i可以；

  2. 效率：

  当考虑自定义类的时候，两者效率有区别。

  i++是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象，不能作为左值；++i是直接对原对象进行自增，然后返回原对象的引用，可以作为左值。

  由于要生成临时对象，i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象一次，临时对象以值传递方式返回一次）；++i由于不用生成临时变量，且以引用方式返回，故没有构造与析构的开销，效率更高。

  所以在使用类等自定义类型的时候，应尽量使用++i。

  3. 线程安全：

  - 如果i是局部变量（在方法里定义的），那么是线程安全的。因为局部变量是线程私有的，别的线程访问不到；

  - 如果i是全局变量（类的成员变量），那么是线程不安全的。因为如果是全局变量的话，同一进程中的不同线程都有可能访问到。

- i++操作是否能保证线程安全

  i++ 操作本质上不是线程安全的，因为它包含了读取和更新操作，这些操作可能会被多个线程同时执行，导致竞态条件（Race Condition）的出现。在多线程环境中，如果多个线程同时对同一个变量进行读取和更新操作，那么就可能会出现数据不一致的问题。

  例如，当一个线程在执行 i++ 操作时，可能会读取 i 的值并将它加1，但是在执行加1操作之前，另一个线程也可能读取i的值并进行加1操作，这样就会导致 i 的值只增加了1，而不是增加了2。这种情况称为竞态条件。

  为了避免竞态条件的出现，可以使用同步机制来保证 i++ 操作的线程安全。例如，可以使用互斥锁（Mutex）来保护对 i 的访问，确保每次只有一个线程可以访问 i，从而避免竞态条件的出现。此外，还可以使用原子操作来实现 i++ 操作的线程安全，原子操作可以确保对 i 的读取和更新操作是不可分割的，从而避免了竞态条件的出现。

  需要注意的是，单个的 i++ 操作可能不会导致竞态条件的出现，因为编译器会将它编译成原子指令。但是，如果在多线程环境中多次执行 i++ 操作，就可能会出现竞态条件的问题。因此，在多线程环境中，应该总是使用同步机制来保证对共享变量的访问是线程安全的。

- 函数指针和指针函数的区别？

  - 函数指针：int (*f)(int x, int y);

  - 指针函数：int *f(int x, int y);

  函数指针本质是一个指针，其指向一个函数；指针函数本质是一个函数，其返回值为指针。

- 回调函数和普通函数的区别

  回调函数（Callback Function）是指在函数运行过程中，将函数指针作为参数传递给另一个函数，并在另一个函数中调用该函数指针，从而完成一定的操作。普通函数则是指没有回调机制，直接按照函数的定义和调用方式执行的函数。 回调函数和普通函数的主要区别如下：

  1. 使用方式不同：回调函数是将函数指针作为参数传递给另一个函数，并在另一个函数中调用该函数指针；而普通函数则是直接按照函数的定义和调用方式执行的函数。
  2. 调用时机不同：回调函数的调用时机是由另一个函数来确定，一般在某个事件发生时被回调；而普通函数的调用时机则是由函数的调用者来确定。
  3. 灵活性不同：由于回调函数是将函数指针作为参数传递，因此可以在运行时动态指定要调用的函数，从而使程序更加灵活；而普通函数则是在编译时确定的，不具备动态性。
  4. 作用不同：回调函数主要用于事件驱动型程序中，例如GUI程序、操作系统等；而普通函数则是用于完成特定的功能。

  需要注意的是，回调函数和普通函数并不是完全独立的概念，有些函数既可以作为普通函数使用，也可以作为回调函数使用。

- 静态变量的初始化时间

  - 静态初始化，用常量来对静态变量进行初始化

    在main()函数之前，程序加载时初始化；

  - 动态初始化，需要调用函数才能完成的初始化，比如类的构造函数

    全局静态变量或者类的静态成员变量，是在main()函数执行前，运行时初始化；局部静态变量在函数第一次执行到该初始化语句时初始化。


- const int* a, int* const a, int const* a 的区别

  - const int* a：指针指向地址的内容不能被改变，但是指针指向的地址可以更改；
  - int const* a：和const int* a相同；
  - int* const a：指针指向的地址不能更改，但是指针指向地址的内容可以更改；

- int a[10]; 这个数组的数组变量和数组内容都是存在哪里的？

  数组变量存储在栈内存中：在 C++ 中，数组变量是一个指向数组首元素的指针，它存储在栈内存中。对于 `int a[10];` 这个数组变量，它在内存中的存储位置是栈内存的某个位置，用于存储指向数组首元素的指针。

  数组内容存储在堆内存或栈内存中：数组内容存储在内存中的位置取决于数组的定义方式和存储位置。对于 `int a[10];` 这个数组，它是在函数栈内存中定义的，其内容也存储在栈内存中。而对于使用 new 运算符动态分配内存的数组，则其内容存储在堆内存中。

- 指针数组和数组指针的区别？

  数组指针本质是指针，是指向数组的指针；指针数组本质是数组，是保存指针的数组。

  ```c
  int (*p)[4]; // 数组指针
  // int类型的指针p指向int[4]数组首地址，数组的每一个元素是一个int类型的变量，数组大小为4
  int *p[4];  // 指针数组
  // 数组长度为4，所有元素均为int类型的指针
  ```

- 求一个表达式的值：

  ```c
  int a = (int)(((int*)0)+4);  
  ```

  a =16，相当于把`(int*)`，这个整形指针加4，即移动`4*sizeof（int）`个字节，即16个字节，然后把这个指针转为int就是16，`(int*)0`地址0，加上16字节后，为0x00000010。

- 下面这段代码最终打印什么

  ```c
  int main () {
    fork();
    fork();
    fork();
    printf("hello world\n");
    exit(0);
  }
  // 打印2的3次方即8行hello world
  int main()
  {
  	fork();
  	printf("hello\n");
  	fork();	
  	printf("hello\n");
  }
  // 打印6行hello world
  ```

- const int func(const char *const p) const 四个 const 的作用

  1. const修饰函数返回值，可以防止函数返回值被修改；
  2. 指针指向地址的内容不可更改；
  3. 指针指向的地址不可以更改；
  4. const修饰类成员函数，可以防止成员函数修改对象的内容；

- assert 函数说一下？abort 函数调用后程序会咋样？

  `assert` 是宏，而不是函数。它的原型定义在头文件 assert中：

  ```c
  void assert( int expression );
  ```

  宏 assert 经常用于在函数开始处检验传入参数的合法性，可以将其看作是异常处理的一种高级形式。assert 的作用是先计算表达式expression，然后判断：

  - 如果表达式值为假，那么它先向 stderr 打印错误信息，然后通过调用 abort 来终止程序运行；
  - 如果表达式值为真，继续运行后面的程序；

  注意：`assert` 只在 `DEBUG` 下生效，在调试结束后，可以通过在 `#include <assert.h>` 语句之前插入 `#define NDEBUG` 来禁用 assert 调用。频繁的调用assert函数会极大的影响程序的性能，增加额外的开销。

  ```c
  #define NDEBUG
  #include <assert.h>
  ```

  abort()函数的原型位于头文件cstdlib（或stdlib.h）中，作用是异常终止一个进程，意味着abort后面的代码将不再执行。调用abort()时，不进行任何清理工作，直接终止程序。abort()函数通过发出一个SIGABRT信号终止程序的执行。

- 二维数组的按行和按列获取元素顺序有什么异同，哪个效果好，为什么

  按行获取时，同一行的元素在内存中是连续存储的；而按列获取时，同一列的元素在内存中不是连续存储的。

  - 对于连续遍历所有元素的情况，按行获取效果更好。因为按行获取的元素在内存中是连续存储的，这样可以充分利用 CPU 缓存，提高程序的运行效率。
  - 对于查找某一行或某一列的所有元素的情况，按列获取效果更好。按列获取元素的优点是可以利用程序的局部性原理，因为二维数组在内存中是连续存储的，所以在按列获取元素时，CPU可以预先将该列的所有元素加载到缓存中，这样可以减少CPU的缓存失效率，提高程序的效率。

  综上所述，如果需要遍历所有元素，建议按行获取；如果需要查找某一行或某一列的所有元素，建议按列获取。

- 运算符重载和函数重载的区别

  函数重载是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字；运算符重载是指同一个运算符可以施加于不同类型的操作数上面。就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

  1. 定义方式不同：运算符重载是通过在函数名前加上运算符关键字和符号来定义的，例如重载加法运算符可以使用`operator+`来定义；而函数重载是在函数名相同的情况下，通过参数列表的不同来定义的。
  2. 使用方式不同：运算符重载可以像使用内置运算符一样来使用，例如 `a+b`，其中 `+` 运算符被重载了；而函数重载需要在调用时根据传递的参数列表来确定具体调用哪个函数。
  3. 限制不同：运算符重载只能重载 C++ 中现有的运算符，而函数重载可以重载任何函数名。
  4. 返回值类型不同：运算符重载的返回值通常是运算结果，而函数重载的返回值可以是任何类型。
  5. 参数个数不同：运算符重载通常只有一个参数，即运算符左侧的操作数，但有些运算符重载可能有两个参数，例如重载赋值运算符 `operator=`；而函数重载可以有任意数量的参数。

- 内存对齐有什么用？

  内存对齐是指在分配内存时，按照一定的规则和字节对齐方式分配，使得数据存储在内存中的地址能够被 CPU 高效地访问，从而提高程序的执行效率和性能。 内存对齐的主要作用有以下几个方面：

  1. 提高访问效率：CPU 访问对齐的数据的速度是非对齐数据的速度的两倍。这是因为对于对齐的数据，CPU 可以通过一次内存读取操作就能够读取到所需的数据，而对于非对齐的数据，CPU 需要进行两次内存读取操作，从而造成额外的开销。
  2. 保证数据结构的正确性：内存对齐可以保证数据结构中的每个元素都被正确地存放在其应该存放的地址上，从而避免了数据被错误地访问或修改的情况。
  3. 与硬件的兼容性：一些硬件设备要求数据必须按照一定的规则和字节对齐方式存储，否则可能会引起硬件异常或错误。
  4. 提高缓存效率：CPU 的缓存系统通常也需要对数据进行对齐。如果数据没有按照对齐的方式存储，可能会造成缓存失效，从而降低程序的执行效率。 

  总之，内存对齐是一种优化技术，可以提高程序的执行效率和性能。在编写程序时，应该尽可能地遵循内存对齐的规则，从而使程序更加高效、稳定和可靠。

  先来看下内存对齐的规则：

  1. 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是min(#pragma pack()指定的数，这个数据成员的自身长度) 的倍数。#pragma pack(n) 表示设置为n字节对齐，VC6默认8字节对齐；

  2. 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

   ```c
  // 环境：vc6 + windows sp2
  #include <iostream>
  using namespace std;
  struct st1 {
      char a ;
      int  b ;
      short c ;
  };
  struct st2{
      short c ;
      char  a ;
      int   b ;
  };
  // sizeof(st1) is 12
  // sizeof(st2) is 8
   ```

  St1 ：char占一个字节，起始偏移为0 ，int 占4个字节，min(#pragma pack()指定的数，这个数据成员的自身长度) = 4（VC6默认8字节对齐），所以int按4字节对齐，起始偏移必须为4的倍数，所以起始偏移为4，在char后编译器会添加3个字节的额外字节，不存放任意数据。short占2个字节，按2字节对齐，起始偏移为8，正好是2的倍数，无须添加额外字节。到此规则1的数据成员对齐结束，此时的内存状态为：

  ```c
  oxxx|oooo|oo
  0123 4567 89 （地址）
  （x表示额外添加的字节）
  ```

  共占10个字节，还要继续进行结构本身的对齐。对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行，st1结构中最大数据成员长度为int，占4字节，而默认的#pragma pack 指定的值为8，所以结果本身按照4字节对齐，结构总大小必须为4的倍数，需添加2个额外字节使结构的总大小为12 。此时的内存状态为：

  ```c
  oxxx|oooo|ooxx
  0123 4567 89ab  （地址）
  ```

  到此内存对齐结束，St1占用了12个字节而非7个字节。St2 的对齐方法和st1相同，st2结构体总大小为8。

- 如何在 main 函数之前执行一些操作

  在 C++ 中，可以使用静态变量（static variable）和全局变量（global variable）来在 `main` 函数之前执行一些操作。因为静态变量和全局变量的初始化顺序是在 `main` 函数之前的。 

  具体来说，可以定义一个全局变量或静态变量，将其初始化为一个函数指针，在其构造函数中执行需要在 `main` 函数之前执行的操作。当程序启动时，全局变量和静态变量的构造函数会自动执行，从而实现在 `main` 函数之前执行一些操作。 

  下面是一个示例代码，演示了如何在 `main` 函数之前执行一些操作：

  ```c
  #include <iostream>
  using namespace std;
  class Init {
  public:
      Init() {
          cout << "Before main." << endl;
      }
  };
  Init init;
  int main() {
      cout << "In main." << endl;
      return 0;
  }
  ```

  在这个示例代码中，我们定义了一个 `Init` 类，将其实例化为一个全局变量 `init`，在其构造函数中输出一条消息。然后，我们定义了 `main` 函数，输出另一条消息。运行这个程序，输出结果如下：

  ```c
  Before main.
  In main.
  ```

  从输出结果可以看出，在 `main` 函数之前，全局变量 `init` 的构造函数已经执行了，输出了一条消息。这说明我们成功地在 `main` 函数之前执行了一些操作。

- explicit 的作用

  `explicit` 是 C++ 中的一个关键字，用于修饰单参构造函数或者转换函数，其作用是防止隐式转换，只能显式调用。

  举个例子，当我们在定义一个只有一个参数的构造函数时，有时候我们不希望这个构造函数被自动调用进行隐式转换，而是需要在使用的时候显式地调用它。这时候就可以使用 `explicit` 关键字进行修饰。 下面是一个示例代码，演示了 `explicit` 关键字的使用：

  ```c
  class A {
  public:
      A(int i) : m_i(i) {}
  private:
      int m_i;
  };
  void fun(A a) {
      // do something
  }
  int main() {
      A a1 = 10; // ok，隐式转换
      A a2(10); // ok，显式构造
      fun(10); // error，不能隐式转换为 A 类型
      fun(A(10)); // ok，显式构造
      return 0;
  }
  ```

  在上面的示例中，我们定义了一个类 `A`，它有一个带有 `int` 类型参数的构造函数。如果我们没有在构造函数前面加上 `explicit` 关键字，那么在 `main` 函数中，我们可以用整型常量值 `10` 隐式地创建一个 `A` 类型的对象 `a1`。但是，如果我们在构造函数前面加上 `explicit` 关键字，则不能用整型常量值隐式地创建 `A` 类型的对象，必须显式地调用构造函数。

  同时，如果我们定义了一个函数 `fun`，它的参数是 `A` 类型的对象，如果我们没有在构造函数前面加上 `explicit` 关键字，则函数 `fun` 的参数可以隐式地将整型常量值 `10` 转换为 `A` 类型的对象，但是如果我们在构造函数前面加上 `explicit` 关键字，则不能进行隐式转换，必须显式地调用构造函数。

- sizeof 和 strlen的区别

  1. strlen是一个库函数，使用时需要引用#include<string.h>这个头文件，而sizeof是一个运算符号；
  2. strlen计算的是'\0'之前的字符个数，sizeof计算的是所占空间内存的大小，单位是字节；
  3. strlen计算时不包含'\0'，而sizeof包含'\0'，strlen遇到'\0'才结束；
  4. strlen计算字符串的具体长度 (只能是字符串)，不包括字符串结束符，返回的是字符个数。
  5. strlen的参数是指针类型，所以传过来的参数为指针才对。

- 一个函数的形参是数组，在函数内部调用 sizeof 和 strlen 分别得到什么答案

  ```c
  #include <stdio.h>
  #include <string.h>
  
  void print_array(char arr[]) {
      printf("sizeof(arr) = %lu\n", sizeof(arr));
      printf("strlen(arr) = %lu\n", strlen(arr));
  }
  
  int main() {
      char str[] = "Hello, world!";
      printf("sizeof(str) = %lu\n", sizeof(str));
      printf("strlen(str) = %lu\n", strlen(str));
      print_array(str);
      return 0;
  }
  ```

  输出结果为：

  ```c
  sizeof(str) = 14
  strlen(str) = 13
  sizeof(arr) = 8
  strlen(arr) = 13
  ```

  在主函数中，我们定义了一个字符数组 str，并使用 sizeof 和 strlen 函数分别计算了其大小和长度。由于该数组包含了 14 个字符（包括结尾的空字符），因此 sizeof(str) 返回 14，而 strlen(str) 返回 13（不包括结尾的空字符）。

  接着，我们调用了一个名为 print_array 的函数，将数组 str 作为参数传递给该函数。在 print_array 函数内部，我们同样使用了 sizeof 和 strlen 函数来计算数组的大小和长度。由于数组形参在函数内部被解释为指向数组首元素的指针，因此 sizeof(arr) 返回的是指针的大小（通常是 8 字节，取决于系统的位数）。而 strlen(arr) 返回的仍然是原数组中第一个元素到空字符之间的字符个数，即 13。

  ```c
  #include <stdio.h>
  #include <string.h>
  
  void print_array(char arr[], int n) {
      printf("sizeof(arr) = %lu\n", sizeof(arr));
      printf("strlen(arr) = %lu\n", strlen(arr));
      for (int i = 0; i < n; i++) {
          printf("%c ", arr[i]);
      }
      printf("\n");
  }
  
  int main() {
      char str[10] = {'H', 'e', 'l', 'l', 'o'};
      printf("sizeof(str) = %lu\n", sizeof(str));
      printf("strlen(str) = %lu\n", strlen(str));
      print_array(str, 5);
      return 0;
  }
  ```

  输出结果为：

  ```c
  sizeof(str) = 10
  strlen(str) = 5
  sizeof(arr) = 8
  strlen(arr) = 5
  H e l l o
  ```

  在主函数中，我们定义了一个长度为 10 的字符数组 str，并使用 sizeof 和 strlen 函数分别计算了其大小和长度。由于该数组中只有 5 个元素被初始化，因此 sizeof(str) 返回 10，而 strlen(str) 返回 5（不包括结尾的空字符）。

  接着，我们调用了一个名为 print_array 的函数，将数组 str 作为参数传递给该函数，并传递了数组中实际被初始化的元素个数 5。在 print_array 函数内部，我们同样使用了 sizeof 和 strlen 函数来计算数组的大小和长度。由于数组形参在函数内部被解释为指向数组首元素的指针，因此 sizeof(arr) 返回的是指针的大小（通常是 8 字节，取决于系统的位数）。而 strlen(arr) 返回的仍然是原数组中第一个元素到空字符之间的字符个数，即 5。

  最后，我们在 print_array 函数内部使用 for 循环遍历了数组中实际被初始化的元素，并将其输出到控制台上。

- 在主函数中对一个指向字符串的指针分别调用sizeof 和 strlen分别得到什么答案

  1. 指针指向字符串数组的第一个元素：

  ```c
  #include <stdio.h>
  #include <string.h>
  
  int main() {
      char str_arr[] = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\0'};
      char *str_ptr = str_arr;
      printf("sizeof(str_ptr) = %lu\n", sizeof(str_ptr));
      printf("strlen(str_ptr) = %lu\n", strlen(str_ptr));
      return 0;
  }
  ```

  输出结果为：

  ```c
  sizeof(str_ptr) = 8
  strlen(str_ptr) = 13
  ```

  在主函数中，我们定义了一个字符数组 str_arr，并将其初始化为一个字符串。接着，我们定义了一个指向字符的指针 str_ptr，将其指向字符串数组的第一个元素。在调用 sizeof 和 strlen 函数时，指针被解释为指向字符串的指针，因此 sizeof(str_ptr) 返回指针类型的大小，而 strlen(str_ptr) 返回字符串的长度。

  2. 指针指向字符串常量：

  ```c
  #include <stdio.h>
  #include <string.h>
  
  int main() {
      char *str_ptr = "Hello, world!";
      printf("sizeof(str_ptr) = %lu\n", sizeof(str_ptr));
      printf("strlen(str_ptr) = %lu\n", strlen(str_ptr));
      return 0;
  }
  ```

  输出结果为：

  ```c
  sizeof(str_ptr) = 8
  strlen(str_ptr) = 13
  ```

  在主函数中，我们定义了一个指向字符串常量的指针 str_ptr。由于字符串常量存储在程序的只读数据段中，因此 sizeof(str_ptr) 返回指针类型的大小，而 strlen(str_ptr) 返回字符串的长度。

  3. 指针指向空字符串：

  ```c
  #include <stdio.h>
  #include <string.h>
  
  int main() {
      char *str_ptr = "";
      printf("sizeof(str_ptr) = %lu\n", sizeof(str_ptr));
      printf("strlen(str_ptr) = %lu\n", strlen(str_ptr));
      return 0;
  }
  ```

  输出结果为：

  ```
  sizeof(str_ptr) = 8
  strlen(str_ptr) = 0
  ```

  在主函数中，我们定义了一个指向空字符串的指针 str_ptr。在调用 sizeof 函数时，指针被解释为指向字符串的指针，因此返回指针类型的大小。而在调用 strlen 函数时，由于空字符串中没有任何字符（包括空字符），因此返回值为 0。

  需要注意的是，在处理指向字符串的指针时，必须保证指针指向的内存位置是有效的，并且字符串以空字符结尾。否则，调用 strlen 函数可能会访问到不属于该字符串的内存位置，导致程序出现未定义的行为。

- strcpy 与 memcpy 的区别

  1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等；
  2. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，如果空间不够，就会引起内存溢出。memcpy则是根据其第3个参数决定复制的长度；
  3. 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy，由于字符串是以“\0”结尾的，所以对于在数据中包含“\0”的数据只能用memcpy；
  4. 从s1复制字符串到s2。strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n>strlen(s1)时，给s2不够数的空间里填充“\0”（n为s2的空间大小）；当n<=strlen(s1)时，s2是没有结束符“\0”的，所以使用strncpy时，确保s2的最后一个字符是“\0”。

- memove和memcpy有什么区别

  memmove和memcpy是C++中的两个函数，它们的作用都是复制内存区块，但是它们有以下区别：

  1. 目标内存区域与源内存区域重叠时，memmove可以正确处理，而memcpy则不能。

  2. memmove的复制过程是从前往后进行，即使目标内存区域在源内存区域的后面，也是先将前面的数据复制过去，再将后面的数据复制过去。而memcpy则没有这个限制，可以从前往后复制，也可以从后往前复制。

  3. memmove的复制速度通常比memcpy慢，因为它要判断内存区域是否重叠，而memcpy则没有这个开销。

  总的来说，如果目标内存区域与源内存区域可能会重叠，应该使用memmove，否则使用memcpy。

- 函数重载，变量前有无const是否可以重载

  fun(int i) 和 fun(const int i)，不能重载。二者是一样的，是因为函数调用中存在实参和形参的结合。假如我们用的实参是 int a，那么这两个函数都不会改变 a 的值，这两个函数对于 a 来说是没有任何区别的，所以不能通过编译，提示重定义。

  fun(char *a) 和 fun(const char *a)，可以重载。因为 char *a 中 a 指向的是一个字符串变量，而 const char *a 指向的是一个字符串常量，所以当参数为字符串常量时，调用第二个函数，而当函数是字符串变量时，调用第一个函数。

  fun(char *a) 和fun(char * const a) ，不能重载。这两个都是指向字符串变量，不同的是 char *a 是指针变量 而 char const *a 是指针常量，这就和 int i 和 const int i 的关系一样了，所以也会提示重定义。

  int &i 和const int & i 也是可以重载的。对于引用，比如 int &i 和 const int & i 也是可以重载的，原因是第一个 i 引用的是一个变量，而第二个i引用的是一个常量，两者是不一样的，类似于上面指向变量的指针和指向常量的指针。

- volatile 能保证线程安全吗，不能的话怎么解决

  volatile 关键字是 C/C++ 中的一个类型修饰符，用于告诉编译器一个变量是易变的，需要在每次访问时重新读取。但是，volatile 关键字不能保证线程安全，因为它只能保证变量在多线程或多进程环境下的可见性，而不能保证原子性和有序性，因此在并发环境下使用 volatile 关键字仍然存在数据竞争和死锁等问题。

  为了解决线程安全问题，可以使用互斥锁、条件变量、原子操作等方法来保证数据的原子性和有序性，避免数据竞争和死锁问题。互斥锁是一种常用的线程同步机制，可以保证在同一时刻只有一个线程可以访问共享资源，从而避免数据竞争问题。条件变量可以用来等待共享资源的状态改变，原子操作可以保证对共享变量的操作是不可分割的，从而避免数据竞争和死锁问题。

  总之，volatile 关键字不能保证线程安全，需要采用其他的线程同步机制来保证数据的原子性和有序性，避免数据竞争和死锁问题。

- struct 和 union 区别

  struct 和 union 都是 C/C++ 中的数据类型，它们的主要区别在于存储方式和内存使用方式：

  struct 是一种自定义的数据类型，可以包含多个不同类型的成员变量，每个成员变量占用独立的内存空间，结构体的大小等于所有成员变量的大小之和，不同成员变量之间没有关联。

  union：union 也是一种自定义的数据类型，可以包含多个不同类型的成员变量，但只有一个成员变量可以被赋值和访问，不同成员变量共享同一块内存空间，共用一个内存地址，结构体的大小等于最大的成员变量的大小。因此，union 可以节省内存空间，但存在数据安全问题，因为不同的成员变量共用同一块内存空间，修改一个成员变量的值可能会影响其他成员变量的值，而 struct 没有这个问题。 

- 头文件中 #ifdef，#endif 有什么作用

  避免头文件被重复引用。在一个大型软件工程编写code，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量重定义的错误。在头文件中实用#ifndef #define #endif能避免头文件的重定义。

  如编写头文件ArrayList.h，在头文件开头写上两行：

  ```c
  #ifndef _Array_List_h
  #define ArrayList.h //一般是文件名的大写
  ```

  头文件结尾写上一行：#endif，这样一个工程文件里同时包含两个ArrayList.h时，就不会出现重定义的错误了。

  分析：当第一次包含ArrayList.h时，由于没有定义_Array_List_h，条件为真，这样就会包含（执行）#ifndef _Array_List_h和#endif之间的代码，当第二次包含test.h时前面一次已经定义了_Array_List_h，条件为假，#ifndef _Array_List_h和#endif之间的代码也就不会再次被包含，这样就避免了重定义了。主要用于防止重复定义宏和重复包含头文件。

- 模板的编译过程，模板是什么时候实例化的

  模板是 C++ 中的一种特殊的类型，它的编译过程和普通的函数或类的编译过程有所不同。模板的编译分为两个阶段：声明和实例化。

  声明阶段：在源代码中定义模板时，编译器只会对模板进行语法和类型检查，不会生成任何代码。在编译器遇到使用模板的语句时，只会对模板进行简单的语法检查，然后将其标记为待实例化。

  实例化阶段：当编译器需要生成实际的代码时，会根据使用模板的具体情况实例化模板。也就是说，模板是在使用时才进行实例化。实例化的过程包括将模板中的类型参数替换为具体的类型，生成对应的代码，并进行编译和链接，生成可执行文件。

   总之，模板的编译过程分为声明阶段和实例化阶段。模板只有在使用时才会进行实例化，根据具体的类型参数生成对应的代码。

- #include<> 和 #include"" 的区别

  1. 引用的头文件不同。#include< >引用的是编译器的类库路径里面的头文件；#include“ ”引用的是你程序目录的相对路径中的头文件。
  2. 用法不同。#include< >用来包含标准头文件(例如stdio.h或stdlib.h)；#include“ ”用来包含非标准头文件。
  3. 调用文件的顺序不同。#include< >编译程序会先到标准函数库中调用文件；#include“ ”编译程序会先从当前目录中调用文件。
  4. 预处理程序的指示不同。#include< >指示预处理程序到预定义的缺省路径下寻找文件；#include“ ”指示预处理程序先到当前目录下寻找文件，再到预定义的缺省路径下寻找文件。

- free 和 delete 的区别

  `free`和`delete`都可以用于释放动态分配的内存，但它们之间有几个重要的区别：

  1. 动态分配方式不同：`new`和`malloc`是不同的内存分配方式，对应的释放操作也不同。`delete`用于释放使用`new`分配的内存，`free`用于释放使用`malloc`分配的内存。

  2. 对象销毁方式不同：`delete`操作除了释放内存以外，还会自动调用对象的析构函数，从而保证对象被正确销毁；而`free`只会释放内存，不会调用任何对象的析构函数。

  3. 参数类型不同：`free`仅接受`void*`类型的指针作为参数，而`delete`需要传入指向动态分配的对象的指针。

  4. 风险不同：使用`delete`可避免出现忘记释放内存的情况，因为`delete`的语义已经包含了释放内存的操作。而`free`则需要程序员显式地调用才能释放内存，容易出现遗漏的情况，从而引发内存泄漏等问题。

  因此，在C++中，应该优先使用`new/delete`，而不是使用`malloc/free`。不过，对于C语言开发者来说，由于`new/delete`是C++特有的操作符，因此在C项目中还是需要使用`malloc/free`来分配和释放内存。

- 空指针和野指针的区别

  - 指向的地址为空的指针是空指针；
  - 指向的地址是不可知的、随机的、没有明确限制的指针是野指针；

  1. 指针未初始化；2. 指针越界访问；3. 指针指向的空间释放。

- 什么是野指针，怎么检测

  野指针是指指向无效内存地址的指针。这通常发生在指针被释放或初始化之前，或者指针指向的对象已经被销毁或移动了。当程序访问野指针时，可能会导致程序崩溃、数据损坏、安全漏洞等问题。

  检测野指针可以通过以下方法：

  1. 编译器选项：现代编译器通常提供一些开关来检测野指针，如gcc的"-Wuninitialized"选项可以检测未初始化的变量和指针。

  2. 静态分析工具：静态分析工具可以扫描代码并检测潜在的野指针问题。例如，Clang Static Analyzer、Coverity等工具都提供了野指针的检测功能。

  3. 动态调试工具：动态调试工具可以在程序运行时检测野指针。例如，Valgrind是一款常用的动态调试工具，可以检测内存泄漏、野指针等问题。

  总之，尽可能避免野指针的出现是最好的方法，可以通过合理的内存管理、指针初始化等方式来减少野指针问题的发生。

- 在一台内存为 2G 的机器上，使用 malloc 分配 20G 会发生什么，new 20G 呢

  在一台内存为2G的机器上，使用malloc分配20GB内存会导致分配失败，因为需要的内存空间已经超出了可用的物理内存大小，malloc会返回NULL指针，表明分配失败。

  而对于new操作符，如果使用的是标准的C++库，那么在同样的情况下也无法成功分配20GB内存，它会抛出std::bad_alloc异常。但是，某些实现可能会尝试通过申请虚拟内存来满足请求，这可能会导致系统变得非常慢，甚至崩溃。

  需要注意的是，即使内存分配成功了，也要确保能够在程序中正确和及时地释放这些内存，否则可能导致内存泄漏等问题。通常情况下，应该在动态分配内存后，及时释放不再需要的内存，以便其他程序可以使用这些内存空间。

  总之，为了避免这种情况的发生，应该在编写程序时仔细估计所需的内存量，并尽可能地避免过多地申请内存空间。另外，在分配内存之前，还可以通过查询可用内存或进行内存回收等操作来提高系统可用内存的效率。

- 函数栈空间的大小是多大

  在大多数现代操作系统中，函数栈空间的大小通常在 1MB 左右，但是这个大小可以通过编译器或操作系统的配置进行修改。例如，在 Linux 系统中，可以使用 ulimit 命令来修改进程的堆栈大小限制。

- 全局变量定义在头文件中有什么问题

  在头文件中定义全局变量可能会导致重复定义错误。因为当多个C++源文件包含同一个头文件时，其中的全局变量会在每个源文件中都被定义一次。

  例如，在头文件`globals.h`中定义了一个全局变量`int x = 0;`，并在C++源文件`file1.cpp`和`file2.cpp`中分别包含`globals.h`头文件进行编译。则在编译时，由于`globals.h`被包含了两次，全局变量`x`也被定义了两次，这将导致重复定义错误。

  为避免这种错误，通常建议在头文件中使用`extern`关键字声明全局变量，并在一个C++源文件中定义它。例如，在`globals.h`头文件中可以声明`extern int x;`，而在`globals.cpp`源文件中定义`int x = 0;`。这样，任何需要使用全局变量`x`的源文件只需要包含`globals.h`头文件即可。

  总之，尽管在C++中允许在头文件中定义全局变量，但为了避免重复定义错误，通常应该在头文件中使用`extern`关键字声明全局变量，并在一个源文件中定义它。

- c++11 中可以用什么特性替换单例模式中的 static 写法？

  在C++11标准中，可以使用局部静态变量（local static variable）来替代单例模式中的静态变量写法。这种实现方法也被称为"Meyers Singleton"，它具有如下特点：

  1. 只有在第一次访问单例对象时才会创建该对象，避免了懒汉式单例中可能存在的线程安全问题；
  2. 局部静态变量在多线程环境下自动初始化，并且保证了初始化过程的线程安全性。

  下面是一个使用局部静态变量实现的单例类的示例代码：

  ```c
  class Singleton {
  public:
      static Singleton& getInstance() {
          static Singleton instance; // 局部静态变量，只在首次调用时初始化
          return instance;
      }
  
      void doSomething() {
          // ...
      }
  
  private:
      Singleton() = default;
      ~Singleton() = default;
      Singleton(const Singleton&) = delete;
      Singleton& operator=(const Singleton&) = delete;
  };
  ```

  在上述代码中，`getInstance()`函数返回一个引用类型的`Singleton`对象，其中`instance`是一个局部静态变量，只在第一次调用时初始化。由于局部静态变量的初始化过程是线程安全的，因此这种实现方式避免了懒汉式单例中可能存在的线程安全问题。同时，该实现方式也避免了饿汉式单例中可能存在的静态初始化顺序问题。

  需要注意的是，为了防止单例被复制或移动，上述代码将拷贝构造函数和赋值运算符声明为删除函数。此外，为了防止单例在程序结束前被销毁，通常将析构函数声明为`default`以使用默认行为。

- g++如何链接动态库，如何生成动态库，库和二进制文件分别在哪些目录

  1. 链接动态库：

  在编译时使用`-l`选项指定动态库的名称，同时使用`-L`选项指定动态库所在的目录。例如，链接名为`libexample.so`的动态库，可以使用以下命令：

  ```
  g++ main.cpp -o main -l example -L /path/to/lib/
  ```

  2. 生成动态库：

  使用`-shared`选项生成动态库，例如：

  ```
  g++ -shared -o libexample.so example.cpp
  ```

  3. 库和二进制文件分别在哪些目录：

  一般情况下，库文件会被安装到`/usr/lib`或`/usr/local/lib`目录下，而二进制文件则被安装到`/usr/bin`或`/usr/local/bin`目录下。但是在开发过程中，库和二进制文件可以放在任何目录下，只需要在编译时使用`-L`选项指定库所在的目录即可。

- 如果我 new 了一个内存，然后在 delete 之前这个进程被系统杀死了，那这样是内存泄露吗？

  是的，如果程序在使用 `new` 动态分配内存后，未使用 `delete` 释放该内存，并且进程在释放该内存之前被系统杀死，那么这就是一种内存泄漏现象。因为当进程被杀死时，它占用的所有内存都被操作系统回收，但由于该内存未被释放，因此操作系统无法回收这部分内存，导致内存泄漏。

  内存泄漏是一种非常严重的问题，可能导致内存资源的耗尽和程序运行效率的降低。为了避免内存泄漏，我们需要在程序中养成良好的内存管理习惯，及时释放不再使用的内存空间，从而提高程序的稳定性和可靠性。

- malloc分配的是虚拟内存还是物理内存？

  malloc分配的是虚拟内存。

  虚拟内存是一种抽象概念，它使得应用程序可以访问比物理内存更大的地址空间。虚拟内存由操作系统负责管理，在应用程序看来，它是一段连续的地址空间，而实际上，这些地址空间可能分散在物理内存和硬盘上。

  当调用malloc函数时，操作系统会分配一段虚拟内存，并将其映射到物理内存或者硬盘上。如果物理内存中有空闲的空间，那么虚拟内存就会被映射到物理内存中。如果物理内存中没有足够的空间，那么虚拟内存就会被映射到硬盘上，并且在需要访问这段虚拟内存时，操作系统会将其从硬盘中读入到物理内存中。

  由于操作系统负责管理虚拟内存和物理内存的映射关系，因此应用程序不需要关心虚拟内存和物理内存的具体细节。应用程序只需要使用malloc函数来分配虚拟内存，然后使用指针来访问这段虚拟内存即可。

  需要注意的是，虚拟内存的分配和释放是由操作系统负责的，而不是由应用程序负责的。因此，在使用malloc函数分配内存时，应用程序不需要关心内存的具体分配情况，只需要确保在使用完毕后及时调用free函数释放内存即可。

- memset操作malloc的指针，是操作物理内存还是虚拟内存？

  memset函数是C标准库中的一个函数，用于将一段内存空间中的数据全部设置为指定的值。memset函数的原型如下：

  ```c
  void *memset(void *s, int c, size_t n);
  ```

  其中，参数`s`是指向要设置的内存空间的指针，参数`c`是要设置的值，参数`n`是要设置的内存空间大小。

  当调用memset函数时，它会将指定的虚拟内存地址中的数据全部设置为指定的值。也就是说，memset函数不关心数据存储在物理内存还是硬盘上，它只关心数据存储在虚拟内存中的哪个位置。

  虚拟内存是一种在操作系统中实现的内存管理技术。它使得每个应用程序都能够看到一段连续的地址空间，而实际上这些地址空间可能分散在物理内存和硬盘上。虚拟内存的出现解决了物理内存不足的问题，让应用程序能够使用比物理内存更大的内存空间。

  当调用malloc函数分配内存时，操作系统会分配一段虚拟内存，并将其映射到物理内存或者硬盘上。当调用memset函数时，它会将指定的虚拟内存地址中的数据全部设置为指定的值。也就是说，memset函数实际上是操作虚拟内存中的数据。

  需要注意的是，由于虚拟内存和物理内存之间的映射关系是由操作系统负责管理的，因此memset函数实际上不一定会直接修改物理内存中的数据。当调用memset函数时，操作系统会将虚拟内存中的数据拷贝到物理内存中，然后再进行修改。这个过程是透明的，应用程序无需关心数据存储在物理内存还是虚拟内存中。

  需要注意的是，在使用memset函数时，应该确保指定的内存空间已经被分配，否则可能会出现未定义的行为。此外，应该避免使用memset函数来修改指向常量的指针或者指向未定义的内存空间的指针，否则可能会导致程序崩溃或者出现其他问题。

- share-ptr 销毁了但还有 weak-ptr 指向那个对象，weak-ptr 怎么知道这个对象已销毁

  当使用`std::shared_ptr`智能指针时，可以通过创建`std::weak_ptr`弱指针来解决循环引用问题。当`std::shared_ptr`指向的对象被销毁后，如果仍有`std::weak_ptr`指向该对象，那么这些`std::weak_ptr`指针会自动变为空指针，避免了悬垂指针的问题。

  在实际使用中，可以通过`std::weak_ptr`的`expired()`方法来检查该对象是否已经被销毁。如果`expired()`方法返回`true`，说明这个对象已经被销毁，弱指针不再指向有效的对象；如果`expired()`方法返回`false`，说明这个对象仍然存在，弱指针仍然指向有效的对象。

  例如，假设有一个`std::shared_ptr`对象`sp`，它指向一个对象，同时还有一个`std::weak_ptr`对象`wp`也指向同一个对象。当`sp`被销毁后，可以通过`wp.expired()`方法来检查该对象是否已经被销毁，代码如下：

  ```c
  std::shared_ptr<int> sp(new int(42));
  std::weak_ptr<int> wp(sp);
  
  sp.reset();   // 销毁 std::shared_ptr 智能指针
  
  if (wp.expired()) {
      std::cout << "对象已经被销毁" << std::endl;
  } else {
      std::cout << "对象仍然存在" << std::endl;
  }
  ```

  在上述代码中，`sp.reset()`语句销毁了`std::shared_ptr`智能指针，此时可以通过`wp.expired()`方法来检查对象是否已经被销毁。如果返回`true`，说明对象已经被销毁；如果返回`false`，说明对象仍然存在。

  需要注意的是，如果要使用`std::weak_ptr`来检查对象是否已经被销毁，那么在创建`std::weak_ptr`时，必须使用`std::shared_ptr`的`shared_from_this()`方法来创建。这是因为，只有通过`shared_from_this()`方法创建的`std::shared_ptr`对象，才能正确地管理指向同一个对象的所有`std::shared_ptr`和`std::weak_ptr`指针。

- override和overload的区别

  `override` 和 `overload` 都是 C++ 中的关键字，但它们的含义和用法有所不同。

  1. `override`：是 C++11 引入的一个关键字，用于表示派生类中的虚函数覆盖了基类中的虚函数。在派生类中使用 `override` 关键字可以明确表示当前函数为虚函数的重写，提高代码的可读性和可维护性。示例代码如下：

     ```c
     class Base {
     public:
         virtual void foo();
     };
     
     class Derived : public Base {
     public:
         void foo() override;  // 重写基类中的虚函数
     };
     ```

  2. `overload`：是 C++ 中的一个概念，表示在同一个作用域内，可以定义多个名称相同但参数类型和个数不同的函数。函数重载可以提高代码的可读性和可维护性，同时允许不同类型的参数使用相同的函数名。示例代码如下：

     ```c
     void foo(int x);
     void foo(double x);
     void foo(int x, double y);
     ```

  总之，`override` 和 `overload` 都是 C++ 中的关键字，但它们的用法和含义有所不同。`override` 用于表示派生类中的虚函数覆盖了基类中的虚函数，提高代码的可读性和可维护性；`overload` 用于表示在同一个作用域内，可以定义多个名称相同但参数类型和个数不同的函数，提高代码的可读性和可维护性，同时允许不同类型的参数使用相同的函数名。

- 浮点数0.3能精确表达吗？有没有简易的方式判断浮点数能不能精确表达？

  浮点数 0.3 不能用二进制精确地表示，因为在二进制中，0.3 无限循环。这是因为浮点数在计算机中以二进制形式存储，而二进制的小数表示方式有时与十进制不同，因此可能会导致精度损失。

  在 C++ 中，可以使用头文件 `<cmath>` 中的 `std::fabs` 函数来判断两个浮点数之间的差值是否小于某个阈值，从而判断浮点数是否精确。示例代码如下：

  ```c
  #include <cmath>
  
  bool is_equal(float x, float y) {
      const float epsilon = 1e-5;
      return std::fabs(x - y) < epsilon;
  }
  
  int main() {
      float a = 0.3f;
      float b = 0.1f + 0.1f + 0.1f;
      if (is_equal(a, b)) {
          // a 和 b 在精度范围内相等
      } else {
          // a 和 b 不相等
      }
      return 0;
  }
  ```

  在上述代码中，`is_equal` 函数用于比较两个浮点数之间的差值是否小于某个阈值 `epsilon`，如果小于，则认为两个浮点数是相等的。需要注意的是，这种方法只是判断浮点数是否在某个误差范围内相等，不能完全解决浮点数精度问题，因此在实际应用中需要根据具体情况进行处理。

- extern变量在哪个数据段

  extern关键字用于声明一个在其他文件中定义的全局变量，它的作用是告诉编译器该变量的存在，但是并不分配内存空间，因此在定义extern变量时不需要指定初始值。

  extern变量在编译阶段并不会分配内存空间，而是在链接阶段进行内存分配。因此，extern变量可以在多个文件中使用，但是必须在某个文件中定义该变量，否则会出现链接错误。

  在内存中，所有的全局变量都会被分配到静态数据段，包括已经初始化的全局变量、未初始化的全局变量以及extern变量。静态数据段通常也被称为BSS段或者数据段。其中，已经初始化的全局变量存储在数据段中，而未初始化的全局变量和extern变量则存储在BSS段中。

  在程序运行时，数据段和BSS段都会被加载到进程的虚拟地址空间中，因此extern变量也会被分配到静态数据段或BSS段中。具体分配到哪个段取决于变量的类型和初始化状态，如果变量已经被初始化，则分配到数据段中，否则分配到BSS段中。

  总的来说，extern变量在内存中分配的数据段取决于变量的类型和初始化状态，通常情况下会被分配到静态数据段或BSS段中。

- 一个数组a[20][10]的首地址是100，问a[11][5]的地址是多少？

  由于a是一个二维数组，每个元素的大小为sizeof(int) * 10，因此a[11][5]的地址可以通过以下公式计算：

  地址 = 首地址 + (11 * 10 + 5) * sizeof(int)

  其中，11 * 10 + 5是a[11][5]在数组中的偏移量，乘以sizeof(int) * 10是为了跨越前面的行。根据题意，首地址为100，因此代入公式计算可得：

  地址 = 100 + (11 * 10 + 5) * sizeof(int) = 100 + 1150 * 4 = 4700

  因此，a[11][5]的地址是4700。

- Linux端⼝范围

  Linux 系统有 65,536 个端口（Port），它们被分成两类：系统端口和动态端口。

  系统端口是指 0 到 1023 的端口号，它们被预留给一些常见的网络服务，如 HTTP (80)、SSH (22)、FTP (21)、SMTP (25) 等等。这些端口只有管理员权限的用户才能使用。

  动态端口是指 1024 到 65535 的端口号，它们不被预留给任何特定的服务，而是由操作系统动态分配给客户端程序使用。当一个客户端程序需要与服务器进行通信时，它会随机选择一个可用的动态端口作为源端口，然后将目标端口设置为服务器所使用的服务端口，以此建立连接。

  需要注意的是，使用端口号时应避免使用 0 到 1023 之间的系统端口，因为这些端口已经被预留给特定的服务，如果被其他程序占用就会导致冲突。而使用动态端口则可以避免这种冲突。

- dynamic_cast讲⼀讲，如果指针类型是基类，转换为⼦类后，指针地址改变吗

  `dynamic_cast` 是 C++ 中的一种类型转换操作符，它主要用于将一个基类指针或引用转换为派生类指针或引用。这个转换过程是在运行时进行的，因此会检查转换的安全性，并在转换失败时返回空指针或抛出 `std::bad_cast` 异常。

  `dynamic_cast` 的语法如下：

  ```c
  dynamic_cast<Derived*>(base_pointer);
  ```

  其中，`base_pointer` 是一个指向基类对象的指针，`Derived` 是一个派生类类型。如果 `base_pointer` 指向的对象是派生类对象，则返回一个指向该派生类对象的指针；否则返回空指针。

  需要注意的是，如果 `base_pointer` 指向的对象不是派生类对象，那么使用 `dynamic_cast` 进行转换会导致未定义行为。因此，在使用 `dynamic_cast` 进行类型转换时，需要保证基类指针指向的对象是派生类对象，或者使用 `dynamic_cast` 的返回值进行判断。

  至于转换后指针地址是否改变，答案是：取决于派生类对象的布局。如果派生类对象中包含了基类对象的部分或全部成员，那么从基类指针转换为派生类指针后，指针地址不会改变，因为派生类对象的地址等于基类对象的地址加上偏移量。如果派生类对象中没有包含基类对象的成员，那么转换后的指针地址可能会发生改变。无论指针地址是否改变，转换后的指针都可以用于访问派生类对象的成员。

- 使⽤dynamic_cast进⾏指针类型转换的类中需定义什么

  使用 `dynamic_cast` 进行指针类型转换，需要满足以下两个条件：

  1. 基类需要定义虚函数

  在 C++ 中，动态类型转换是通过运行时类型信息（RTTI）来实现的。RTTI 是指运行时对类型信息进行识别和处理的机制，其中最重要的机制就是虚函数表（Virtual Table）。

  在 C++ 中，只有含有虚函数的类才会存在虚函数表，因此使用 `dynamic_cast` 进行类型转换时，需要确保基类至少有一个虚函数。

  2. 派生类需要公开继承自基类

  使用 `dynamic_cast` 进行类型转换时，需要保证基类和派生类之间是公开继承关系，即使用 `public` 关键字进行继承。

  这是因为 `dynamic_cast` 只能用于基类和派生类之间的转换，而且只能用于公开继承关系。如果基类和派生类之间是私有继承或保护继承关系，那么不能使用 `dynamic_cast` 进行类型转换。

  综上所述，使用 `dynamic_cast` 进行指针类型转换，需要在基类中定义虚函数，并且要求派生类公开继承自基类。

- free() 函数入参是一个void*指针，它是如何知道被指向的大小的？

  在C语言中，`free()`函数并不知道被释放内存块的大小。当你调用`malloc()`函数来分配内存时，`malloc()`会在内部维护一些额外的信息，例如分配的内存块的大小。这些信息通常存储在内存块的头部，可以用指针运算来访问。

  当你调用`free()`函数时，它会将指向被释放内存块头部的指针传递给内存管理器。内存管理器使用这个指针来查找被释放的内存块，并将其标记为可用。内存管理器不需要知道被释放内存块的大小，因为它已经在内存块头部保存了这个信息。

  注意，在释放内存块之前，你应该确保该内存块是通过`malloc()`、`calloc()`或`realloc()`等函数分配的。如果你试图释放一个不是通过这些函数分配的内存块，那么`free()`函数的行为是未定义的，可能会导致程序崩溃或其他问题。

- weak_ptr指向的对象可不可以访问类的成员函数

  可以访问类的公共成员函数，但不能访问类的私有成员函数。

  weak_ptr是一种智能指针，用于解决shared_ptr的循环引用问题。它与shared_ptr类似，也可以指向堆上的对象，并且可以通过lock()函数获取一个shared_ptr对象。与shared_ptr不同的是，weak_ptr不会增加对象的引用计数，因此可以避免循环引用导致内存泄漏的问题。

  在使用weak_ptr时，可以通过lock()函数获取一个指向堆上对象的shared_ptr，然后使用该shared_ptr来访问对象的公共成员函数。例如：

  ```c
  #include <iostream>
  #include <memory>
  
  using namespace std;
  
  class MyClass {
  public:
      void func() {
          cout << "Hello, world!" << endl;
      }
  };
  
  int main() {
      shared_ptr<MyClass> sp = make_shared<MyClass>();
      weak_ptr<MyClass> wp = sp;
  
      if (auto p = wp.lock()) {
          p->func();  // 可以访问公共成员函数func()
      }
  
      return 0;
  }
  ```

  在上面的示例代码中，我们创建了一个MyClass的对象，并将其指针保存在shared_ptr中，然后又使用weak_ptr指向该对象。在使用lock()函数获取shared_ptr对象之后，可以通过该对象来访问公共成员函数func()。

  需要注意的是，由于weak_ptr不增加对象的引用计数，因此如果对象已经被释放，使用lock()函数获取的shared_ptr将会为空指针，此时访问成员函数会导致运行时错误。因此，在使用weak_ptr时，需要先检查获取的shared_ptr是否为空指针，然后再进行访问。

- weak_ptr转shared_ptr指针哪些情况下可能会失效？

  在使用weak_ptr转换为shared_ptr时，由于weak_ptr不会增加对象的引用计数，因此需要注意以下几种情况，可能会导致转换后的shared_ptr失效：

  1. 对象已经被释放：如果对象已经被释放，那么使用weak_ptr转换为shared_ptr时将会返回一个空指针，访问该指针的成员函数将会导致运行时错误。

  2. 同一个对象存在多个weak_ptr：如果同一个对象存在多个weak_ptr，而且这些weak_ptr都转换为了shared_ptr，那么可能会导致对象被多次释放，从而导致转换后的shared_ptr失效。

  3. 由于指针误用而导致的对象被释放：如果在对象被释放之前，使用了不正确的指针或者访问了已经释放的内存，那么可能会导致对象被提前释放，从而导致转换后的shared_ptr失效。

  为了避免这些问题，可以在使用weak_ptr转换为shared_ptr时，先检查转换后的shared_ptr是否为空指针，然后再进行访问。例如：

  ```c
  #include <iostream>
  #include <memory>
  
  using namespace std;
  
  class MyClass {
  public:
      void func() {
          cout << "Hello, world!" << endl;
      }
  };
  
  int main() {
      shared_ptr<MyClass> sp = make_shared<MyClass>();
      weak_ptr<MyClass> wp = sp;
  
      if (auto p = wp.lock()) {
          p->func();  // 可以访问公共成员函数func()
      }
      else {
          cout << "Object has been destroyed!" << endl;
      }
  
      return 0;
  }
  ```

  在上面的示例代码中，我们在使用lock()函数获取shared_ptr之前，先判断其是否为空指针，以避免使用已经被释放的内存。如果shared_ptr不为空指针，就可以使用该指针来访问对象的成员函数了。

- 局部变量和全局变量的区别？

  局部变量和全局变量是两种不同的变量类型，它们的作用域和生命周期有所不同。

  1. 作用域：局部变量的作用域限定在定义它的代码块中，例如函数、循环、条件语句等。一旦离开该代码块，局部变量就无法访问。而全局变量的作用域可以跨越多个代码块，包括多个函数和文件。

  2. 生命周期：局部变量的生命周期与其所在的代码块相同，一旦程序离开该代码块，局部变量的内存空间就会被释放。相比之下，全局变量的生命周期与整个程序运行期间相同，它们在程序启动时被创建，在程序结束时被销毁。

  3. 存储位置：局部变量通常存储在栈上，而全局变量通常存储在静态数据区中。栈是一种自动分配和释放内存的数据结构，而静态数据区是在程序启动时由操作系统分配的一块内存区域。

  4. 初始化：局部变量的初始化可以在定义时进行，也可以在代码块中进行。而全局变量的初始化只能在定义时进行。

  需要注意的是，全局变量的使用应该谨慎，因为它们可能会引起命名冲突和程序的不可预测性。为了避免这些问题，应该尽可能使用局部变量，只在必要时才使用全局变量。

- 全局变量未初始化时为什么是随机值？

  在C/C++中，未显式初始化的全局变量其初始值是未定义的（Undefined）。因为全局变量存储在静态数据区中，其初始值是在程序运行前由编译器和链接器确定的。如果未显式初始化，编译器和链接器并不会为该变量赋一个特定的初始值，而是将它的初始值留给了静态数据区中储存该变量的内存位置上的值。

  由于这块内存区域在程序启动时并不会被清空，因此其中可能会存在一些先前被其他程序或者操作系统使用过的数据，这些数据可能被误认为是全局变量的初始值。因此，未初始化的全局变量的初始值往往是一些随机的、未知的值，这些值取决于该内存区域之前被使用过的数据。

  需要注意的是，尽管未初始化的全局变量的初始值是未定义的，但是它们在内存中占据的位置是被保留的。所以，在程序运行中，即使没有对未初始化的全局变量进行赋值，也可以通过指针等方式来访问该变量，因为它已经在内存中被分配了一个位置。

  为了避免未初始化的全局变量带来的问题，应该在定义时显式初始化所有全局变量，或者将其定义为静态局部变量并在函数内部进行初始化。这样可以保证全局变量的初始值是可控的，而不会带来不确定性。

- 两个浮点数如何比较大小？

  在C/C++中，可以使用比较运算符（>, <, >=, <=, ==, !=）来比较两个浮点数的大小。但是，由于浮点数是以二进制形式表示的，而二进制数不能精确地表示所有的十进制数，因此可能会出现精度误差，导致比较结果不准确。

  为了避免精度误差，应该使用一些特殊的函数来比较浮点数。常用的函数包括以下几种：

  1. fabs()函数：该函数返回一个浮点数的绝对值。

  2. fpclassify()函数：该函数返回一个浮点数的类型，例如正无穷、负无穷、NaN、零、非零等。

  3. isfinite()函数：该函数判断一个浮点数是否为有限数，即不是正无穷、负无穷或NaN。

  4. isgreater()和isless()函数：这两个函数用于比较两个浮点数的大小，可以处理NaN和无穷大的情况。

  需要注意的是，以上函数只是为了提高比较浮点数大小的精度和准确性，但并不能完全避免精度误差。在实际应用中，如果需要比较浮点数的大小，应该先确定精度要求，再根据具体情况选择合适的比较方法。

  isgreater()和isless()函数是C++11引入的新函数，用于比较两个浮点数的大小。这两个函数可以处理NaN和无穷大的情况，从而提高比较的精度和准确性。

  isgreater()函数用于比较第一个参数是否大于第二个参数，语法如下：

  ```c
  bool isgreater(float x, float y);
  bool isgreater(double x, double y);
  bool isgreater(long double x, long double y);
  ```

  isless()函数用于比较第一个参数是否小于第二个参数，语法如下：

  ```c
  bool isless(float x, float y);
  bool isless(double x, double y);
  bool isless(long double x, long double y);
  ```

  这些函数返回的是一个bool类型的值，如果第一个参数大于（或小于）第二个参数，则返回true，否则返回false。

  例如，以下代码演示了如何使用isgreater()函数来比较两个浮点数的大小：

  ```c
  #include <iostream>
  #include <cmath>
  using namespace std;
  
  int main() {
      float x = 1.2, y = 3.4;
      if (isgreater(x, y)) {
          cout << "x is greater than y" << endl;
      } else {
          cout << "x is not greater than y" << endl;
      }
  
      return 0;
  }
  ```

  这段代码中，使用isgreater()函数比较x和y的大小，如果x大于y，则输出"x is greater than y"，否则输出"x is not greater than y"。

  需要注意的是，isgreater()和isless()函数比较浮点数大小时，也可能存在精度误差。因此，在比较浮点数大小时，应该根据具体情况选择合适的比较方法，以确保比较的准确性和精度。

- char arr[20]和char *p = new char[20]的区别？初始化和未初始化的情况？放在内存的哪个位置？

  `char arr[20]`和`char *p = new char[20]`都可以用来分配20个char类型的内存空间，但是它们有几个区别：

  1. 内存分配方式不同：`char arr[20]`是在栈上分配内存空间，而`char *p = new char[20]`是在堆上分配内存空间。

  2. 可以被复制和赋值的方式不同：`char arr[20]`是一个数组，不能直接进行赋值和复制操作，但是可以用memcpy()等函数进行复制。而`char *p = new char[20]`是一个指向char类型的指针，可以进行复制和赋值操作。

  3. 生命周期不同：`char arr[20]`的生命周期与其所在的函数或代码块相同，当函数或代码块执行完毕时，该数组会自动释放。而`char *p = new char[20]`的生命周期与调用delete运算符的时刻有关，需要手动释放内存空间，否则会导致内存泄漏。

  在初始化和未初始化的情况下，`char arr[20]`和`char *p = new char[20]`的行为也有所不同：

  1. 未初始化的情况：`char arr[20]`未初始化时，数组中的元素值是未定义的，即可能是任意值。而`char *p = new char[20]`未初始化时，分配的内存空间中的元素也是未定义的。

  2. 初始化的情况：`char arr[20]`可以在定义时进行初始化，例如`char arr[20] = "hello world";`。而`char *p = new char[20]`需要使用赋值语句或者memcpy()函数进行初始化，例如`memcpy(p, "hello world", 12);`。

  无论是`char arr[20]`还是`char *p = new char[20]`分配的内存空间都是在进程的虚拟地址空间中，但是它们所在的区域不同。`char arr[20]`分配的内存空间通常位于栈上，而`char *p = new char[20]`分配的内存空间位于堆上。在堆上分配的内存空间需要手动释放，否则会导致内存泄漏。

- C++内存分配有哪几种方式？画出C++内存布局图？

  C++内存分配的主要方式有以下几种：

  1. 栈内存分配：栈是一种后进先出（LIFO）的数据结构，用于存储局部变量和函数调用的上下文信息。当函数被调用时，其局部变量和参数会被分配到栈上，当函数返回时，栈上的内存空间会被自动释放。栈内存分配是一种快速且自动化的内存分配方式，但是其分配的内存空间大小通常受到限制，可能会导致栈溢出的问题。

  2. 堆内存分配：堆是一种动态分配的内存空间，用于存储动态创建的对象和数据结构。堆内存的分配和释放需要通过new和delete等运算符进行操作。堆内存分配的优点是可以动态地分配和释放内存空间，但是需要手动释放内存空间，否则会导致内存泄漏的问题。

  3. 静态内存分配：静态内存分配是指在程序编译时就已经分配好的内存空间，例如全局变量和静态变量。静态内存分配的优点是可以快速地访问变量和数据，但是其分配的内存空间是固定的，无法动态地扩展和收缩。

  下面是一张简单的C++内存布局图，它展示了C++程序在运行时所使用的内存空间及其对应的用途：

  ```c
  +-----------------------------+
  |        堆（Heap）           |
  +-----------------------------+
  |        动态分配的内存空间   |
  +-----------------------------+
  |        未初始化的数据段    |
  +-----------------------------+
  |        初始化的数据段      |
  +-----------------------------+
  |        可执行代码段        |
  +-----------------------------+
  |        栈（Stack）         |
  +-----------------------------+
  |        局部变量和参数       |
  +-----------------------------+
  ```

  这个内存布局图包含了C++程序在运行时所使用的主要内存区域。其中，堆空间用于存储动态分配的内存空间，未初始化的数据段和初始化的数据段用于存储程序的全局变量和静态变量，可执行代码段用于存储程序的可执行代码，栈空间用于存储局部变量和函数调用的上下文信息。

- 整数、指针、布尔变量、浮点数值如何与0比较大小？

  整数、指针、布尔变量、浮点数值与0比较大小的方法略有不同：

  1. 整数：可以直接使用比较运算符（>, <, >=, <=, ==, !=）来比较整数和0的大小。

  2. 指针：指针可以用于表示内存地址，与0进行比较可以判断指针是否为空指针。可以使用比较运算符（>, <, >=, <=, ==, !=）来比较指针和0的大小，或者使用指针运算符（!ptr）来判断指针是否为空指针。

  3. 布尔变量：布尔变量只有两个取值：true和false。可以使用比较运算符（==和!=）来比较布尔变量和0的大小，其中false等于0，true等于1。

  4. 浮点数值：由于浮点数是以二进制形式表示的，存在精度误差，因此不能直接用比较运算符（>, <, >=, <=, ==, !=）来比较浮点数和0的大小。可以使用一些特殊的函数来比较浮点数和0的大小，例如fabs()函数、fpclassify()函数、isfinite()函数、isgreater()函数和isless()函数等。

  需要注意的是，在比较浮点数和0的大小时，也可能存在精度误差。因此，在实际应用中，应该根据具体情况选择合适的比较方法，以确保比较的准确性和精度。

- 动态链接中什么是共享？什么不是共享的？动态库中有一些全局变量怎么办？全局变量是一份吗？一份不就互相冲突了吗？

  在动态链接中，共享指的是多个进程或模块共享一个动态库的代码和数据。具体来说，动态库中的代码和数据可以被多个进程或模块同时使用，从而实现代码和数据的共享和重用，提高了程序的执行效率和资源利用率。

  在动态链接中，共享的包括动态库中的函数、变量、常量、数据结构等。这些共享的代码和数据可以被多个进程或模块调用和使用，从而避免了代码和数据的重复定义和占用，减少了程序的内存占用和启动时间。

  但也有一些内容是不共享的，例如动态库中的一些非静态全局变量。由于多个进程或模块可能会同时使用这些变量，因此如果它们是共享的，可能会导致数据的冲突和不一致性。为了解决这个问题，通常需要使用“符号版本控制”等机制来确保动态库中的全局变量是不共享的，即每个进程或模块都有自己的一份拷贝。

  在一些编程语言中，如 C++，全局变量的实现方式可能会影响它们在动态库中的共享性。具体来说，如果全局变量是静态的，则它们在动态库中是共享的；如果全局变量是非静态的，则它们在动态库中是不共享的。为了保证全局变量的正确性和一致性，通常需要使用线程局部存储、进程间通信等机制来避免数据冲突和不一致性。

  总之，在动态链接中，共享是一种重要的机制，它可以实现代码和数据的共享和重用，提高程序的执行效率和资源利用率。但也需要注意一些内容是不共享的，如动态库中的一些非静态全局变量，需要使用特定的机制来确保数据的正确性和一致性。

- B+树有什么缺点，哪些需要优化的地方？

  B+树是一种常用的数据结构，广泛应用于数据库、文件系统等领域。B+树相对于其他树结构，拥有很多优点，如高效的查找、插入、删除等操作，以及支持范围查找、排序等操作。但是，B+树也存在一些缺点，需要优化的地方主要有以下几点：

  1. 内存占用较大：B+树中每个节点都需要占用一定的内存空间，而且节点的大小通常比较大，因此B+树的内存占用较大，对于大数据量的情况可能会出现内存不足的问题。
  2. 插入、删除操作的代价较高：当需要进行插入或删除操作时，B+树需要进行节点的拆分、合并等操作，这些操作涉及到磁盘IO操作，代价较高，因此在频繁进行插入、删除操作时，B+树的性能可能会受到影响。
  3. 维护成本较高：B+树的维护需要考虑到节点的拆分、合并等操作，这些操作需要保证B+树的平衡性和有序性，因此维护成本较高。
  4. 不支持高并发：B+树的操作通常需要进行磁盘IO操作，因此在高并发的情况下，磁盘IO可能会成为瓶颈，导致性能下降。

  针对以上缺点，可以采取以下优化措施：

  1. 使用压缩算法：可以采用一些压缩算法，如字典压缩、前缀压缩等，来减少节点的大小，降低内存占用。
  2. 批量处理插入、删除操作：可以采用批量处理的方式，将多次插入、删除操作合并成一次操作，减少磁盘IO操作的次数，提高性能。
  3. 优化节点拆分、合并算法：可以采用一些优化算法，如延迟合并、节点复用等，来减少节点的拆分、合并操作，降低维护成本。
  4. 使用缓存、预读等技术：可以采用缓存、预读等技术，将磁盘IO的次数降到最低，提高性能。
  5. 使用分布式B+树：可以采用分布式B+树的方式，将数据分布在多个节点上，提高并发性能。

- 内存对齐会带来什么问题？

  内存对齐是为了提高内存访问的效率和性能，但是它也会带来一些问题，包括：

  1. 浪费内存空间：内存对齐可能会导致结构体中存在一些未使用的空间，这些空间不能被其他变量利用，从而浪费内存空间。

  2. 平台兼容性：不同的平台和编译器对内存对齐的实现可能不同，这可能会导致在不同的平台上运行时出现问题。为了解决这个问题，需要使用特定的编译器选项或者指定特定的对齐方式。

  3. 性能下降：内存对齐可能会导致在访问未对齐的数据时需要进行额外的操作，从而降低程序的性能。

  4. 跨平台数据传输问题：在网络传输或者文件存储时，由于不同平台之间对齐方式的差异可能会导致数据解析错误，从而产生跨平台数据传输问题。为了解决这个问题，需要使用特定的序列化和反序列化方法来确保数据的正确解析。

- 数据库死锁的场景，怎么解决，操作系统的死锁，怎么解决？

  数据库死锁是指两个或多个事务相互等待对方释放资源而导致的一种状态，这种状态下所有事务都无法继续执行。下面介绍一些常见的数据库死锁场景以及如何解决它们：

  1. 场景一：并发访问同一批记录

  当多个事务同时访问同一批记录并尝试更新它们时，就有可能出现死锁。例如，事务A锁定记录1，然后尝试锁定记录2；同时，事务B锁定记录2，然后尝试锁定记录1。这时候就会发生死锁。

  解决方法：减小锁定范围，例如对记录进行分组，让每个事务只锁定自己的一组记录。

  2. 场景二：交错的更新操作

  当多个事务交错执行更新操作时，也可能出现死锁。例如，事务A更新记录1，然后尝试更新记录2；同时，事务B更新记录2，然后尝试更新记录1。这时候就会发生死锁。

  解决方法：为事务执行的更新操作定义一个标准的顺序，使得所有的事务都按照相同的顺序访问记录。例如，可以按照记录的主键值进行排序，或者按照记录的创建时间进行排序，以确保所有事务都按照相同的顺序访问记录。

  3. 场景三：持有锁并等待其他锁

  当一个事务持有一个锁并等待其他锁时，也可能导致死锁。例如，事务A锁定记录1，然后等待事务B释放记录2的锁；同时，事务B锁定记录2，然后等待事务A释放记录1的锁。这时候就会发生死锁。

  解决方法：在事务中尽可能少地持有锁，并尽快释放锁。如果需要锁定多个记录，可以对记录按照固定的顺序进行锁定，以避免死锁的发生。

  至于操作系统死锁，通常可以采用以下方法进行解决：

  1. 预防死锁的发生：通过设计良好的算法和数据结构，避免死锁的发生。例如，避免资源的竞争和抢占，尽量减小锁定资源的范围等。

  2. 检测死锁：通过检测系统中的资源使用情况，及时发现死锁的发生。例如，可以使用死锁检测算法，或者通过系统日志来检测死锁。

  3. 解除死锁：一旦检测到死锁，就需要解除死锁。常用的方法包括：

  - 抢占资源：中断某个进程并回收其占用的资源，将资源分配给其他进程。

  - 回滚事务：对于数据库系统而言，可以回滚某个事务，释放其占用的资源。

  - 通过协商解除死锁：让某个进程或事务主动释放资源，以便其他进程或事务可以继续执行。

  需要注意的是，以上方法都需要系统支持，并且有一定的代价。例如，抢占资源可能会影响到进程或事务的正常执行，回滚事务可能会导致数据的丢失，而协商解除死锁则需要对系统进行一定的修改和调整。因此，在实际应用中，需要根据具体的情况选择合适的方法来解决死锁问题。

  另外，还有一些预防死锁的方法，例如：

  1. 避免过度并发：减少并发操作，降低系统的负载，从而减少死锁的发生概率。

  2. 避免长时间持有锁：尽可能减少锁定资源的时间，避免长时间持有锁，从而减少死锁的发生概率。

  3. 使用超时机制：对锁定操作设置超时时间，如果超时则自动释放锁，避免死锁的发生。

  4. 使用死锁检测算法：对系统中的资源使用情况进行监控，及时发现死锁并采取相应的措施。例如，可以使用银行家算法、资源分配图等死锁检测算法，或者通过系统日志来检测死锁。

  总之，解决死锁问题需要根据具体的场景进行分析和解决，需要综合考虑系统的性能、可靠性、安全性等因素。同时，预防死锁的发生也是非常重要的，可以从系统设计、资源分配、并发控制等方面入手，尽可能减少死锁的发生概率。

- 什么情况下会出现栈溢出，递归调用的时候会把哪些参数压栈？

  栈溢出（Stack Overflow）通常发生在程序递归调用层数过多，导致栈空间不足而无法继续压栈的情况下。当一个函数被调用时，它的局部变量、函数参数、返回地址等信息都会被保存在栈中。每次函数调用时，这些信息都会被压入栈中，当函数返回时，这些信息会被从栈中弹出，恢复前一个函数的执行现场。

  在递归调用中，每一层递归都需要保存一份相同的信息到栈中，因此递归调用的深度越深，栈中保存的信息就越多，栈空间就会越快地被耗尽。如果递归调用的深度过大，栈空间就会被耗尽，从而导致栈溢出。

  递归调用时会将函数的参数、局部变量和返回地址等信息压入栈中。在递归调用子函数时，会将当前函数的返回地址、参数和局部变量等信息压入栈中，然后跳转到子函数的入口地址执行。当子函数执行完成后，会从栈中弹出保存的信息，返回到调用该函数的上一层函数继续执行。这个过程会一直重复，直到递归调用结束。

  在递归调用过程中，每次压栈的信息包括：

  1. 函数的返回地址，用于在子函数执行完成后返回到调用该函数的上一层函数。
  2. 函数的参数，包括传递给函数的实参和函数自身的形参。
  3. 函数的局部变量，包括函数内部定义的所有变量和临时变量。
  4. 其他与函数执行相关的信息，如程序计数器等。

  当递归调用深度过大，栈中保存的信息就会越来越多，最终导致栈溢出。要避免栈溢出，可以通过优化算法或使用迭代代替递归等方式减少递归调用的深度，或者增大栈空间的大小。另外，一些编程语言也提供了尾递归优化等机制来减少递归调用时的栈空间使用。

- 快速排序的平均时间复杂度和最坏时间复杂度，什么情况下会出现最坏时间复杂度，怎么改进？

  快速排序的平均时间复杂度为O(n*log(n))，其中n为待排序序列的长度。最坏时间复杂度为O(n^2)，发生在待排序序列已经有序或基本有序的情况下。

  快速排序的基本思想是通过一次划分操作将待排序序列分成两个子序列，其中一个子序列的所有元素均小于等于另一个子序列的所有元素，然后递归地对这两个子序列进行排序。在划分操作中，我们通常选择一个基准元素（pivot），将序列中所有小于等于基准元素的元素放到它的左边，将大于基准元素的元素放到它的右边，最后将基准元素插入到中间位置。这个过程可以使用快速排序的分治思想实现。

  快速排序的平均时间复杂度为O(n*log(n))，是因为每次划分操作可以将序列分成两个大致相等的子序列，因此总共需要进行log(n)次划分操作，每次划分的时间复杂度为O(n)，因此总时间复杂度为O(n*log(n))。但是，当待排序序列已经有序或基本有序时，快速排序的划分操作可能会将序列分成一个很小的子序列和一个很大的子序列，这种情况下快速排序的时间复杂度会退化为O(n^2)。

  为了避免出现最坏时间复杂度，可以采用以下一些改进措施：

  1. 随机化pivot：在选择pivot时，可以随机选择序列中的一个元素作为pivot，这样可以降低出现最坏情况的概率。

  2. 三数取中法：在选择pivot时，可以使用三数取中法，即从序列的首、尾、中间三个位置选取一个元素作为pivot，这样可以避免最坏情况的发生。

  3. 聚集相等元素：在划分操作中，可以将与pivot相等的元素聚集到一起，避免这些元素在下一轮划分中来回交换，从而提高快速排序的效率。

  4. 小数据规模使用插入排序：当待排序序列的规模比较小的时候，可以使用插入排序等简单排序算法来进行排序，避免快速排序的递归调用过深。

  5. 尾递归优化：在实现快速排序时，可以使用尾递归优化来减少递归调用的深度，减少栈空间的使用。

  6. 非递归实现：使用非递归的方式实现快速排序，避免递归调用的深度过大而导致栈溢出或性能下降。

  使用上述改进措施可以有效地避免快速排序的最坏情况，提高快速排序的效率。

- int[]、int*、int**区别

  int[]、int*、int**都是C语言中的指针类型，它们之间有以下区别：

  1. int[]表示一个数组类型，其内存空间是连续的一段，可以使用下标来访问数组元素。例如，int a[5]表示一个包含5个整数元素的数组，可以使用a[i]来访问第i个元素。

  2. int*表示一个指向int类型变量的指针，其值是一个地址，指向一个int类型的变量。例如，int *p表示一个指向int类型变量的指针，可以使用*p来访问指针所指向的变量的值。

  3. int**表示一个指向指针的指针，其值是一个地址，指向一个指向int类型变量的指针。例如，int **pp表示一个指向指针的指针，可以使用**pp来访问指针所指向的变量的值。

  总的来说，int[]、int*、int**都是指向整型数据的指针类型，但它们之间的区别在于指针的级别和指针所指向的数据类型。int[]指向的是一个数组类型，int*指向的是一个整型变量，而int**指向的是一个指向整型变量的指针。此外，int[]和int*都可以用于访问数组元素，但使用方式略有不同。int[]使用下标访问数组元素，而int*可以使用指针运算符来访问数组元素。int**通常用于指向动态分配的二维数组或者指针数组，在这种情况下，它可以指向一个指针数组或者一个二维数组的第一维。

- 拷贝和赋值的区别

  在编程中，拷贝和赋值都是将一个变量的值复制到另一个变量中。但是，它们之间有着重要的区别：

  1. 赋值是将某个变量的值直接赋给另一个变量，两个变量最终指向相同的内存地址。如果其中一个变量的值发生改变，另一个变量的值也会改变。
  2. 拷贝是将某个变量的值复制到一个新的内存地址中，两个变量指向不同的内存位置。如果其中一个变量的值发生改变，另一个变量的值不会受到影响。

  具体来说，赋值是对已有的变量重新赋值，变量名不变，指向的内存地址也不变。而拷贝是将已有的变量的值复制到一个新的内存地址中，生成一个新的变量名，指向新的内存地址。

- allocator c++的实现

  在 C++ 中，我们可以使用标准库中的 allocator 类来实现内存分配器。Allocator 是一个模板类，我们可以通过实例化不同类型的 Allocator 来为它们分配内存。

  以下是一个示例实现：

  ```c
  #include <iostream>
  #include <memory>
  
  int main() {
      // 创建一个 allocator 对象
      std::allocator<int> alloc;
  
      // 分配一段能够存储 10 个 int 类型的内存空间
      int* ptr = alloc.allocate(10);
  
      // 使用分配的内存空间
      for (int i = 0; i < 10; i++) {
          ptr[i] = i;
      }
  
      // 输出分配的内存空间中的值
      for (int i = 0; i < 10; i++) {
          std::cout << ptr[i] << " ";
      }
  
      // 释放内存空间
      alloc.deallocate(ptr, 10);
  
      return 0;
  }
  ```

  在这个示例中，我们首先创建了一个 `std::allocator<int>` 对象 `alloc`。然后，我们使用 `alloc.allocate(10)` 分配了一段能够存储 10 个 int 类型的内存空间，并将返回的指针 `ptr` 指向了这段内存空间的起始位置。接下来，我们使用循环将 0 到 9 这 10 个整数依次存储在了分配的内存空间中，并使用循环输出了这些整数。最后，我们使用 `alloc.deallocate(ptr, 10)` 释放了分配的内存空间。

  需要注意的是，在使用 allocator 分配内存空间时，我们需要使用 `allocate()` 方法来分配内存空间，并指定需要分配的元素数量，而在释放内存空间时，我们需要使用 `deallocate()` 方法，并指定需要释放的内存空间的指针和元素数量。此外，我们还可以使用 allocator 的其他方法，如 `construct()` 和 `destroy()` 来构造和销毁对象。

  需要注意的是，C++11 引入了可变参数模板的 allocator，即 `std::allocator_traits`。它提供了更多的能力，可以处理不同的内存分配器，支持 C++11 引入的移动语义，还可以处理可变参数的构造函数和析构函数。

- 智能指针shared_ptr、unique_ptr应用场景

  智能指针是一种 C++ 的语言特性，它可以自动管理动态分配的内存。智能指针的两种常用类型是 `shared_ptr` 和 `unique_ptr`。

  `unique_ptr` 是一个独占指针，它拥有对其所指对象的唯一所有权。当 `unique_ptr` 被销毁时，它所指向的对象也会被销毁。`unique_ptr` 适用于以下场景：

  - 管理动态分配的内存，确保内存的正确释放；
  - 作为函数的返回值，传递动态分配的对象的所有权；
  - 在容器中存储对象。

  示例代码：

  ```c
  // 创建一个 unique_ptr 对象，指向一个动态分配的整数
  std::unique_ptr<int> uptr(new int(42));
  
  // unique_ptr 对象可以作为函数的返回值
  std::unique_ptr<int> create_int() {
    return std::unique_ptr<int>(new int(42));
  }
  
  // unique_ptr 对象可以存储在容器中
  std::vector<std::unique_ptr<int>> vec;
  vec.push_back(std::unique_ptr<int>(new int(42)));
  ```

  `shared_ptr` 是一个共享指针，它允许多个指针共享同一个对象。当最后一个 `shared_ptr` 对象被销毁时，它所指向的对象也会被销毁。`shared_ptr` 适用于以下场景：

  - 多个对象需要共享同一个动态分配的对象；
  - 对象的所有权需要在多个地方传递和共享。

  示例代码：

  ```c
  // 创建一个 shared_ptr 对象，指向一个动态分配的整数
  std::shared_ptr<int> sptr(new int(42));
  
  // 多个 shared_ptr 对象可以共享同一个对象
  std::shared_ptr<int> sptr2 = sptr;
  
  // shared_ptr 对象可以作为函数的参数和返回值
  void process_int(std::shared_ptr<int> sptr) {
    // do something with sptr
  }
  
  std::shared_ptr<int> create_int() {
    return std::make_shared<int>(42);
  }
  ```

  需要注意的是，`shared_ptr` 的多线程使用需要特别小心，因为它的内部引用计数可能会被多个线程同时访问和修改。为了避免多线程问题，可以使用 `std::atomic<>`对引用计数进行原子操作，或者使用线程安全的智能指针实现，如 `std::shared_ptr<std::mutex>` 和 `std::shared_ptr<std::shared_mutex>`。

- shared_ptr的内部的count计数是否是线程安全的

  `std::shared_ptr` 内部的引用计数 `count` 不是线程安全的。多个线程同时访问和修改 `count` 可能会导致竞态条件和内存泄漏等问题。

  为了避免这些问题，C++11 标准库提供了 `std::atomic` 模板，可以用于原子操作计数器。可以通过将 `count` 声明为 `std::atomic<std::size_t>`，来保证 `shared_ptr` 计数器的线程安全。使用原子操作可以确保多线程访问计数器时，不会发生竞争条件。

  示例代码：

  ```c
  #include <atomic>
  #include <memory>
  
  int main() {
      std::atomic<std::size_t> count(0);
      std::shared_ptr<int> ptr(new int(42), [&count](int* p) {
          delete p;
          --count;
      });
      ++count;
      std::shared_ptr<int> ptr2 = ptr;
      ++count;
      return 0;
  }
  ```

  在上面的示例中，我们使用了 `std::atomic` 来保证 `count` 的线程安全。在创建 `shared_ptr` 时，我们将计数器 `count` 的类型声明为 `std::atomic<std::size_t>`，并在自定义的删除器中对 `count` 进行原子操作。在增加和减少 `shared_ptr` 的引用计数时，也需要使用原子操作来保证线程安全。

  需要注意的是，使用原子操作会增加一定的开销，因此只有在多线程环境下，且计数器的访问频率较高时，才有必要使用原子操作来保证线程安全。如果在单线程环境下使用 `std::atomic`，则可能会降低程序的性能。

  另外，C++11 标准库还提供了 `std::enable_shared_from_this` 类，它可以让某个对象 `obj` 获得一个 `std::shared_ptr`，从而可以在对象内部访问该对象的引用计数。使用 `std::enable_shared_from_this` 可以避免在创建 `shared_ptr` 时出现竞态条件，从而提高代码的可靠性。

- 调用shared_ptr指向的对象的方法是否是线程安全的

  调用 `std::shared_ptr` 指向的对象的方法是否线程安全取决于该对象本身是否线程安全。`std::shared_ptr` 只是一种内存管理工具，它本身并没有提供线程安全保障。

  如果 `std::shared_ptr` 指向的对象是线程安全的，那么在多线程环境下调用该对象的方法也是线程安全的。否则，在多线程环境下调用该对象的方法可能会导致竞态条件和数据竞争等问题。

  例如，如果 `std::shared_ptr` 指向的对象是一个线程安全的容器，如 `std::vector`，那么在多线程环境下调用该容器的方法是线程安全的。另外，如果该对象已经被加锁，那么在多线程环境下调用该对象的方法也是线程安全的。

  需要注意的是，即使对象本身是线程安全的，多个线程同时调用该对象的方法仍然可能会导致性能问题。在这种情况下，可以考虑使用线程安全的容器或者采用其他线程同步机制来避免竞态条件和数据竞争。

  总之，当使用 `std::shared_ptr` 时，需要确认指向的对象是否是线程安全的，并根据实际情况采取相应的线程同步措施来保证多线程环境下的程序正确性和性能。

- malloc最多能开多少

  `malloc` 函数的最大可分配内存取决于操作系统和硬件架构的限制。在 32 位操作系统上，由于地址空间的限制，`malloc` 函数最多只能分配 2GB 的内存；而在 64 位操作系统上，由于地址空间更大，理论上可以分配更大的内存。

  但是，即使在 64 位操作系统上，实际上也无法分配所有可用内存，因为操作系统和硬件架构仍然会施加一些限制。例如，操作系统可能会限制进程最大可用内存的大小，硬件架构也可能会限制每个进程可用内存的大小。此外，`malloc` 函数的实现还可能会对可分配的内存大小进行限制，例如可能会限制分配的内存大小为操作系统页面大小的倍数。

  因此，如果需要分配大量内存，建议使用专门的内存分配库，如 `jemalloc`、`tcmalloc` 等，这些库通常能够更好地管理内存碎片，提供更高效的内存分配和释放。另外，也可以考虑使用内存映射文件等技术来分配大量的内存。

- 





## 面向对象

- C++空类会默认创建哪些函数

  缺省构造函数，拷贝构造函数，析构函数，赋值运算符，取址运算符，取址运算符 const。

  ```c
  class Empty{
    public:
        Empty(); // 缺省构造函数
        Empty( const Empty& ); // 拷贝构造函数
        ~Empty(); // 析构函数
         Empty& operator=( const Empty& ); // 赋值运算符
         Empty* operator&(); // 取址运算符
         const Empty* operator&() const; // 取址运算符 const
  };
  ```

- 调用析构函数的时候类型是 void 类型，指向的是类对象，会正确调用析构函数吗？

  - void指向系统自建类型，可以使用delete void；
  - void*所指向的对象在析构函数里释放会丢失内存，因为它不执行析构函数。需要强制转换类型，然后delete；

- 析构函数可以抛异常么？

  理论上析构函数可以抛出异常。但是，这样做可能会导致一些问题，因此通常不建议在析构函数中抛出异常。

  首先，如果析构函数抛出了异常，那么很可能导致对象没有完全被销毁。因为在抛出异常的情况下，程序会跳过后续的清理工作，导致对象没有被正确地析构。这可能会导致资源泄露等问题。

  其次，如果在析构函数中抛出了异常，并且该异常没有被捕获和处理，那么程序就会调用 `std::terminate` 函数来结束程序运行。这样可能会导致一些未预料到的问题，比如内存泄漏和数据损坏等。

  因此，最好的做法是在析构函数中避免抛出异常。如果必须要在析构函数中抛出异常，那么建议在析构函数中进行必要的安全措施，以确保在抛出异常的情况下对象能够被正确地销毁。同时，也需要在代码中进行相应的异常处理，以避免程序调用 `std::terminate` 函数而崩溃。

- 条件变量为什么需要加锁？

  条件变量是多线程编程中的一种同步机制，通常与互斥锁一起使用，在多线程中实现线程之间的同步和通信。条件变量的作用是当某个条件被满足时，唤醒正在等待该条件的线程。 条件变量需要加锁的原因如下：

  1. 确保线程安全：在使用条件变量时，需要先获取相关的互斥锁，然后再对条件变量进行操作。这是因为条件变量的操作通常需要访问共享资源，如果没有加锁，多个线程可能会同时访问共享资源，导致数据竞争和线程安全问题。
  2. 避免竞争条件：条件变量的等待和唤醒操作通常需要依赖互斥锁来保证其原子性和同步性。如果没有加锁，多个线程可能会同时调用条件变量的等待和唤醒操作，导致竞争条件和线程安全问题。
  3. 避免死锁：条件变量和互斥锁通常是成对使用的，如果在使用条件变量时没有获取相应的互斥锁，可能会导致死锁问题。 

  因此，为了保证线程安全、避免竞争条件和死锁问题，条件变量需要加锁。在使用条件变量时，通常需要先获取相关的互斥锁，然后再对条件变量进行操作。

- 虚函数可以内联吗

  虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。内联发生在编译阶段，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

  inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

  ```c
  #include <iostream>  
  using namespace std;
  class Base{
  public:
  	inline virtual void who()
  	{
  		cout << "I am Base\n";
  	}
  	virtual ~Base() {}
  };
  class Derived : public Base{
  public:
  	inline void who()  // 不写inline时隐式内联
  	{
  		cout << "I am Derived\n";
  	}
  };
  
  int main(){
  	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，
      // 编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
  	Base b;
  	b.who();
  
  	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
  	Base *ptr = new Derived();
  	ptr->who();
  
  	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，
      // 会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
  	delete ptr;
  	ptr = nullptr;
  } 
  ```

- 一个类有多个基类，内存中怎么虚函数表是怎么分布的？

  在派生类对象的内存中，虚表指针放在最前面，和对象的地址相同。然后是成员变量，基类的成员变量在派生类的成员变量前面，基类和派生类的成员变量分别按类中的声明顺序排列。

  对于多继承的情况，假如派生类有n个直接基类，那么派生类对象中就有n个虚表指针。派生类对象的内存可以划分为n+1块，首先存放第1个基类的虚表指针和成员变量，然后存放第2个基类的虚表指针和成员变量，以此类推。派生类自己的成员变量放在最后1块。

  虚表中虚函数的顺序是按声明顺序排列的，基类虚函数的声明先于派生类。派生类的虚函数和第一个直接基类共用一张虚表，并且在这张虚表中，基类的虚函数在前，派生类的虚函数在后。如果派生类覆盖了基类的一个虚函数，那么虚表中本来存放这个基类虚函数地址的位置改为存放派生类版本的虚函数地址。

- 拷贝构造函数为什么传引用

  因为调用拷贝构造函数是实参向形参传值，如果传进来的不是引用，那么就是值传递，那么就会在函数里又重新创建一个对象，而重新创建又是通过调用拷贝构造函数，所以如果不是引用的话，就会无穷递归地调用拷贝构造函数。另外调用拷贝构造函数时不需要消耗另外的内存空间。


- 构造函数里面可以调用成员函数吗

  1. 构造函数调用成员函数的顺序应该在初始化列表中指定。因为初始化列表是在进入构造函数的主体之前执行的，所以成员函数调用必须放在初始化列表中。
  2. 在构造函数中调用成员函数时，需要注意成员变量的值是否已经初始化。如果成员变量的值还没有初始化，可能会导致成员函数调用出错。
  3. 如果成员函数是虚函数，那么在构造函数中调用虚函数是有风险的，因为在构造函数中，对象还没有完全构造完成，此时调用虚函数可能会导致不可预测的行为。 下面是一个示例代码，演示了如何在构造函数中调用成员函数：

  ```c
  class MyClass {
  public:
      MyClass(int value) : m_value(value) {
          m_data = new int[m_value];
          InitData();
      }
      ~MyClass() {
          delete[] m_data;
          m_data = nullptr;
      }
  private:
      int m_value;
      int* m_data;
      void InitData() {
          for (int i = 0; i < m_value; i++) {
              m_data[i] = i;
          }
      }
  };
  ```

  在这个示例代码中，我们定义了一个 MyClass 类，包含了一个构造函数和一个 InitData 成员函数。

  在构造函数中，我们首先使用初始化列表将 m_value 成员变量初始化，然后在构造函数主体中调用 new 操作符动态分配了一个数组，并将其赋值给 m_data 成员变量。接着，我们调用了 InitData 成员函数，用于初始化 m_data 数组中的值。

  在析构函数中，我们使用 delete[] 操作符释放了 m_data 数组所占用的内存。 需要注意的是，在构造函数中调用成员函数时，需要特别小心，确保成员变量的值已经被正确初始化。此外，在构造函数中调用虚函数是有风险的，请尽量避免这种情况的发生。

- 移动语义和移动构造函数

  引入右值引用的目的之一是实现移动语义。移动语义的引入是为了解决在进行大数据复制的时候，将动态申请的内存空间的所有权直接转让出去，不用进行大量的数据移动，既节省空间又提高效率。移动语义可能修改右值的值，所以，右值引用参数不能是const。

  通过复制构造函数来实现复制语义，通过移动构造函数来实现移动语义。复制构造使用const &引用，而移动构造函数使用非const && 引用，需要传入右值引用。

  被移动语义的数据交出了所有权，为了不出现析构两次同一数据区，要将交出所有权的数据的指向动态申请内存区的指针赋值为nullptr，即空指针，对空指针执行delete[]是合法的。

  移动构造函数：右值主要用来实现移动构造函数，资源给了新的移动构造函数的对象，移动构造函数只交换资源的所有权。也就是说，移动构造函数事实上做了一个浅拷贝，将右值的地址给调用了移动构造函数的对象，并将原来的指针置空。

  ```c
  class MyString {
  public:
      // 普通构造函数
      MyString(const char* str = nullptr) {
          if (str == nullptr) {
              m_data = new char[1];
              *m_data = '\0';
          } else {
              int len = strlen(str);
              m_data = new char[len+1];
              strcpy(m_data, str);
          }
      }
      // 移动构造函数
      MyString(MyString&& other) {
          m_data = other.m_data;
          other.m_data = nullptr;
      }
      // 析构函数
      ~MyString() {
          if (m_data != nullptr) {
              delete[] m_data;
              m_data = nullptr;
          }
      }
  private:
      char* m_data;
  };
  ```

  在这个示例代码中，我们定义了一个 MyString 类，包含了一个普通构造函数和一个移动构造函数。在移动构造函数中，我们将 other 对象的内部资源移动到了新对象中，并将 other.m_data 置为 nullptr，以避免析构函数重复释放内存。

  使用移动构造函数可以减少不必要的内存复制操作，提高程序的性能和效率。需要注意的是，在定义移动构造函数时，需要将源对象的指针置为 nullptr，以避免重复释放内存。

- unique_ptr如何实现独占对象

  unique_ptr实现独占对象的关键在于禁止复制和移动操作，只允许通过move函数进行所有权的转移。

  具体实现方式如下：

  1. 禁止复制构造函数和复制赋值运算符

  在类的定义中声明为私有，并不提供实现。这样可以防止其他代码通过复制操作来获取对象的所有权，确保对象只能被一个unique_ptr实例所拥有。

  2. 实现移动构造函数和移动赋值运算符

  移动构造函数和移动赋值运算符可以通过std::move函数将对象的所有权转移给另一个unique_ptr实例。在转移所有权后，原来的unique_ptr实例将不再拥有对象的所有权，避免了资源的重复释放。

  3. 在析构函数中释放资源

  unique_ptr的析构函数会自动调用对象的析构函数，并释放资源。由于unique_ptr只能拥有一个对象的所有权，因此在析构函数中只需要释放一次资源，避免了资源的重复释放。

  总之，unique_ptr通过禁止复制和移动操作，以及在析构函数中释放资源的方式，实现了独占对象的功能。

- 一个类对象数据的初始化顺序

  一个类对象的数据初始化顺序是先调用基类的构造函数，然后按照派生类中非静态成员变量的定义顺序依次初始化这些成员变量，最后调用派生类的构造函数。需要注意的是，静态成员变量的初始化是在程序启动时进行的，不属于类对象的初始化顺序。

  总之，一个类对象的数据初始化顺序遵循基类构造函数先于派生类构造函数，派生类中非静态成员变量按照定义顺序初始化的规则。

- 如何让类不能被继承

  在C++中，可以通过声明一个类为`final`来防止其被继承。使用`final`关键字修饰的类称为最终类（或密封类），这些类不能再被其他类所继承。

  例如，下面的代码定义了一个最终类`MyClass`：

  ```c
  class MyClass final {
    // 类定义
  };
  ```

  在这个例子中，`final`关键字用于修饰类`MyClass`，表示该类不能再被其他类所继承。

  需要注意的是，`final`只能用于类的声明中，而不能用于类的定义中。同时，如果一个类被声明为最终类，那么它的成员函数也都将自动成为最终函数，不能被派生类覆盖。

  除了使用`final`关键字，还可以通过将类的构造函数声明为`private`来实现类无法被继承。由于不能在派生类中访问基类的私有成员，因此这样定义的类无法被继承。例如：

  ```c
  class MyClass {
  private:
    MyClass() {}  // 将构造函数声明为私有，防止类被继承
    friend class SomeFriend; // 友元类可以调用私有构造函数
  };
  
  // 不能继承MyClass，因为其构造函数是私有的
  class MyDerived : public MyClass {
    // 类定义
  };
  ```

  在这个例子中，`MyClass`的构造函数被声明为私有，在`MyDerived`中无法访问到该构造函数，因此`MyDerived`无法继承`MyClass`。

  总之，可以通过将类声明为`final`、将构造函数声明为`private`等方式来实现类不能被继承。选择哪种方式取决于具体的要求和场景。

- 如何禁止构造函数的使用

  有两种方法可以禁止构造函数的使用：

  1. 将构造函数声明为私有（private）或受保护（protected），这样就无法从外部访问和调用构造函数。例如：

  ```c
  class MyClass {
  private:
      MyClass() {}
  };
  ```

  在这个例子中，将`MyClass`的构造函数声明为`private`，这样在类的外部就无法调用构造函数来创建对象。

  2. 继承一个不可复制（uncopyable）的基类。不可复制的基类中包含了私有的构造函数和赋值运算符，并将它们声明为`delete`，以防止任何尝试复制该类的操作。例如：

  ```c
  class Uncopyable {
  protected:
      Uncopyable() {}
      ~Uncopyable() {}
  
  private:
      Uncopyable(const Uncopyable&) = delete;
      Uncopyable& operator=(const Uncopyable&) = delete;
  };
  
  class MyClass : private Uncopyable {
  public:
      // ...
  };
  ```

  在这个例子中，`MyClass`继承了`Uncopyable`类，因此在编译期间会检测到任何尝试复制或移动`MyClass`对象的操作，并报告编译错误。

  总之，以上两种方法都可以禁止构造函数的使用，具体取决于需要实现的场景。

- 如果多重继承，只有一个虚表指针吗

  在多重继承情况下，一个子类会继承来自多个父类的成员和方法，这些父类中可能都有虚函数。因此，在这种情况下，每个父类都有自己的虚函数表，而一个子类也会有对应数量的虚函数表指针。具体来说，如果一个子类中继承了n个父类，则存在n个指向虚函数表的指针。

  虚函数表指针的数量等于子类的直接父类的数量加上1，其中这1个指针指向子类自己的虚函数表。还需要注意的是，虚函数表指针的顺序与直接父类在声明时的顺序相同，即先声明的父类的虚函数表指针排在前面。

  请注意，在一些操作系统或编译器的实现中，虚函数表和虚函数表指针的布局有所不同，但通常都会遵循上述原则。

- 如果禁止类实例化时候的动态分配方式

  如果要禁止类实例化时的动态分配方式，可以将类的构造函数声明为私有，并提供一个静态成员函数来创建类的对象。由于构造函数是私有的，类的对象只能通过该静态成员函数来创建，从而限制了动态分配方式。

  下面是一个示例代码：

  ```c
  class MyClass {
  private:
      MyClass() {}  // 将构造函数声明为私有
  
  public:
      static MyClass createInstance() {
          return MyClass();  // 静态成员函数来创建对象
      }
  };
  
  int main() {
      //MyClass* ptr = new MyClass();  // 错误：无法动态分配对象
      MyClass obj = MyClass::createInstance();  // 用静态成员函数创建对象
      return 0;
  }
  ```

  在这个例子中，将`MyClass`的构造函数声明为`private`，这样就无法在类的外部通过`new`运算符来动态分配内存以创建对象。但是通过提供一个公共的静态成员函数`createInstance()`，可以在类的外部调用该函数来创建对象，从而避免了动态分配对象的问题。

  需要注意的一点是，尽管这种方法可以禁止动态分配对象，但仍然可以使用栈空间和全局变量等方式来创建对象。因此，如果需要确保对象不被任何方式所创建，可以考虑将类的构造函数声明为`private`并删除该类的拷贝构造函数和赋值运算符重载函数。

- C++能否在有参构造函数中调用无参构造函数，无参构造函数中如果有修改类成员会不会对当前正在构造的类产生影响，这种调用方式有什么优势或者缺点。

  在 C++ 中，有参构造函数可以调用无参构造函数，这样的语法被称为委派构造函数（Delegating constructors）。委派构造函数的语法如下：

  ```c
  class MyClass {
  public:
      MyClass(int x, int y) : MyClass() { // 委派构造函数
          // ...
      }
  
      MyClass() : member(0) { // 无参构造函数
          // ...
      }
  
  private:
      int member;
  };
  ```

  在上面的示例中，有参构造函数 `MyClass(int x, int y)` 中调用了无参构造函数 `MyClass()`，并且使用了委派构造函数的语法。

  需要注意的是，如果无参构造函数中修改了类成员，那么在调用委派构造函数之后，这些修改的结果会被覆盖。例如：

  ```c
  class MyClass {
  public:
      MyClass(int x, int y) : MyClass() {
          member = x + y;
      }
  
      MyClass() : member(0) {
          member = 1; // 修改类成员
      }
  
  private:
      int member;
  };
  
  int main() {
      MyClass obj(1, 2);
      std::cout << obj.member << std::endl; // 输出 3，而不是 1
      return 0;
  }
  ```

  在上面的示例中，调用 `MyClass(int x, int y)` 时会先调用 `MyClass()`，在 `MyClass()` 中修改了 `member` 的值为 1，但是在 `MyClass(int x, int y)` 中又对 `member` 进行了修改，因此最终输出的是 3。

  委派构造函数的优点在于可以避免代码重复，提高代码的复用性和可维护性。委派构造函数的缺点在于可能会导致代码结构更加复杂，特别是当多个构造函数之间存在复杂的依赖关系时。此外，需要注意避免构造函数之间的无限递归调用。

- C++中将基类对象赋值给派生类指针这个操作是允许的吗？派生类对象赋值给基类指针呢？

  将基类对象赋值给派生类指针是允许的，但需要注意这个操作可能会导致指针指向的派生类成员不可访问或者访问错误的问题。派生类对象赋值给基类指针也是允许的，但同样需要注意这个操作可能会导致部分派生类成员无法访问。这是因为派生类中新增的成员变量和成员函数可能无法在基类指针或引用下被访问。

  具体来说，在将基类对象赋值给派生类指针时，派生类指针将会指向基类对象的起始地址，但只能访问基类中定义的成员变量和成员函数，无法访问派生类中新增的成员变量和成员函数。如果在派生类指针下访问了派生类中新增的成员变量或成员函数，可能会导致未定义的行为。

  例如：

  ```c
  class Base {
  public:
      int x;
      Base() : x(0) {}
      virtual void func() { cout << "Base::func()" << endl; }
  };
  
  class Derived : public Base {
  public:
      int y;
      Derived() : y(0) {}
      virtual void func() { cout << "Derived::func()" << endl; }
  };
  
  int main() {
      Base b;
      Derived* d = &b;  // 可以编译通过，但是 d 指针指向的是 b 的起始地址，访问 d->y 会导致未定义的行为
      d->func();  // 输出 Base::func()
  
      return 0;
  }
  ```

  将派生类对象赋值给基类指针时，基类指针将会指向派生类对象的起始地址，但只能访问派生类中覆盖或继承自基类的成员变量和成员函数，无法访问派生类新增的成员变量和成员函数。如果在基类指针下访问了派生类新增的成员变量或成员函数，可能会导致未定义的行为。

  例如：

  ```c
  int main() {
      Derived d;
      Base* b = &d;  
      // 可以编译通过，b 指针指向的是 d 的起始地址，但只能访问 Base 中定义的成员变量和成员函数，
      // 无法访问 Derived 中新增的成员变量和成员函数
      b->func();  // 输出 Derived::func()
      // b->y;  // 错误，无法访问派生类新增的成员变量
  
      return 0;
  }
  ```

  因此，在进行类的指针类型转换时，需要根据实际情况进行转换，并且需要注意访问指针指向的成员时是否安全。如果需要在派生类中访问派生类新增的成员变量和成员函数，应该使用派生类指针或引用。

- c++的自解锁 std::lock_guard的底层原理

  `std::lock_guard` 是C++标准库中提供的一个RAII（Resource Acquisition Is Initialization）封装，用于在构造函数中获取锁，并在析构函数中释放锁，从而避免忘记手动释放锁而导致死锁的情况。

  `std::lock_guard` 的底层实现依赖于C++11中引入的 `std::mutex` 类型，`std::mutex` 类型是一个线程安全的互斥量，可以保证多个线程之间的互斥访问。`std::lock_guard` 的构造函数接受一个 `std::mutex` 对象的引用，并在构造函数中调用该 `std::mutex` 对象的 `lock()` 方法获取锁，同时在析构函数中自动调用 `std::mutex` 对象的 `unlock()` 方法释放锁。

  下面是 `std::lock_guard` 的简单实现示例：

  ```c
  template <typename Mutex>
  class lock_guard {
  public:
      explicit lock_guard(Mutex& mutex)
          : m_mutex(mutex) {
          m_mutex.lock();
      }
  
      ~lock_guard() {
          m_mutex.unlock();
      }
  
  private:
      Mutex& m_mutex;
  };
  ```

  在构造函数中，`lock_guard` 对象获取了一个 `Mutex` 引用，并在构造函数中调用了 `lock()` 方法，从而获取了该 `Mutex` 对象的锁。在析构函数中，`lock_guard` 对象自动释放了该 `Mutex` 对象的锁，从而避免了忘记手动释放锁而导致死锁的情况。

  需要注意的是，`std::lock_guard` 并不是一个线程安全的类型，如果多个线程同时访问同一个 `std::lock_guard` 对象，可能会导致竞态条件和未定义行为。因此，每个线程需要拥有自己的 `std::lock_guard` 对象来保证线程安全。

- 类和结构体的区别

  在C++中，类和结构体都是用来封装数据和行为的数据类型，它们有相似的语法和特性，但也有一些区别，主要包括以下几点：

  1. 默认访问控制权限不同：在类中，默认的成员访问控制权限是private，而在结构体中默认的成员访问控制权限是public。

  2. 成员函数：类可以定义成员函数，而结构体不能定义成员函数。

  3. 继承：类支持继承机制，可以通过继承实现代码的复用和扩展，而结构体不支持继承。

  4. 对象初始化：在C++11之前，类和结构体的对象初始化方式是不同的，类需要使用构造函数来初始化对象，而结构体可以直接使用列表初始化语法。但是在C++11中，类和结构体的对象初始化方式进行了统一，都可以使用列表初始化语法。

  总的来说，类和结构体的主要区别在于默认访问控制权限和是否支持继承机制，而其他的特性和语法都是相似的。在实际编程中，可以根据具体的需求和习惯选择使用类或结构体。

- C++ lambda表达式的特性，什么情况下使用？

  C++11引入了Lambda表达式，它是一种匿名函数，可以在需要的地方直接定义并使用，通常用于需要传递函数对象的场合，例如STL算法，线程和异步任务等。

  Lambda表达式的特性包括：

  1. 可以捕获外部变量：Lambda表达式可以捕获外部的变量，包括局部变量，函数参数和全局变量等。捕获可以按值或按引用进行，还可以指定捕获方式的默认方式。

  2. 支持自动类型推断：Lambda表达式的参数和返回值类型可以使用auto关键字来表示，编译器会根据上下文自动推断出类型。

  3. 可以作为函数参数或返回值：Lambda表达式可以像函数一样作为参数或返回值，这使得它可以方便地用于STL算法或其他需要函数对象的场合。

  4. 可以定义在函数内部：Lambda表达式可以定义在函数内部，这使得它可以访问函数的局部变量。

  5. 支持重载函数调用运算符：Lambda表达式可以像函数对象一样重载函数调用运算符，这使得它可以像函数一样被调用。

  在实际编程中，Lambda表达式通常用于以下情况：

  1. 作为STL算法的谓词：Lambda表达式可以作为STL算法的谓词，用于对容器元素进行筛选，排序或转换等操作。

  2. 作为函数对象：Lambda表达式可以作为函数对象，用于对容器元素进行自定义操作，例如对容器元素进行计数，累加，合并等操作。

  3. 作为线程和异步任务的参数：Lambda表达式可以作为线程和异步任务的参数，用于指定要在新线程或异步任务中执行的代码块。

  4. 作为回调函数：Lambda表达式可以作为回调函数，用于在事件发生时执行特定的代码块。例如，在图形用户界面编程中，可以使用Lambda表达式来响应按钮点击事件或窗口关闭事件等。

- std::weak_ptr如何转std::shared_ptr？

  在 C++ 中，可以通过 `std::weak_ptr` 转换为 `std::shared_ptr`，具体步骤如下：

  1. 通过 `std::weak_ptr` 对象的 `lock()` 方法获得一个指向 `std::shared_ptr` 的指针。

  2. 检查指针是否为空。如果指针为空，则表示 `std::weak_ptr` 已经失效，无法转换为 `std::shared_ptr`。

  3. 如果指针不为空，则可以使用该指针进行后续的操作。

  下面是一个示例代码：

  ```c
  #include <iostream>
  #include <memory>
  
  int main() {
      std::shared_ptr<int> sp(new int(42));
      std::weak_ptr<int> wp(sp);
  
      std::shared_ptr<int> sp2 = wp.lock();
      if (sp2) {
          std::cout << "sp2: " << *sp2 << std::endl;
      } else {
          std::cout << "wp is expired." << std::endl;
      }
  
      return 0;
  }
  ```

  在上面的代码中，首先创建了一个 `std::shared_ptr` 对象 `sp`，然后通过 `sp` 创建了一个 `std::weak_ptr` 对象 `wp`。接着通过 `wp` 的 `lock()` 方法获得了一个指向 `int` 类型的 `std::shared_ptr` 对象 `sp2`，并判断该指针是否为空。最后输出 `sp2` 指向的值。

  需要注意的是，`std::weak_ptr` 转换为 `std::shared_ptr` 可能会产生空指针，因此在使用时需要进行检查，以避免出现空指针引用的问题。

- weak_ptr中怎么处理内存泄露，错误的情况？

  `weak_ptr`是C++11标准中引入的一种智能指针，它用于解决循环引用问题，避免内存泄漏。`weak_ptr`可以指向一个由`shared_ptr`管理的对象，但不会增加对象的引用计数，也不会阻止`shared_ptr`释放对象。当对象被释放后，`weak_ptr`会自动失效，避免访问已经释放的内存。

  对于`weak_ptr`的内存泄漏问题，一般可以通过以下几种方式来避免或解决：

  1. 避免循环引用：`weak_ptr`通常用于解决循环引用问题，因此应该尽量避免循环引用的情况。如果无法避免循环引用，可以考虑使用`weak_ptr`和`shared_ptr`的组合来管理对象，避免出现内存泄漏的情况。

  2. 使用`lock`函数检查`weak_ptr`是否有效：在访问`weak_ptr`指向的对象之前，应该先使用`lock`函数检查`weak_ptr`是否有效。如果`weak_ptr`已经失效，`lock`函数会返回一个空的`shared_ptr`，避免访问已经释放的内存。

  3. 使用`std::enable_shared_from_this`类：如果一个类需要被`shared_ptr`管理，并且需要将自己的`shared_ptr`传递给其他对象，可以使用`std::enable_shared_from_this`类来实现。`std::enable_shared_from_this`类提供了一个`shared_from_this`函数，可以返回当前对象的`shared_ptr`，避免使用`weak_ptr`时出现内存泄漏的情况。

  4. 使用`std::shared_ptr`的自定义删除器：如果需要在对象被释放时执行一些额外的操作，可以使用`std::shared_ptr`的自定义删除器来实现。自定义删除器可以是一个函数、一个函数对象或一个lambda表达式，它会在对象被释放的时候被调用，执行额外的操作，避免内存泄漏。

  对于`weak_ptr`的错误使用情况，一般可以通过以下几种方式来避免或解决：

  1. 不要将`weak_ptr`转换为`shared_ptr`：`weak_ptr`不能直接访问对象，必须先将其转换为`shared_ptr`才能访问对象。但是，在转换时需要使用`lock`函数检查`weak_ptr`是否有效，否则会导致访问已经释放的内存。

  2. 不要将`weak_ptr`拷贝到对象内部：在对象内部保存`weak_ptr`的拷贝可能会导致循环引用，从而出现内存泄漏的情况。应该尽量避免在对象内部保存`weak_ptr`，或者使用`std::weak_ptr`的`owner_before`函数来比较两个`weak_ptr`的拥有者，避免出现循环引用的情况。

  总之，在使用`weak_ptr`时，需要注意避免循环引用和内存泄漏的问题，同时避免出现错误的使用情况，以确保程序的正确性和稳定性。

- 拷贝构造和赋值运算符有什么区别？

  拷贝构造函数和赋值运算符都是用来实现对象的复制，但它们的实现方法和使用场景有所不同。

  拷贝构造函数是一种特殊的构造函数，用于创建一个新的对象，该对象的内容与现有对象完全相同。拷贝构造函数通常采用引用方式传递参数，即将现有对象的引用作为参数传递给拷贝构造函数，然后创建一个新的对象并将现有对象的数据复制到新对象中。拷贝构造函数通常在以下情况下被调用：

  1. 通过值传递方式创建对象；
  2. 对象作为函数参数传递；
  3. 对象作为函数返回值返回；
  4. 对象作为另一个对象的成员变量创建。

  赋值运算符是一种函数，用于将一个对象的值赋给另一个对象。赋值运算符通常采用引用方式传递参数，即将右值对象的引用作为参数传递给赋值运算符，然后将右值对象的数据复制到左值对象中。赋值运算符通常在以下情况下被调用：

  1. 对象被另一个对象赋值；
  2. 对象被另一个对象初始化；
  3. 对象作为函数参数传递；
  4. 对象作为函数返回值返回。

  总的来说，拷贝构造函数和赋值运算符都是用来实现对象的复制，但它们的实现方法和使用场景有所不同。拷贝构造函数用于在创建对象的同时进行赋值操作，而赋值运算符用于已经存在的对象之间的赋值操作。因此，在实现类时，需要同时实现拷贝构造函数和赋值运算符，以便支持对象的复制和赋值操作。

- 手写string类的成员函数，构造、析构、复制构造函数、赋值运算符？类有一个数据成员count，此数据成员有什么用？

  下面是一个简单的string类的实现，包括构造函数、析构函数、复制构造函数和赋值运算符重载：
  
  ```c
  #include <cstring>
  
  class String {
  public:
      // 默认构造函数
      String() {
          m_data = new char[1];
          m_data[0] = '\0';
          count = 1;
      }
  
      // 构造函数
      String(const char* str) {
          int length = strlen(str);
          m_data = new char[length + 1];
          strcpy(m_data, str);
          count = 1;
      }
  
      // 复制构造函数
      String(const String& other) {
          int length = strlen(other.m_data);
          m_data = new char[length + 1];
          strcpy(m_data, other.m_data);
          count = 1;
      }
  
      // 析构函数
      ~String() {
          count--;
          if (count == 0) {
              delete[] m_data;
          }
      }
  
      // 赋值运算符重载
      String& operator=(const String& other) {
          if (this != &other) {
              String tmp(other);
              std::swap(m_data, tmp.m_data);
              std::swap(count, tmp.count);
          }
          return *this;
      }
  
  private:
      char* m_data;
      int count;   // 引用计数
  };
  ```
  
  在这个string类中，count是一个数据成员，用于记录对象的引用计数。在构造函数中，count被初始化为1，表示有一个对象引用了这个string对象。在析构函数中，count减1，表示有一个对象不再引用这个string对象，如果count变为0，则说明没有任何对象引用这个string对象，可以释放其分配的内存空间。
  
  引用计数技术可以用于实现智能指针等高级数据结构，它可以帮助我们更好地管理内存空间，避免内存泄漏和野指针等问题。
  
- A、B、C链式继承，问最后一共有多少个虚函数表？

  在链式继承中，如果派生类继承了多个基类，且这些基类都声明了虚函数，那么派生类将会继承这些虚函数，并且在其虚函数表中建立对应的虚函数指针。因此，最后一共有多少个虚函数表取决于派生类的继承方式和基类的虚函数个数。
  
  在本题中，假设 A、B、C 都是有虚函数的类，并且它们之间采用链式继承方式。根据 C++ 的继承规则，C 类将同时继承 A 类和 B 类的成员，包括虚函数表。因此，如果 A 和 B 都有虚函数，则 C 类的虚函数表将包含 A 类和 B 类的虚函数表，加上 C 类自身的虚函数表。
  
  如果假设 A 类和 B 类都有一个虚函数，那么 C 类最后一共会有 3 个虚函数表，分别对应 A 类、B 类和 C 类自身的虚函数表。如果 A 和 B 类的虚函数个数不同，则 C 类的虚函数表将包含更多的虚函数表指针，以保证虚函数表的正确性和完整性。
  
  需要注意的是，在使用多重继承时，如果出现了重复的虚函数继承，可能会导致虚函数表的大小增加，从而影响程序的性能和效率。因此，在设计和使用多重继承时，应该避免出现重复的虚函数继承，并且尽量遵循“虚继承”和“菱形继承”等继承规则，以避免继承带来的问题。
  
- string什么时候发生右值引用？

  在 C++11 中，对于 `std::string` 类型，当它作为右值时，会发生右值引用。这是因为 `std::string` 类型已经实现了移动构造函数和移动赋值运算符，可以高效地处理右值引用。

  举个例子，假设有以下代码：

  ```c
  std::string s1 = "hello";
  std::string s2 = std::move(s1);
  ```

  在上面的代码中，`s1` 是一个左值，`"hello"` 是一个右值。当我们使用 `std::move` 将 `s1` 转换为右值后，它会调用 `std::string` 类型的移动构造函数，将 `s1` 中的数据移动到 `s2` 中，而不是进行拷贝操作。这样可以避免不必要的内存分配和拷贝操作，提高程序的性能。

  类似的，当我们将一个 `std::string` 类型的对象作为函数的返回值时，也会发生右值引用。例如：

  ```c
  std::string get_string() {
      return "hello";
  }
  
  std::string s = get_string();
  ```

  在上面的代码中，`get_string()` 返回一个右值，它会调用 `std::string` 类型的移动构造函数，将返回的字符串数据移动到 `s` 中。

  需要注意的是，当一个对象作为函数的返回值时，编译器可能会进行优化，将其转换为右值引用，以提高程序的性能。这种优化被称为“返回值优化”（Return Value Optimization，简称 RVO）。因此，在实际编程中，我们可以不用过于担心右值引用的情况，而是要注意代码的正确性和性能优化。


- 派生类函数能否抛出比基类函数多的异常？

  在 C++ 中，派生类函数可以抛出比基类函数更多的异常。这是因为派生类可以重新定义其继承的基类的函数，并且在重新定义的函数中可以增加新的异常，或者不抛出基类函数中可能抛出的异常。这个特性称为异常规范（Exception Specification），它允许函数声明它们可能抛出的异常类型。
  
  然而，需要注意的是，C++11 标准中已经废弃了异常规范这个特性。在新的标准中，建议使用 noexcept 关键字来声明函数是否会抛出异常。使用 noexcept 关键字可以更加灵活地控制函数的异常行为，而不需要限制派生类函数的异常类型。
  
  值得注意的是，如果派生类函数抛出了一个基类函数没有声明的异常类型，而且该异常没有被捕获，那么这将会导致 std::unexpected() 函数被调用，从而调用 std::terminate() 函数来终止程序的执行。因此，在设计派生类的函数时，应该遵循好的异常处理实践，确保异常不会被未处理。
  
- 如果不用指针和引用，子类赋值给父类，会不会引发动态绑定，为什么？

  如果不使用指针和引用，而是将子类对象赋值给父类对象，不会引发动态绑定。这是因为在这种情况下，编译器会进行隐式类型转换，将子类对象转换为父类对象，而不是将子类对象视为父类对象的指针或引用。

  在 C++ 中，动态绑定的发生是通过指针或引用来实现的。当一个函数以指针或引用形式调用时，编译器会根据指针或引用所指向的对象的类型来确定调用哪个函数。如果指针或引用指向的是基类对象，但实际对象是派生类对象，则编译器会动态地绑定到派生类对象的函数上。

  例如，假设有一个基类 Animal 和一个派生类 Cat，它们都有一个名为 makeSound 的虚函数。如果使用指针或引用来调用 makeSound 函数，则会根据指针或引用所指向的对象的类型来确定调用哪个函数。如果指针或引用指向 Cat 对象，则会调用 Cat 类的 makeSound 函数；如果指针或引用指向 Animal 对象，则会调用 Animal 类的 makeSound 函数。

  但是，如果将 Cat 对象赋值给 Animal 对象，则不会发生动态绑定。在这种情况下，Cat 对象会被隐式转换为 Animal 对象，只有 Animal 类的成员变量和成员函数会被保留，而 Cat 类的成员变量和成员函数将被忽略。因此，不会发生动态绑定。

  需要注意的是，将子类对象赋值给父类对象虽然不会发生动态绑定，但是可能会导致对象切片问题，即子类对象的信息被截断。如果想要避免对象切片问题，可以使用指针或引用来代替对象赋值。

- 

  

## STL


- vector的push_back操作的时间复杂度

  vector的push_back操作的时间复杂度为O(1)（摊还时间复杂度）。这是因为vector采用的是连续的内存空间，当向vector的末尾添加元素时，只需要在已分配的内存空间最后一个位置插入元素即可，时间复杂度为常数级别。但是，当vector的内存空间不足时，需要重新分配更大的内存空间并将原有元素复制到新的内存空间中，此时的时间复杂度为O(n)。但是，由于这种情况出现的概率很小，因此可以将其视为摊还时间复杂度为O(1)。

- 栈的时间复杂度、空间复杂度

  时间复杂度：栈的基本操作包括入栈和出栈，它们的时间复杂度都是 O(1)，即常数级别的时间复杂度。因为栈只允许在栈顶进行插入和删除操作，所以不需要遍历整个栈来查找元素，从而使得栈的操作非常高效。

  空间复杂度：栈的空间复杂度取决于栈的使用情况和实现方式。对于静态数组实现的栈，它的空间复杂度是固定的，即 O(n)，其中 n 表示数组的长度。而对于动态数组或链表实现的栈，它的空间复杂度会根据实际情况进行动态调整，最坏情况下为 O(n)，其中 n 表示栈中元素的个数。

- STL中仿函数有什么用，和函数指针有什么不同，哪个效率高

  STL 中的仿函数（Functor）是一种重载了函数调用运算符 () 的类，它可以像函数一样被调用。仿函数可以作为函数对象传递给 STL 算法或容器，用于自定义排序、查找、统计等操作的比较规则或操作规则。与函数指针相比，仿函数具有更高的灵活性和可定制性，可以通过类的成员变量来保存状态，也可以通过模板参数来实现更加通用的操作。 与函数指针相比，仿函数有以下优点：

  1. 仿函数可以保存状态，因为仿函数是一个类，可以将需要保存的状态保存在类的成员变量中，这样就可以在连续调用中保留状态，而函数指针不能保存状态；
  2. 仿函数可以通过模板参数来实现更加通用的操作，因为仿函数可以定义多个重载的 operator() 函数，可以根据需要进行不同的操作，而函数指针只能指向一个函数；
  3. 仿函数可以使用函数对象适配器来适应不同的算法或容器，例如，可以使用 std::bind 和 std::function 来适配不同的参数列表或返回类型。 

  相比之下，仿函数的效率可能稍低于函数指针，因为仿函数是一个类，需要实例化对象，而函数指针只需要保存一个指针。但是，由于仿函数可以保存状态，因此在一些需要保存状态的场合，例如排序算法，仿函数比函数指针更加有效。此外，现代编译器对于使用仿函数进行的优化，可能会使其效率更高。

- 使用 map 不是基础数据类型需要重载什么运算符

  使用 `map` 存储自定义类型时，需要重载 `<` 运算符，以便 `map` 能够正确地进行排序和查找。因为 `map` 是一种关联容器，它的内部实现依赖于对元素的排序，而排序依赖于元素之间的比较。如果没有重载 `<` 运算符，编译器不知道如何比较两个元素的大小，也就无法对 `map` 进行正确的排序和查找。 

  下面是一个示例代码，演示了如何重载 `<` 运算符来实现 `map` 的自定义类型：

  ```c
  #include <iostream>
  #include <map>
  using namespace std;
  class Person {
  public:
      Person(string name, int age) : m_name(name), m_age(age) {}
      string GetName() const { return m_name; }
      int GetAge() const { return m_age; }
  private:
      string m_name;
      int m_age;
  };
  bool operator<(const Person& lhs, const Person& rhs) {
      if (lhs.GetAge() < rhs.GetAge()) {
          return true;
      } else if (lhs.GetAge() == rhs.GetAge()) {
          return lhs.GetName() < rhs.GetName();
      } else {
          return false;
      }
  }
  int main() {
      map<Person, int> people;
      people[Person("Tom", 25)] = 1;
      people[Person("John", 30)] = 2;
      people[Person("Alice", 20)] = 3;
      for (const auto& p : people) {
          cout << p.first.GetName() << " " << p.first.GetAge() << " " << p.second << endl;
      }
      return 0;
  }
  ```

  在这个示例代码中，我们定义了一个 `Person` 类，包含了姓名和年龄两个成员变量。接着，我们重载了 `<` 运算符，按照年龄从小到大排序，如果年龄相等，则按照姓名从小到大排序。然后，我们定义了一个 `map` 对象 `people`，用于存储 `Person` 对象和一个整数。最后，我们遍历 `people` 对象，并输出每个 `Person` 对象的姓名、年龄和对应的整数。运行这个程序，输出结果如下：

  ```c
  Alice 20 3
  Tom 25 1
  John 30 2
  ```

  从输出结果可以看出，`map` 按照年龄从小到大排序，如果年龄相等，则按照姓名从小到大排序，这是由于我们重载了 `<` 运算符的缘故。

- STL容器的线程安全性

  线程安全的情况：

  - 多个读取者是安全的。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器；

  - 对不同容器的多个写入者是安全的，多线程可以同时写不同的容器；

  线程不安全的情况：

  - 在对同一个容器进行多线程的读写、写操作时；

  - 在每次调用容器的成员函数期间都要锁定该容器；

  - 在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；

  - 在每个在容器上调用的算法执行期间锁定该容器；

- 什么情况用栈什么情况用队列

  栈的应用：非常广泛，在CPU内部就有提供栈这个机制。主要用途：函数调用和返回，数字转字符，表达式求值，走迷宫等等。在CPU内部栈主要是用来进行子程序调用和返回，中断时数据保存和返回。在编程语言中：主要用来进行函数的调用和返回。可以说在计算机中，只要数据的保存满足先进后出的原理，都优先考虑使用栈，所以栈是计算机中不可缺的机制。

  队列的应用：队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制。windows中的消息机制就是通过队列来实现的。进程调度也是使用队列来实现，所以队列也是一个重要的机制，只要满足数据的先进先出原理就可以使用队列。

- vector扩容和realloc是需要直接拷贝吗？

  vector 扩容时会调用 `realloc` 或者分配新的内存，具体是哪种方式取决于当前内存的分配策略。

  如果当前内存是通过 `malloc` 系列函数分配的，那么扩容时会使用 `realloc` 进行内存的重新分配。`realloc` 会尝试在原有内存块的末尾或者相邻的空闲内存块中分配新的内存，如果找到合适的位置，就直接扩大内存块并返回指向原内存块的指针；如果找不到合适的位置，就会分配新的内存块，并将原内存块中的数据拷贝到新内存块中，最后释放原内存块。

  如果当前内存是通过 C++ 的 `new` 运算符分配的，那么扩容时会先分配新的内存块，然后将原内存块中的数据拷贝到新内存块中，最后释放原内存块。

  无论是使用 `realloc` 还是分配新的内存块，都需要将原有内存块中的数据拷贝到新的内存块中，因此 vector 扩容时是需要进行数据拷贝的。但是，在使用 `realloc` 进行内存重分配时，如果找到了相邻的空闲内存块，就可以避免数据拷贝，提高效率。

- push_back和emplace_back的区别

  `push_back` 和 `emplace_back` 都是 C++ STL 中 vector 容器的方法，它们的主要区别在于：

  1. 参数类型不同：`push_back` 的参数是一个对象，而 `emplace_back` 的参数是该对象的构造函数所需要的参数。

  2. 插入方式不同：`push_back` 在容器末尾添加一个元素，而 `emplace_back` 在容器末尾构造一个元素。

  3. 效率不同：由于 `emplace_back` 可以直接在容器末尾构造一个元素，而无需创建一个临时对象，因此 `emplace_back` 比 `push_back` 更高效。

  具体来说，`push_back` 会创建一个对象并将其复制到容器的末尾，在对象较大的情况下，这可能会导致效率低下。而 `emplace_back` 直接在容器的末尾构造一个对象，避免了对象复制的开销，因此效率更高。

  总之，`push_back` 和 `emplace_back` 在实现上有所不同，使用时需要根据具体的情况进行选择。如果需要将一个已经构造好的对象添加到容器中，可以使用 `push_back`；如果需要在容器中直接构造一个新的对象，可以使用 `emplace_back`。

- 怎么回收vector的空间

  在 C++11 之前，vector 中的空间只能用 `swap` 或 `clear` 方法来进行回收。

  1. 使用 `swap` 方法：可以把一个空的 vector 对象和需要回收空间的 vector 对象进行交换，从而实现空间的回收。示例代码如下：

     ```c
     std::vector<int>().swap(vec);
     ```

  2. 使用 `clear` 方法：可以清空 vector 中所有的元素，但并不会释放 vector 占用的内存空间。示例代码如下：

     ```c
     vec.clear();
     ```

  在 C++11 及以后的版本中，vector 提供了 `shrink_to_fit` 方法，可以释放 vector 占用的内存空间。示例代码如下：

  ```c
  vec.clear();
  vec.shrink_to_fit();
  ```

  需要注意的是，`shrink_to_fit` 方法并不是强制释放内存，而是请求释放多余的内存空间，具体是否释放内存取决于具体实现。如果需要确保 vector 释放了占用的内存空间，可以使用 `swap` 方法交换一个空的 vector 对象来实现。

  总之，回收 vector 的空间可以使用 `swap`、`clear` 或 `shrink_to_fit` 方法，需要根据具体情况选择适当的方法。

- resize 和 reserve的区别

  在 C++ 中，`resize()` 和 `reserve()` 都是用于动态分配内存的函数，但它们的功能和使用方式有所不同。

  `resize()` 函数用于改变容器的大小，即增加或减少容器中元素的个数，可以用以下方式调用：

  ```c
  vector<int> v;
  v.resize(10); // 将 v 容器中的元素个数改为 10，新增元素值为 0
  ```

  调用 `resize()` 函数之后，容器的大小会被改变，多出来的元素会被初始化为该类型的默认值（例如 `int` 类型的默认值是 0）。如果将容器大小减小，则多出来的元素会被删除。

  `reserve()` 函数用于预留容器的内存空间，但不会改变容器的大小，可以用以下方式调用：

  ```c
  vector<int> v;
  v.reserve(10); // 预留 v 容器中的内存空间，但不改变元素个数
  ```

  调用 `reserve()` 函数之后，容器会分配足够的内存空间以容纳指定数量的元素，但容器中的元素个数并不会改变。这样可以避免频繁地重新分配内存空间，提高代码的效率。

  需要注意的是，`reserve()` 函数只是预留了内存空间，并不会初始化新增的元素，因此在使用新增元素之前，需要使用其他方式将其初始化。

  总之，`resize()` 用于改变容器的大小，`reserve()` 用于预留容器的内存空间。在使用时需要根据具体的需求选择合适的函数。

- resize时，如果容器中是类的对象，STL怎么做

  当容器中存储的是类的对象时，调用 `resize()` 函数会按照以下方式进行处理：

  1. 如果容器大小增加，则默认构造函数会被调用来初始化新增元素，例如：

  ```c
  class MyClass {
  public:
      MyClass() { cout << "Default constructor called." << endl; }
      MyClass(int x) { cout << "Constructor with int argument called." << endl; }
  };
  
  vector<MyClass> v;
  v.resize(5); // 调用 5 次 MyClass 的默认构造函数
  ```

  上述代码中，调用 `resize(5)` 函数会将容器大小增加到 5，此时会调用 5 次 `MyClass` 的默认构造函数来初始化新增元素。

  2. 如果容器大小减小，则析构函数会被调用来销毁多余的元素，例如：

  ```c
  class MyClass {
  public:
      ~MyClass() { cout << "Destructor called." << endl; }
  };
  
  vector<MyClass> v;
  v.resize(5); // 调用 5 次 MyClass 的默认构造函数
  v.resize(3); // 调用 2 次 MyClass 的析构函数
  ```

  上述代码中，调用 `resize(5)` 函数会将容器大小增加到 5，此时会调用 5 次 `MyClass` 的默认构造函数来初始化新增元素；接着调用 `resize(3)` 函数将容器大小减小到 3，此时会调用 2 次 `MyClass` 的析构函数来销毁多余的元素。

  需要注意的是，如果类定义了自己的复制构造函数、移动构造函数或者赋值运算符重载函数，那么 `resize()` 函数在改变容器大小时会调用这些函数来复制或移动元素。如果类没有定义这些函数，则默认使用浅拷贝来复制元素，这可能会导致意外的行为。因此，在定义存储类对象的容器时，需要根据具体情况来定义适当的构造函数、析构函数和拷贝控制函数，以确保容器的行为符合预期。

- 数组和链表的区别

  数组和链表是两种常用的数据结构，它们在实现方式、特点和应用场景上都有很大的不同。

  1. 实现方式：

  数组是一种线性结构，它将一组相同类型的数据元素存储在一段连续的内存空间中，可以通过下标来访问数组中的元素。

  链表是一种非线性结构，它使用一组通过指针连接起来的节点来存储数据元素，每个节点包含一个数据元素和一个指向下一个节点的指针。

  2. 特点：

  数组具有随机访问的特点，在O(1)的时间复杂度内可以直接访问任意位置的元素，但在插入和删除元素时需要移动其他元素，效率较低。

  链表具有顺序访问的特点，在插入和删除元素时只需要修改相应节点的指针，效率较高，但在访问任意位置的元素时需要从头遍历链表，效率较低。

  3. 应用场景：

  数组适用于需要随机访问元素的场景，例如用于存储静态数据、实现矩阵等。

  链表适用于需要频繁插入和删除元素的场景，例如实现栈、队列、链式哈希表等。

  综上所述，数组和链表都有各自的优缺点和适用场景，选择哪种数据结构要根据具体的需求和问题来决定。

- string底层是如何分配空间的

  在 C++ 中，`std::string` 是一个类，它的底层实现通常是使用一个动态分配的字符数组来存储字符串。当我们创建一个 `std::string` 对象时，它会自动分配足够的内存来存储字符串，并在需要时自动调整内存大小。

  具体来说，当我们向 `std::string` 对象中添加字符时，它会先检查当前字符串的长度是否已经达到了分配的内存大小。如果达到了，它会分配一个新的更大的内存块，并将原字符串中的内容复制到新的内存块中，然后释放旧的内存块。这个过程被称为重新分配（re-allocation）。

  为了避免频繁的重新分配，`std::string` 通常会预留一定的额外空间。我们可以使用 `std::string::reserve()` 方法来手动指定预留的空间大小，以避免不必要的重新分配。

  另外，C++11 引入了一种称为短字符串优化（SBO，Short String Optimization）的技术，它允许 `std::string` 存储较短的字符串（通常不超过 15 个字符）时，直接将字符串存储在对象本身的内存空间中，而不需要额外的动态分配内存。

  总之，`std::string` 底层的空间分配是一个动态分配的过程，它会自动调整内存大小以适应字符串的长度，并预留一定的额外空间以避免频繁地重新分配。

- string是如何存储数据的，具体过程？为什么会扩容2倍或1.5倍？

  在 C++ 中，`std::string` 是一个类，用于表示字符串。`std::string` 内部采用动态数组的方式来存储字符串数据，可以动态地增加或减少其所占用的内存空间。以下是 `std::string` 内部存储数据的具体过程：

  1. `std::string` 内部使用一个指针来指向存储字符串的内存空间，称为字符数组或缓冲区（buffer）。

  2. 当创建一个 `std::string` 对象时，会为字符数组分配一块初始内存空间，用来存储字符串的初始数据。

  3. 如果字符串的长度超过了字符数组的大小，`std::string` 会自动扩容。扩容的过程如下：

     - `std::string` 会先根据当前字符串的长度和一个称为“容量（capacity）”的值来判断是否需要扩容。容量是指字符数组当前所能容纳的字符数。

     - 如果当前字符串的长度已经等于或超过了容量，`std::string` 就会分配一块更大的内存空间，并将原来的数据复制到新的内存空间中。

     - 扩容后的容量通常是原来容量的两倍或者是原来容量加上一个固定的值，比如 1.5 倍。这是因为如果每次只扩容一个字符，会导致频繁地重新分配内存空间，影响性能。

     - 扩容后，`std::string` 会更新字符数组的指针，使其指向新的内存空间。

  4. 当删除字符串中的字符时，`std::string` 也会自动缩容。缩容的过程和扩容相似，但会释放多余的内存空间，以便其他程序可以使用。

  综上所述，`std::string` 采用动态数组的方式来存储字符串数据，可以动态地增加或减少其所占用的内存空间。扩容时，`std::string` 根据当前字符串的长度和容量来判断是否需要扩容，并分配一块更大的内存空间。通常情况下，扩容的大小是原来容量的两倍或者是原来容量加上一个固定的值。

- 如果把一个类传递给map的key值，需要加什么操作吗？

  如果要将一个类的对象作为map的key值，需要满足两个条件：

  1. 该类必须支持比较运算符（operator<），以便能够比较两个对象的大小关系。

  2. 比较运算符必须正确实现，以保证对象之间的比较不出错。

  如果类已经支持比较运算符，那么可以直接将其对象作为map的key值，例如：

  ```c
  #include <map>
  #include <string>
  
  class Person {
  public:
      std::string name;
      int age;
      
      bool operator<(const Person& other) const {
          return name < other.name;
      }
  };
  
  int main() {
      std::map<Person, int> personMap;
      
      Person p1 = {"Tom", 20};
      Person p2 = {"Jerry", 18};
      
      personMap[p1] = 100;
      personMap[p2] = 200;
      
      return 0;
  }
  ```

  在上面的例子中，Person类实现了比较运算符，将其对象作为map的key值，不需要进行额外的操作。

  需要注意的是，当将一个类的对象作为map的key值时，应该避免修改对象的属性，以免影响map的正确性和可靠性。另外，也需要注意对象比较的效率和性能，避免影响程序的执行效率和响应速度。

- vector和list的区别？

  STL中的vector和list也是两个常用的容器，它们有以下主要区别：

  1. 存储方式：vector是基于数组实现的动态数组，支持随机访问，可以通过下标或迭代器访问元素；而list是基于双向链表实现的，不支持随机访问，只能通过迭代器访问元素。

  2. 容器大小：vector在每次插入元素时，可能需要重新分配内存空间，而list不需要。因此，当需要插入大量元素时，list的性能可能会优于vector。

  3. 内存分配：vector在每次插入元素时，可能需要重新分配内存空间，而list不需要。因此，vector的内存分配比list更加高效，但是可能会带来内存碎片的问题。

  4. 迭代器失效：vector在插入或删除元素时，可能会导致迭代器失效，而list不会。因此，在需要频繁插入或删除元素的情况下，可以选择使用list。

  5. 性能：vector支持随机访问，因此在需要频繁进行随机访问的情况下，其性能可能会优于list。而list在需要频繁进行插入或删除操作的情况下，其性能可能会优于vector。

  总的来说，vector和list都是常用的容器，各自具有不同的特点和适用场景。如果需要随机访问元素，可以选择使用vector；如果需要频繁进行插入或删除操作，可以选择使用list。

- vector底层工作原理

  在 C++ 中，vector 是一种动态数组，可以自动调整其大小以适应存储元素的需求。vector 的底层实现是一个连续存储空间，它使用指针来管理存储空间，并提供了一系列的方法来操作存储的元素。

  vector 的底层实现可以分为三个部分：容量管理、元素存储和元素访问。

  1. 容量管理：vector 使用指针来管理存储空间，其中包括指向存储区域的首地址、尾地址和容量。容量表示 vector 已经分配的存储空间大小，它可能大于或等于 vector 中元素的个数。当 vector 中的元素数量超过容量时，vector 将重新分配更大的存储空间，并将原有的元素复制到新的存储空间中。这种操作称为“重新分配”，它会导致指向原有存储空间的指针失效。为了避免频繁的重新分配操作，vector 通常会预留一定的存储空间，以便在添加新元素时不需要重新分配存储空间。
  
  2. 元素存储：vector 的元素存储在连续的内存空间中，每个元素占用一个位置。当元素数量超过容量时，vector 将重新分配更大的存储空间，并将原有的元素复制到新的存储空间中。vector 中的元素存储顺序是连续的，因此可以通过指针和下标运算符来访问元素。
  
  3. 元素访问：vector 提供了多种方法来访问元素，包括下标运算符、迭代器和指针。下标运算符可以直接访问元素，迭代器可以遍历元素，指针可以指向元素的地址。vector 还提供了一些方法来添加、删除和修改元素，包括 push_back、insert、erase 等方法。
  
  需要注意的是，在 vector 中添加、删除和修改元素可能会导致存储空间的重新分配，从而导致指向原有存储空间的指针失效。因此，在对 vector 进行添加、删除和修改操作时，需要小心处理指针和迭代器，以避免出现指针失效的情况。
  
- STL sort()的底层实现

  STL（标准模板库）中的 sort() 函数是一个非常常用的排序函数，它的底层实现是使用快速排序（Quick Sort）算法和插入排序（Insertion Sort）算法的混合排序。

  具体来说，当排序的序列大小小于阈值时，sort() 函数会使用插入排序，否则会使用快速排序。在快速排序中，sort() 函数会选择序列中的一个元素作为枢轴（pivot），将序列分成两个部分，左部分的元素都小于等于枢轴，右部分的元素都大于枢轴，然后递归地对左右两部分进行排序。为了提高快速排序的效率，sort() 函数还会采取一些优化措施，例如随机选择枢轴、三点取中法等。

  需要注意的是，sort() 函数是一个通用的排序函数，可以对各种类型的序列进行排序，因此在实现上需要使用模板和函数指针等技术，使得 sort() 函数可以接受各种类型的参数和排序规则。

  另外，STL 中的 sort() 函数并不是最优秀的排序算法，因为它的最坏时间复杂度为 O(N^2)，而且在某些情况下，它的性能也不如其他排序算法。因此，在实际应用中，需要根据具体问题的特点选择合适的排序算法，以获得最好的性能。

- 

  

  

  

  

